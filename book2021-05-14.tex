% Why direct style instead of continuation passing style?

%% Student project ideas:
%%   * high-level optimizations like procedure inlining, etc.
%%   * closure optimization
%%   * adding letrec to the language
%%     (Thought: in the book and regular course, replace top-level defines
%%      with letrec.)
%%   * alternative back ends (ARM!, LLVM)
%%   * alternative calling convention (a la Dybvig)
%%   * lazy evaluation
%%   * continuations (frames in heap a la SML or segmented stack a la Dybvig)
%%   * exceptions
%%   * self hosting
%%   * I/O
%%   * foreign function interface
%%   * quasi-quote and unquote
%%   * macros (too difficult?)
%%   * alternative garbage collector
%%   * alternative register allocator
%%   * type classes
%%   * loop optimization (fusion, etc.)
%%   * deforestation
%%   * records with subtyping
%%   * object-oriented features
%%     - objects, object types, and structural subtyping (e.g. Abadi & Cardelli)
%%     - class-based objects and nominal subtyping (e.g. Featherweight Java)
%%   * multi-threading, fork join, futures, implicit parallelism
%%   * type analysis and specialization


\documentclass[11pt]{book}
\usepackage{ctex}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[numbers]{natbib}
\usepackage{stmaryrd}
\usepackage{xypic}
\usepackage{semantic}
\usepackage{wrapfig}
\usepackage{tcolorbox}
\usepackage{multirow}
\usepackage{color}
\usepackage{upquote}
\usepackage{makeidx}
%\usepackage{framed}

\makeindex

\definecolor{lightgray}{gray}{1}
\newcommand{\black}[1]{{\color{black} #1}}
%\newcommand{\gray}[1]{{\color{lightgray} #1}}
\newcommand{\gray}[1]{{\color{gray} #1}}



%% For pictures
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
\tikzset{baseline=(current bounding box.center), >/.tip={Triangle[scale=1.4]}}

% Computer Modern is already the default. -Jeremy
%\renewcommand{\ttdefault}{cmtt}

\definecolor{comment-red}{rgb}{0.8,0,0}
\if01
\newcommand{\rn}[1]{{\color{comment-red}{(RRN: #1)}}}
\newcommand{\margincomment}[1]{\marginpar{\color{comment-red}\tiny #1}}
\else
\newcommand{\rn}[1]{}
\newcommand{\margincomment}[1]{}
\fi

\lstset{%
language=Lisp,
basicstyle=\ttfamily\small,
morekeywords={seq,assign,program,block,define,lambda,match,goto,if,else,then,struct,Integer,Boolean,Vector,Void,Any,while,begin,define,public,override,class},
deletekeywords={read,mapping,vector},
escapechar=|,
columns=flexible,
moredelim=[is][\color{red}]{~}{~},
showstringspaces=false
}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{constraint}[theorem]{Constraint}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{exercise}[theorem]{Exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 'dedication' environment: To add a dedication paragraph at the start of book %
% Source: http://www.tug.org/pipermail/texhax/2010-June/015184.html            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newenvironment{dedication}
{
   \cleardoublepage
   \thispagestyle{empty}
   \vspace*{\stretch{1}}
   \hfill\begin{minipage}[t]{0.66\textwidth}
   \raggedright
}
{
   \end{minipage}
   \vspace*{\stretch{3}}
   \clearpage
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter quote at the start of chapter        %
% Source: http://tex.stackexchange.com/a/53380 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter
\renewcommand{\@chapapp}{}% Not necessary...
\newenvironment{chapquote}[2][2em]
  {\setlength{\@tempdima}{#1}%
   \def\chapquote@author{#2}%
   \parshape 1 \@tempdima \dimexpr\textwidth-2\@tempdima\relax%
   \itshape}
  {\par\normalfont\hfill--\ \chapquote@author\hspace*{\@tempdima}\par\bigskip}
\makeatother

\input{defs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{\Huge \textbf{编译基础} \\
  \huge 增量的微通道方法}

\author{\textsc{Jeremy G. Siek} \\
%\thanks{\url{http://homes.soic.indiana.edu/jsiek/}} \\
  印第安纳大学 \\
  \\
  贡献者： \\
  Carl Factora \\
  Andre Kuhlenschmidt \\
  Ryan R. Newton \\
  Ryan Scott \\
  Cameron Swords \\
  Michael M. Vitousek \\
  Michael Vollmer \\
  \\
  吴华均\  译
   }

\begin{document}

\frontmatter
\maketitle

\begin{dedication}
这本书是献给印第安纳大学的编程语言专家。
\end{dedication}

\renewcommand{\contentsname}{目录}
\renewcommand{\figurename}{图}
\renewcommand\listfigurename{插图目录}
\renewcommand{\bibname}{参考文献}
\renewcommand{\tablename}{表}
\tableofcontents
\listoffigures

%\renewcommand{\footnotesize}{\fontsize{8pt}{2pt}\selectfont}
%\listoftables

\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{前言}
\label{ch:qianyan}

当程序员按下“运行”按钮，软件就开始运行，这是一个神奇的时刻。不知何故，用某种高级语言编写的程序只能以某种方式在能位转换的计算机上运行。下面我们就来揭示让这一刻成为可能的魔法。从20世纪50年代 Backus 及其同事的突破性工作开始，计算机科学家发现构造程序的技术，称为 \emph{编译器}, ，它可以自动将高级程序转换为机器代码。

我们为一门小而强大的语言构建自己的编译器，带你踏上征程。在此过程中，我们解释编译器基础的基本概念、算法和数据结构。帮助你理解程序是如何映射到计算机硬件上，这有助于在硬件和软件之间的连接点进行推理，如执行时间、软件错误和安全漏洞。对于那些对编译器构造感兴趣的人，我们的目标是为高级主题(如即时编译、程序分析和程序优化)提供一个跳板。对于那些对设计和实现自己的编程语言感兴趣的人，将语言设计选择与它们对编译器产生的代码的影响联系起来。

编译器通常被组织成一系列的阶段，逐步地把程序翻译成在硬件上运行的代码。我们将编译器划分为大量的 \emph{微通道} ，每个微通道执行一项任务，从而达到极致。这使我们能够独立地测试每个通道的输出，而且，允许我们集中精力使编译器更容易理解。

%% [TODO: easier to understand/debug for those maintaining the compiler,
%%   proving correctness]

最常见的描述编译器的方法是每一章进行一次编译。这样做的问题是，它混淆了语言特性如何在编译器中激发设计选择。我们采用一种
\emph{增量} 的方法，在每一章中构建一个完整的编译器，从算术和变量开始，并在随后的章节中添加新的特性。

我们对语言特性的选择是为了引出编译器中使用的基本概念和算法。
\begin{itemize}
\item 第~\ref{ch:trees-recur} 章和第 \ref{ch:Rvar} 章，从整数算术和局部变量开始，介绍编译器构造的基本工具:  \emph{抽象语法树} 和 \emph{递归函数} 。
\item 第~\ref{ch:register-allocation-Rvar} 章中，用
  \emph{图着色} 给机器寄存器变量赋值。
\item 第~\ref{ch:Rif} 章增加 \code{if} 表达式，这激发一个优雅的递归算法，用于将表达式映射到
  \emph{控制流图} 。
\item 第~\ref{ch:Rvec} 章增加堆分配元组，促进
  \emph{垃圾收集} 。
\item 第~\ref{ch:Rfun} 章添加一等变量，但没有词法作用域，这与C编程语言~\citep{Kernighan:1988nx} 类似，只是我们生成有效的尾部调用。读取器了解过程调用堆栈、
  \emph{调用约定} 以及它们与寄存器分配和垃圾收集的交互。
\item 第~\ref{ch:Rlam} 章增加具有词法作用域的匿名函数，即 \emph{lambda 抽象} 。学习
  \emph{闭包转换} ，在闭包转换中，lambdas被转换为函数和元组的组合。
\item 第~\ref{ch:Rdyn} 章增加 \emph{动态类型} 。在此之前，输入语言是静态类型的。读取器使用 \code{Any} 类型扩展静态类型语言，作为编译动态类型语言的目标。
\item 第~\ref{ch:Rwhile} 章通过添加循环和可变变量来充实对命令式编程语言的支持。这些增加引出在寄存分配器中进行 \emph{数据流分析} 的需要。
\item 第~\ref{ch:Rgrad} 章使用第~\ref{ch:Rdyn} 章的 \code{Any} 类型来实现一种 \emph{逐渐类型化语言}
  ，在这种语言中，程序的不同区域可以是静态类型的，也可以是动态类型的。读取器为 \emph{代理} 实现运行时支持，以允许值在区域之间安全移动。
\item 第~\ref{ch:Rpoly} 章利用在第 \ref{ch:Rdyn} 章和第 \ref{ch:Rgrad} 章中开发的 \code{Any} 类型和类型强制转换，增加带有自动装箱功能的 \emph{泛型} 。
\end{itemize}
有许多语言特性我们没有包括在内。我们的选择是在特性附带的复杂性和它所暴露的基本概念之间进行权衡。例如，我们包含元组而不包含记录，因为它们都引出对堆分配和垃圾回收的研究，但是记录带有更多的附带复杂性。

自2016年起，这本书作为印第安纳大学编译课程的教材，这是一门专为高年级本科生和一年级研究生开设的16周课程。
%
在这门课程之前，学生学习命令式语言和函数式语言编程，学习数据结构和算法，并学习离散数学。
%
课程开始时，学生以2-4人为一组。每个小组每两周完成一章，从第~\ref{ch:Rvar} 章开始，到第~\ref{ch:Rdyn} 章结束。许多章节包括我们分配给研究生的一个具有挑战性的问题。本课程的最后两周包括一个期末专题，在这个专题中，学生设计并实现他们所选择的编译器扩展。第~\ref{ch:Rwhile} 章、第 \ref{ch:Rgrad} 章和第
\ref{ch:Rpoly} 章可以用来支持这些项目，或者它们可以取代前面的一些章节。例如，一门强调静态类型命令式语言的课程会跳过第~\ref{ch:Rdyn} 章，而选择第~\ref{ch:Rwhile} 章。图~\ref{fig:chapter-dependences} 描述章节之间的依赖关系。

本书还在加利福尼亚州立理工大学，罗斯-霍尔曼技术学院和麻萨诸塞州洛厄尔大学的编译器课程中使用过。


\begin{figure}[tp]
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
  \node (C1) at (0,1.5) {\small 第~\ref{ch:trees-recur} 章 预备知识};
  \node (C2) at (4,1.5) {\small 第~\ref{ch:Rvar} 章 变量};
  \node (C3) at (8,1.5) {\small 第~\ref{ch:register-allocation-Rvar} 章 寄存器};
  \node (C4) at (0,0) {\small 第~\ref{ch:Rif} 章 控制流};
  \node (C5) at (4,0) {\small 第~\ref{ch:Rvec} 章 元组};
  \node (C6) at (8,0) {\small 第~\ref{ch:Rfun} 章 函数};
  \node (C9) at (0,-1.5) {\small 第~\ref{ch:Rwhile} 章 循环};
  \node (C8) at (4,-1.5) {\small 第~\ref{ch:Rdyn} 章 动态};
  \node (C7) at (8,-1.5) {\small 第~\ref{ch:Rlam} 章 Lambda};
  \node (C10) at (4,-3) {\small 第~\ref{ch:Rgrad} 章 渐变};
  \node (C11) at (8,-3) {\small 第~\ref{ch:Rpoly} 章 泛型};

  \path[->] (C1) edge [above] node {} (C2);
  \path[->] (C2) edge [above] node {} (C3);
  \path[->] (C3) edge [above] node {} (C4);
  \path[->] (C4) edge [above] node {} (C5);
  \path[->] (C5) edge [above] node {} (C6);
  \path[->] (C6) edge [above] node {} (C7);
  \path[->] (C4) edge [above] node {} (C8);
  \path[->] (C4) edge [above] node {} (C9);
  \path[->] (C8) edge [above] node {} (C10);
  \path[->] (C10) edge [above] node {} (C11);
\end{tikzpicture}
  \caption{章节依赖关系图。}
  \label{fig:chapter-dependences}
\end{figure}

我们在编译器的实现和输入语言中都使用 \href{https://racket-lang.org/}{Racket} 语言，所以读者应该精通 Racket 或 Scheme 。有很多很好的学习 Scheme 和 Racket的资源~\citep{Dybvig:1987aa,Abelson:1996uq,Friedman:1996aa,Felleisen:2001aa,Felleisen:2013aa,Flatt:2014aa} 。本书的支持代码在github存储库中，网址如下：
\begin{center}\small
  \url{https://github.com/IUCompilerCourse/public-student-support-code}
\end{center}

该编译器的目标是x86汇编语言~\citep{Intel:2015aa} ，所以对于已经上过计算机系统课程~\citep{Bryant:2010aa} 的读者来说是有帮助的，但不是必需的。本书介绍需要的x86-64汇编语言的部分。
%
我们遵循 System V 调用约定~\citep{Bryant:2005aa,Matz:2013aa} ，所以当我们生成的汇编代码在 Linux 和 MacOS 操作系统上使用 GNU C 编译器 (\code{gcc}) 编译时，它与运行时系统一起工作(用C编写)。
%
在Windows操作系统上， \code{gcc} 使用 Microsoft x64 调用约定~\citep{Microsoft:2018aa,Microsoft:2020aa} 。因此，我们生成的汇编代码 \emph{不能} 与 Windows 上的运行时系统一起工作。一种解决方案是使用 Linux 虚拟机作为客户操作系统。

\section*{致谢}

编译器构造在印第安纳大学的传统可以追溯到 Daniel Friedman 在20世纪70年代和80年代的编程语言研究和课程。他的一个学生 Kent Dybvig 实现了
Chez Scheme~\citep{Dybvig:2006aa} ，这是一个针对 Scheme 的高质量、高效的编译器。在20世纪90年代和2000年代，Dybvig教授编译器课程，并继续开发 Chez Scheme 。
%
编译器课程发展到融合新颖的教学思想，同时也包括有效的现实世界编译器的元素。Friedman 的一个想法是把编译器分成许多小的通道。另一个被称为“游戏”的想法是测试每一个解释器的通道生成的代码。

在他的学生 Dipanwita Sarkar 和 Andrew Keep 的帮助下，Dybvig 开发支持这种方法的基础设施，并发展使用更小微通道的课程~\citep{Sarkar:2004fk,Keep:2012aa}。本书中的许多编译器设计决策都受到 \citet{Dybvig:2010aa} 的赋值描述的启发。在2000年中期，Dybvig 的一个名叫 Abdulaziz Ghuloum 的学生注意到，课程的前后结构让学生很难理解编译器设计的基本原理。Ghuloum 提出了增量方法~\citep{Ghuloum:2006bh} 。

我们感谢 Bor-Yuh Chang 、 John Clements 、 Jay McCarthy 、 Joseph Near 、 Nate
Nystrom 和 Michael Wollowski ，他们基于早期草稿教授课程。

我们感谢 Ronald Garcia 在2000年早期与 Jeremy 学习编译器课程时成为他们的合作伙伴，尤其感谢他找到让垃圾收集器白费力气的 bug !

\mbox{}\\
\noindent Jeremy G. Siek \\
Bloomington, Indiana

%Oscar Waddell ??



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{预备知识}
\label{ch:trees-recur}

在本章中，回顾实现编译器所需的基本工具。程序通常是由程序员以文本形式输入的，也就是一串字符。程序即文本表示称为 \emph{具体语法} 。我们用具体的语法来简明地写和讨论程序。在编译器内部，使用
\emph{抽象语法树} (AST) ，以一种有效支持编译器要执行的操作方式来表示程序。\index{concrete syntax}\index{abstract syntax}\index{abstract
  syntax tree}\index{AST}\index{program}\index{parse} 从具体语法到抽象语法的转换过程称为
\emph{解析}~\citep{Aho:1986qf} 。在本书中，不涉及解析的理论和实现。在支持代码中提供一个解析器，将具体语法转换为抽象语法。

在编译器中，AST 可以以多种不同的方式表示，这取决于编写编译器所用的编程语言。
%
使用 Racket 的 \href{https://docs.racket-lang.org/guide/define-struct.html}{\code{struct}}
 特性来表示 AST (第~\ref{sec:ast} 节) 。使用语法来定义编程语言的抽象语法
(第~\ref{sec:grammar} 节) ，使用模式匹配来检查 AST 中的单个节点 (第~\ref{sec:pattern-matching} 节) 。使用递归函数来构造和解构 AST
(第~\ref{sec:recursion} 节) 。本章简要介绍这些概念。  \index{struct}

\section{抽象语法树和 Racket 结构}
\label{sec:ast}

编译器使用抽象语法树来表示程序，因为他们经常需要问这样的问题：对于程序的给定部分，它是什么样的语言特性?它的子部分是什么?考虑左边的程序和右边的 AST 。这个程序是一个加法操作，它有两个子部分，一个读操作和一个求反。否定还有另一个子部分，整数常数
\code{8} 。通过使用树来表示程序，可以很容易地按照链接从程序的一个部分走到它的子部分。
\begin{center}
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
(+ (read) (- 8))
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{equation}
\begin{tikzpicture}
 \node[draw, circle] (plus)  at (0 ,  0) {\key{+}};
 \node[draw, circle] (read)  at (-1, -1.5) {{\footnotesize\key{read}}};
 \node[draw, circle] (minus) at (1 , -1.5) {$\key{-}$};
 \node[draw, circle] (8)     at (1 , -3) {\key{8}};

 \draw[->] (plus) to (read);
 \draw[->] (plus) to (minus);
 \draw[->] (minus) to (8);
\end{tikzpicture}
\label{eq:arith-prog}
\end{equation}
\end{minipage}
\end{center}
使用树的标准术语来描述 AST ：上面的每个圆称为\emph{节点} 。箭头将节点连接到它的
\emph{子节点} (它们也是节点) 。最上面的节点是
\emph{根节点} 。除了根节点之外，每个节点都有其\emph{父节点} (其父节点是子节点) 。如果一个节点没有子节点，它就是一个\emph{叶} 节点。否则就是\emph{内部} 节点。
\index{node}
\index{children}
\index{root}
\index{parent}
\index{leaf}
\index{internal node}

%% Recall that an \emph{symbolic expression} (S-expression) is either
%% \begin{enumerate}
%% \item an atom, or
%% \item a pair of two S-expressions, written $(e_1 \key{.} e_2)$,
%%     where $e_1$ and $e_2$ are each an S-expression.
%% \end{enumerate}
%% An \emph{atom} can be a symbol, such as \code{`hello}, a number, the
%% null value \code{'()}, etc.  We can create an S-expression in Racket
%% simply by writing a backquote (called a quasi-quote in Racket)
%% followed by the textual representation of the S-expression.  It is
%% quite common to use S-expressions to represent a list, such as $a, b
%% ,c$ in the following way:
%% \begin{lstlisting}
%% `(a . (b . (c . ())))
%% \end{lstlisting}
%% Each element of the list is in the first slot of a pair, and the
%% second slot is either the rest of the list or the null value, to mark
%% the end of the list. Such lists are so common that Racket provides
%% special notation for them that removes the need for the periods
%% and so many parenthesis:
%% \begin{lstlisting}
%% `(a b c)
%% \end{lstlisting}
%% The following expression creates an S-expression that represents AST
%% \eqref{eq:arith-prog}.
%% \begin{lstlisting}
%% `(+ (read) (- 8))
%% \end{lstlisting}
%% When using S-expressions to represent ASTs, the convention is to
%% represent each AST node as a list and to put the operation symbol at
%% the front of the list. The rest of the list contains the children.  So
%% in the above case, the root AST node has operation \code{`+} and its
%% two children are \code{`(read)} and \code{`(- 8)}, just as in the
%% diagram \eqref{eq:arith-prog}.

%% To build larger S-expressions one often needs to splice together
%% several smaller S-expressions. Racket provides the comma operator to
%% splice an S-expression into a larger one. For example, instead of
%% creating the S-expression for AST \eqref{eq:arith-prog} all at once,
%% we could have first created an S-expression for AST
%% \eqref{eq:arith-neg8} and then spliced that into the addition
%% S-expression.
%% \begin{lstlisting}
%% (define ast1.4 `(- 8))
%% (define ast1.1 `(+ (read) ,ast1.4))
%% \end{lstlisting}
%% In general, the Racket expression that follows the comma (splice)
%% can be any expression that produces an S-expression.

为每种节点定义一个 Racket \code{struct} 。本章只需要两种节点：一种用于整型常量，另一种用于基本操作。下面是整型常量的\code{struct}
 的定义。
\begin{lstlisting}
(struct Int (value))
\end{lstlisting}
整数节点只包括一个东西：整数值。为整数 $8$ 创建AST节点，写下 \code{(Int 8)} 。
\begin{lstlisting}
(define eight (Int 8))
\end{lstlisting}
\code{(Int 8)} 创建的值是\code{Int} 结构体的一个\emph{实例} 。

下面是原语操作的 \code{struct} 定义。
\begin{lstlisting}
(struct Prim (op args))
\end{lstlisting}
一个原语操作节点包括一个操作符符号\code{op}
和一组子 \code{args} 。例如，要创建一个对数字 $8$ 求反的AST，可以这样写\code{(Prim '- (list eight))} 。
\begin{lstlisting}
(define neg-eight (Prim '- (list eight)))
\end{lstlisting}
原始操作可以有0个或多个子操作。\code{read} 操作符有0个子操作符：
\begin{lstlisting}
(define rd (Prim 'read '()))
\end{lstlisting}
而加法运算符有两个子操作符：
\begin{lstlisting}
(define ast1.1 (Prim '+ (list rd neg-eight)))
\end{lstlisting}

我们对\code{Prim} 的结构做出设计选择。
与其为许多不同的操作
(\code{read} 、 \code{+} 和 \code{-}) 使用一个结构，不如为每个操作定义一个结构，如下所示。
\begin{lstlisting}
(struct Read ())
(struct Add (left right))
(struct Neg (value))
\end{lstlisting}
选择只使用一种结构的原因是，在编译器的许多部分中，不同原语操作符的代码是相同的，所以我们不妨只编写一次代码，这是通过使用单一结构来实现的。

当编译像 \eqref{eq:arith-prog} 这样的程序时，需要知道与根节点相关的操作是加法，并且要能访问它的两个子节点。Racket 提供模式匹配来支持这类查询，如在~\ref{sec:pattern-matching} 节中看到的。

在这本书中，通常写下程序的具体语法，即使我们脑子里已经有AST，因为具体语法更简洁。我们建议，在头脑中，始终把程序看作是抽象语法树。

\section{语法}
\label{sec:grammar}
\index{integer}
\index{literal}
\index{constant}

编程语言可以被看作是程序的\emph{集合} 。
集合通常是无限的(人们总是可以创建越来越大的程序)，所以不能简单地通过列出语言中的所有程序来描述一种语言。相反，我们写下一套规则，一套
\emph{语法} ，来构建程序。语法通常用来定义一种语言的具体语法，但它们也可以用来描述抽象语法。我们用
Backus-Naur 形式 (BNF)~\citep{Backus:1960aa,Knuth:1964aa} 。
\index{Backus-Naur Form}\index{BNF} 例如，描述一种名为\LangInt{} 的小语言，它由整数和算术运算组成。
\index{grammar}

\LangInt{} 的抽象语法的第一个语法规则是\code{Int} 结构的一个实例是一个表达式：
\begin{equation}
\Exp ::= \INT{\Int}  \label{eq:arith-int}
\end{equation}
%
每条规则都有左手边和右手边。读取规则的方法是，如果有一个与右手边匹配的 AST 节点，那么可以根据左手边对它进行分类。
%
语法规则定义的名称，如 $\Exp$ ，是\emph{非终端符} 。  \index{non-terminal}
%
名称 $\Int$ 也是一个非终端符，但我们没有使用语法规则来定义它，而是使用以下解释来定义它。我们做出简化设计的决定，即本书中所有的语言都只处理机器可表示的整数。在大多数现代机器上，这对应于用64位表示的整数，也就是 $-2^{63}$ 到 $2^{63}-1$ 的范围。我们进一步限制这个范围，以匹配 Racket \texttt{fixnum} 数据类型，它允许64位机器上的63位整数。因此， $\Int$ 是一个十进制序列
($0$ 到 $9$) ，可能从 $-$ (对于负整数)开始，因此十进制序列表示范围为 $-2^{62}$
到 $2^{62}-1$ 的整数。

第二条语法规则是 \texttt{read} 操作，它从程序的用户那里接收一个输入整数。
\begin{equation}
  \Exp ::= \READ{} \label{eq:arith-read}
\end{equation}

第三条规则是，给定一个 $\Exp$ 节点，该节点的否定也是一个 $\Exp$ 。
\begin{equation}
  \Exp ::= \NEG{\Exp}  \label{eq:arith-neg}
\end{equation}
打字机字体中的符号，如 \key{-} 和 \key{read} ，都是
\emph{终端} 符号，必须按字面意思出现在程序中，规则才能适用。
\index{terminal}

可以用这些规则对
\LangInt{} 语言中的 AST 进行分类。例如，根据规则 \eqref{eq:arith-int}
\texttt{(Int 8)} 是 $\Exp$ ，那么根据规则 \eqref{eq:arith-neg} 下面的 AST 是 $\Exp$ 。
\begin{center}
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
(Prim '- (list (Int 8)))
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.25\textwidth}
\begin{equation}
\begin{tikzpicture}
 \node[draw, circle] (minus) at (0, 0)  {$\text{--}$};
 \node[draw, circle] (8)     at (0, -1.2) {$8$};

 \draw[->] (minus) to (8);
\end{tikzpicture}
\label{eq:arith-neg8}
\end{equation}
\end{minipage}
\end{center}

下一条语法规则是关于加法表达式的：
\begin{equation}
  \Exp ::= \ADD{\Exp}{\Exp} \label{eq:arith-add}
\end{equation}
现在可以证明 AST \eqref{eq:arith-prog} 是
\LangInt{} 中的 $\Exp$ 。我们知道 \lstinline{(Prim 'read '())} 是规则
\eqref{eq:arith-read} 的 $\Exp$ ，并且已经将 \code{(Prim '-
  (list (Int 8)))} 归类为 $\Exp$ ，根据规则 \eqref{eq:arith-add}
表明
\begin{lstlisting}
(Prim '+ (list (Prim 'read '()) (Prim '- (list (Int 8)))))
\end{lstlisting}
是 \LangInt{} 语言中的 $\Exp$ 。

如果有一个不适用上述规则的 AST ，那么这个 AST 就不是 \LangInt{} 。例如，程序 \code{(- (read) (+ 8))}
不在 \LangInt{} 中，因为对于只有一个参数的 \code{+} 有规则，对于有两个参数的 \key{-} 也没有规则。 当我们用语法定义一种语言时，这种语言只包括那些符合规则的程序。

 \LangInt{} 的最后一条语法规则是有一个\code{Program} 节点来标记整个程序的顶部：
\[
  \LangInt{} ::= \PROGRAM{\code{'()}}{\Exp}
\]
 \code{Program} 结构的定义如下
\begin{lstlisting}
(struct Program (info body))
\end{lstlisting}
这里的 \code{body} 是一个表达式。在后面的章节中， \code{info} 部分将被用来存储辅助信息，但目前它只是一个空列表。

很多语法规则左手边相同，右手边不同，这是很常见的，比如 \LangInt{} 语法中的$\Exp$ 规则。作为一种简写，竖条可以用来将几个右手边组合成一条规则。

我们收集图~\ref{fig:r0-syntax} 中\LangInt{}
抽象语法的所有语法规则。 \LangInt{} 的具体语法在图~\ref{fig:r0-concrete-syntax} 中定义。

支持代码\code{utilities.rkt} 中提供的 \code{read-program} 函数从文件( Racket 具体语法中的字符序列)中读取程序，并将其解析为一个抽象语法树。更多细节请参阅附录~\ref{appendix:utilities} 中对\code{read-program} 的描述。


\begin{figure}[tp]
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{rcl}
\begin{array}{rcl}
  \Exp &::=& \Int \mid \LP\key{read}\RP \mid \LP\key{-}\;\Exp\RP \mid \LP\key{+} \; \Exp\;\Exp\RP\\
  \LangInt{} &::=& \Exp
\end{array}
\end{array}
\]
\end{minipage}
}
\caption{\LangInt{} 的具体语法。}
\label{fig:r0-concrete-syntax}
\end{figure}

\begin{figure}[tp]
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{rcl}
\Exp &::=& \INT{\Int} \mid \READ{} \mid \NEG{\Exp} \\
     &\mid&  \ADD{\Exp}{\Exp}  \\
\LangInt{}  &::=& \PROGRAM{\code{'()}}{\Exp}
\end{array}
\]
\end{minipage}
}
\caption{\LangInt{} 的抽象语法。}
\label{fig:r0-syntax}
\end{figure}


\section{模式匹配}
\label{sec:pattern-matching}

正如~\ref{sec:ast} 节中提到的，编译器经常需要访问AST节点的各个部分。 Racket 提供\texttt{match} 形式，以访问一个结构的各个部分。考虑下面的示例和右边的输出。 \index{match} \index{pattern matching}
\begin{center}
\begin{minipage}{0.5\textwidth}
\begin{lstlisting}
(match ast1.1
  [(Prim op (list child1 child2))
    (print op)])
\end{lstlisting}
\end{minipage}
\vrule
\begin{minipage}{0.25\textwidth}
\begin{lstlisting}


   '+
\end{lstlisting}
\end{minipage}
\end{center}
在上面的例子中 \texttt{match} 形式接受一个 AST
\eqref{eq:arith-prog} ，并将它的各个部分绑定到三个模式变量 \texttt{op} 、 \texttt{child1} 和 \texttt{child2} ，然后打印出操作符。一般来说，一个匹配子句由
\emph{pattern} 和 \emph{body} 组成。\index{pattern} 模式被递归地定义为模式变量、结构名后面跟着每个结构参数的模式，或者S-表达式(符号、列表等)。 (关于 \code{match} 的完整描述，请参阅《 Racket 指南》\footnote{\url{https://docs.racket-lang.org/guide/match.html}} 
第12章和《 Racket 参考》\footnote{\url{https://docs.racket-lang.org/reference/match.html}}
第9章。)
%
匹配子句的正文可以包含任意的 Racket 代码。模式变量可以在主体的作用域中使用，例如
 \code{(print op)} 中的\code{op} 。

一个 \code{match} 形式可能包含几个子句，如下面的函数 \code{leaf?} 识别 \LangInt{} 节点何时是 AST 中的叶子。 \code{match} 按顺序遍历子句，检查模式是否能匹配输入的 AST 。匹配的第一个子句的主体将被执行。 右侧显示多个 AST 的 \code{leaf?} 的输出。
\begin{center}
\begin{minipage}{0.6\textwidth}
\begin{lstlisting}
(define (leaf? arith)
  (match arith
    [(Int n) #t]
    [(Prim 'read '()) #t]
    [(Prim '- (list e1)) #f]
    [(Prim '+ (list e1 e2)) #f]))

(leaf? (Prim 'read '()))
(leaf? (Prim '- (list (Int 8))))
(leaf? (Int 8))
\end{lstlisting}
\end{minipage}
\vrule
\begin{minipage}{0.25\textwidth}
  \begin{lstlisting}






    
   #t
   #f
   #t
\end{lstlisting}
\end{minipage}
\end{center}

写 \code{match} 时,我们指的是用语法定义来确定预匹配哪些非终结符,然后我们确保：1)对于非终结符的每个选项，都有一个子句；2)每个子句中的模式对应于语法规则的右手边。对于\code{leaf?} 函数中的 \code{match}
我们参考图~\ref{fig:r0-syntax} 中的 \LangInt{} 语法。 $\Exp$ 非终结符有4个选项，所以 \code{match} 有4个子句。每个子句中的模式对应于语法规则的右侧。例如，模式 \code{(Prim '+ (list e1 e2))} 对应右边的 $\ADD{\Exp}{\Exp}$ 。当从语法转换为模式时，用选择的模式变量(例如\code{e1} and \code{e2})替换非终结符，例如 $\Exp$ 。


\section{递归函数}
\label{sec:recursion}
\index{recursive function}

程序本质上是递归的。例如， \LangInt{} 表达式通常由更小的表达式组成。因此，处理整个程序的自然方法是使用递归函数。作为这种递归函数的第一个例子，我们定义 \texttt{exp?} ，它取一个任意的值，并且判定它是否是一个 \LangInt{}表达式。
%
当使用与语法相对应的匹配子句序列定义函数时，我们说函数是通过 \emph{结构递归} 定义的，并且每个子句的主体对每个子节点进行递归调用。\footnote{在 \emph{How to Design
    Programs} \url{http://www.ccs.neu.edu/home/matthias/HtDP2e/}中提倡了根据数据定义来构造代码的这一原理。} 
下面还定义第二个函数，名为 \code{Rint?} ，它确定 AST 是否是一个 \LangInt{} 程序。一般来说，可以编写一个递归函数来处理语法中的每个非终结符。\index{structural recursion}
%
\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{lstlisting}
(define (exp? ast)
  (match ast
    [(Int n) #t]
    [(Prim 'read '()) #t]
    [(Prim '- (list e)) (exp? e)]
    [(Prim '+ (list e1 e2))
      (and (exp? e1) (exp? e2))]
    [else #f]))

(define (Rint? ast)
  (match ast
    [(Program '() e) (exp? e)]
    [else #f]))

(Rint? (Program '() ast1.1)
(Rint? (Program '()
       (Prim '- (list (Prim 'read '())
                      (Prim '+ (list (Num 8)))))))
\end{lstlisting}
\end{minipage}
\vrule
\begin{minipage}{0.25\textwidth}
\begin{lstlisting}













   #t
   #f
\end{lstlisting}
\end{minipage}
\end{center}


你可能会试图将两个函数合并为一个，像这样：
\begin{center}
\begin{minipage}{0.5\textwidth}
\begin{lstlisting}
(define (Rint? ast)
  (match ast
    [(Int n) #t]
    [(Prim 'read '()) #t]
    [(Prim '- (list e)) (Rint? e)]
    [(Prim '+ (list e1 e2)) (and (Rint? e1) (Rint? e2))]
    [(Program '() e) (Rint? e)]
    [else #f]))
\end{lstlisting}
\end{minipage}
\end{center}
%
有时这样的技巧可以节省几行代码，特别是当涉及到 \code{Program} 包装器时。然而，这种风格通常
\emph{不} 推荐使用，因为它会带来麻烦。
%
例如，上面的函数微妙地错误:
\lstinline{(Rint? (Program '() (Program '() (Int 3))))}
应该返回 false 却返回 true 。


\section{解释器}
\label{sec:interp-Rint}
\index{interpreter}

一般来说，程序的预期行为是由语言规范来定义的。例如，Scheme 语言在报告中由 \cite{SPERBER:2009aa} 定义。 Racket 语言在它的参考手册~\citep{plt-tr} 中有定义。在本书中，使用解释器来指定我们所考虑的每种语言。被指定为语言定义的解释器称为
\emph{定义解释器}~\citep{reynolds72:_def_interp} 。
\index{definitional interpreter} 通过为 \LangInt{} 语言创建定义解释器进行预热，这是结构递归的第二个示例。 \texttt{interp-Rint} 函数在图~\ref{fig:interp-Rint} 中定义。函数体对输入程序进行匹配，然后对 \lstinline{interp-exp} 辅助函数进行调用，该函数对每个
\LangInt{} 表达式的语法规则都有一个匹配子句。

\begin{figure}[tp]
\begin{lstlisting}
(define (interp-exp e)
  (match e
    [(Int n) n]
    [(Prim 'read '())
     (define r (read))
     (cond [(fixnum? r) r]
           [else (error 'interp-exp "read expected an integer" r)])]
    [(Prim '- (list e))
     (define v (interp-exp e))
     (fx- 0 v)]
    [(Prim '+ (list e1 e2))
     (define v1 (interp-exp e1))
     (define v2 (interp-exp e2))
     (fx+ v1 v2)]))

(define (interp-Rint p)
  (match p
    [(Program '() e) (interp-exp e)]))
\end{lstlisting}
\caption{ \LangInt{} 语言的解释器。}
\label{fig:interp-Rint}
\end{figure}

让我们解释几个 \LangInt{} 程序的结果。下面的程序将两个整数相加。
\begin{lstlisting}
(+ 10 32)
\end{lstlisting}
结果是 \key{42} , 生命、宇宙和一切的答案： \code{42}!\footnote{\emph{The Hitchhiker's Guide to the
    Galaxy} by Douglas Adams.}.
%
用具体的语法编写上面的程序，而解析的抽象语法是：
\begin{lstlisting}
(Program '() (Prim '+ (list (Int 10) (Int 32))))
\end{lstlisting}

下一个示例演示表达式可以相互嵌套，在本例中嵌套几个加法和否定。
\begin{lstlisting}
(+ 10 (- (+ 12 20)))
\end{lstlisting}
上述程序的结果是什么?

正如前面提到的， \LangInt{} 语言不支持任意大的整数，而只支持 $63$ 位整数，因此我们在 Racket 中使用 fixnum 算术来解释 \LangInt{} 的算术操作。假设

\[
  n = 999999999999999999
\]
它确实适合 $63$ 位。当我们在解释器中运行以下程序时会发生什么?
\begin{lstlisting}
(+ (+ (+ |$n$| |$n$|) (+ |$n$| |$n$|)) (+ (+ |$n$| |$n$|) (+ |$n$| |$n$|)))))
\end{lstlisting}
它会产生一个错误:
\begin{lstlisting}
fx+: result is not a fixnum
\end{lstlisting}
我们建立这样一种约定:如果在程序上运行定义解释器产生一个错误，那么该程序的意义是 \emph{不确定的}\index{unspecified behavior} ，除非该错误是一个 \code{trapped-error} 。该语言的编译器没有义务关注具有未指定行为的程序;它不必生成可执行文件，如果生成，可执行文件就可以做任何事情。另一方面，如果错误是一个
\code{trapped-error} ，那么编译器必须生成一个可执行文件，并且必须报告错误发生的情况。要发出错误信号，退出时返回代码为 \code{255} 。第
\ref{ch:Rdyn} 章和第 \ref{ch:Rgrad} 章的解释器使用\code{trapped-error} 。

%% This convention applies to the languages defined in this
%% book, as a way to simplify the student's task of implementing them,
%% but this convention is not applicable to all programming languages.
%% 

接下来是 \LangInt{} 语言的最后一个特性， \key{read}
操作提示程序的用户是否需要一个整数。 回想一下程序 \eqref{eq:arith-prog} 执行一个 \key{read} ，然后减去
\code{8} 。所以如果我们运行
\begin{lstlisting}
(interp-Rint (Program '() ast1.1))
\end{lstlisting}
如果输入是 \code{50} ，结果是 \code{42} 。

我们将 \key{read} 操作包含在 \LangInt{} 中，因此聪明的学生无法为 \LangInt{} 实现编译器，该编译器仅在编译期间运行解释器以获取输出，然后生成琐碎的代码来生成输出。(是的，一个聪明的学生在本课程的第一部分中做到了这一点。)

编译器的工作是将一种语言的程序翻译成另一种语言的程序，使输出程序的行为与输入程序的行为相同。这个想法如下图所示。 假设有两种语言， $\mathcal{L}_1$ 和
$\mathcal{L}_2$ ，每种语言都有一个定义解释器。给定一个编译器将语言 $\mathcal{L}_1$ 翻译成语言
$\mathcal{L}_2$ ，并且给定语言 $\mathcal{L}_1$ 的任何程序 $P_1$，编译器必须将其翻译成程序 $P_2$ ，以便在各自的解释器上输入相同的 $i$ 来解释 $P_1$ 和 $P_2$ ，产生相同的输出 $o$ 。
\begin{equation} \label{eq:compile-correct}
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
 \node (p1) at (0,  0) {$P_1$};
 \node (p2) at (3,  0) {$P_2$};
 \node (o)  at (3, -2.5) {$o$};

 \path[->] (p1) edge [above] node {compile} (p2);
 \path[->] (p2) edge [right] node {interp-$\mathcal{L}_2$($i$)} (o);
 \path[->] (p1) edge [left]  node {interp-$\mathcal{L}_1$($i$)} (o);
\end{tikzpicture}
\end{equation}
在下一节中，将看到第一个编译器示例。


\section{编译器示例:部分求值器}
\label{sec:partial-evaluation}

在本节中，考虑一种编译器，它可以将 \LangInt{} 程序翻译成更高效的 \LangInt{} 程序，也就是说，这种编译器是一种优化器。这个优化器急切地计算程序中不依赖于任何输入的部分，这个过程称为
\emph{部分求值}~\citep{Jones:1993uq} 。
\index{partial evaluation}
例如，给定如下程序
\begin{lstlisting}
(+ (read) (- (+ 5 3)))
\end{lstlisting}
我们的编译器将把它翻译成程序
\begin{lstlisting}
(+ (read) -8)
\end{lstlisting}

图~\ref{fig:pe-arith} 给出 \LangInt{} 语言的一个简单的部分求值程序的代码。 部分求值器的输出是一个 \LangInt{} 程序。在图~\ref{fig:pe-arith}中， \code{pe-exp} 函数捕获关于 $\Exp$ 的结构递归，而部分计算否定和加法运算的代码则被分解成两个独立的辅助函数：
\code{pe-neg} 和 \code{pe-add} 。这些辅助函数的输入是对子函数部分求值的输出。

\begin{figure}[tp]
\begin{lstlisting}
(define (pe-neg r)
  (match r
    [(Int n) (Int (fx- 0 n))]
    [else (Prim '- (list r))]))

(define (pe-add r1 r2)
  (match* (r1 r2)
    [((Int n1) (Int n2)) (Int (fx+ n1 n2))]
    [(_ _) (Prim '+ (list r1 r2))]))

(define (pe-exp e)
  (match e
    [(Int n) (Int n)]
    [(Prim 'read '()) (Prim 'read '())]
    [(Prim '- (list e1)) (pe-neg (pe-exp e1))]
    [(Prim '+ (list e1 e2)) (pe-add (pe-exp e1) (pe-exp e2))]))

(define (pe-Rint p)
  (match p
    [(Program '() e) (Program '() (pe-exp e))]))
\end{lstlisting}
\caption{ \LangInt{} 的部分求值程序。}
\label{fig:pe-arith}
\end{figure}

\texttt{pe-neg} 和 \texttt{pe-add} 函数检查它们的参数是否为整数，如果是，则执行适当的算术。否则，它们将为算术操作创建一个AST节点。

为了获得部分求值器是正确的一些信心，可以测试它是否生成与输入程序得到相同结果的程序。也就是说，可以测试它是否满足图
\ref{eq:compile-correct} 。下面的代码在几个示例上运行部分求值程序，并测试输出程序。
\texttt{parse-program} 和 \texttt{assert} 函数在附录~\ref{appendix:utilities}中定义。\\
\begin{minipage}{1.0\textwidth}
\begin{lstlisting}
(define (test-pe p)
  (assert "testing pe-Rint"
     (equal? (interp-Rint p) (interp-Rint (pe-Rint p)))))

(test-pe (parse-program `(program () (+ 10 (- (+ 5 3))))))
(test-pe (parse-program `(program () (+ 1 (+ 3 1)))))
(test-pe (parse-program `(program () (- (+ 3 (- 5))))))
\end{lstlisting}
\end{minipage}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{整数和变量}
\label{ch:Rvar}

本章是关于编译 Racket 的子集到x86-64汇编代码~\citep{Intel:2015aa} 。名为 \LangVar{} 的子集包括整数算术和局部变量绑定。通常把x86-64简单地称为x86。本章首先介绍
\LangVar{} 语言 (~\ref{sec:s0} 节) ，然后介绍x86汇编语言(~\ref{sec:x86} 节) 。x86汇编语言非常大，只讨论编译
\LangVar{} 所需的指令。 我们将在后面的章节中介绍更多的x86指令。在介绍 \LangVar{} 和x86之后，我们反思它们的区别，并列出一个计划，将 \LangVar{}
到x86的转换分解为几个步骤 (~\ref{sec:plan-s0-x86} 节)。本章的其余部分给出每个步骤的详细提示(~\ref{sec:uniquify-Rvar} 至 \ref{sec:patch-s0} 节)。我们希望给出足够的提示，让准备充分的读者和一些朋友能够在几周内实现从 \LangVar{} 到x86的编译器。 为了让读者了解第一个编译器的规模， \LangVar{} 编译器的指导解决方案大约是500行代码。

\section{\LangVar{} 语言}
\label{sec:s0}
\index{variable}

\LangVar{} 语言通过变量定义扩展 \LangInt{} 语言。 \LangVar{} 语言的具体语法由图~\ref{fig:r1-concrete-syntax} 中的语法定义，抽象语法由图~\ref{fig:r1-syntax} 定义。非终端
\Var{} 可以是任何 Racket 标识符。和 \LangInt{} 一样，\key{read} 是一个空操作符， \key{-} 是一个一元操作符， \key{+} 是一个二元操作符。与 \LangInt{} 类似， \LangVar{} 的抽象语法包含标记程序顶部的\key{Program} 结构体。
%% The $\itm{info}$
%% field of the \key{Program} structure contains an \emph{association
%%   list} (a list of key-value pairs) that is used to communicate
%% auxiliary data from one compiler pass the next.
尽管 \LangVar{} 语言非常简单，但它的丰富程度足以展示几种编译技术。

\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{rcl}
  \Exp &::=& \Int \mid \CREAD{} \mid \CNEG{\Exp} \mid \CADD{\Exp}{\Exp}\\
       &\mid& \Var \mid \CLET{\Var}{\Exp}{\Exp} \\
  \LangVar{} &::=& \Exp
\end{array}
\]
\end{minipage}
}
\caption{ \LangVar{} 的具体语法。}
\label{fig:r1-concrete-syntax}
\end{figure}

\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{rcl}
\Exp &::=& \INT{\Int} \mid \READ{} \\
     &\mid& \NEG{\Exp} \mid \ADD{\Exp}{\Exp}  \\
     &\mid&  \VAR{\Var} \mid \LET{\Var}{\Exp}{\Exp} \\
\LangVar{} &::=& \PROGRAM{\code{'()}}{\Exp}
\end{array}
\]
\end{minipage}
}
\caption{ \LangVar{} 的抽象语法。}
\label{fig:r1-syntax}
\end{figure}

让我们进一步研究 \LangVar{}
语言的语法和语义。 \key{let} 特性定义一个变量，以便在其主体中使用，并使用表达式的值初始化该变量。 \key{let} 的抽象语法在图~\ref{fig:r1-syntax} 中定义。 \key{let} 的具体语法是
\begin{lstlisting}
(let ([|$\itm{var}$| |$\itm{exp}$|]) |$\itm{exp}$|)
\end{lstlisting}
例如，下面的程序将 \code{x} 初始化为 $32$ ，然后对 \code{(+ 10 x)} 求值，生成 $42$ 。
\begin{lstlisting}
(let ([x (+ 12 20)]) (+ 10 x))
\end{lstlisting}
当同一个变量有多个 \key{let} 时，使用最接近的 \key{let} 。也就是说，变量定义掩盖先前的定义。考虑下面的程序，它有两个 \key{let} ，定义名为 \code{x} 的变量。你能算出结果吗?
\begin{lstlisting}
(let ([x 32]) (+ (let ([x 10]) x) x))
\end{lstlisting}
为了描述哪个变量的使用对应于哪个定义，下面显示用下标标注的 \code{x} ，以区分它们。仔细检查您对上述问题的回答是否与本程序注释版本的回答相同。
\begin{lstlisting}
(let ([x|$_1$| 32]) (+ (let ([x|$_2$| 10]) x|$_2$|) x|$_1$|))
\end{lstlisting}
初始化表达式总是在
\key{let} 函数体求值之前，因此如下 \code{x} 的 \key{read} 函数会在 \code{y} 的 \key{read} 函数体之前执行。给定输入
$52$ ，然后是 $10$ ，下面的结果是 $42$ (不是 $-42$)。
\begin{lstlisting}
(let ([x (read)]) (let ([y (read)]) (+ x (- y))))
\end{lstlisting}

\subsection{通过方法覆盖的可扩展解释器}
\label{sec:extensible-interp}

为了准备讨论 \LangVar{} 的解释器，需要解释为什么选择使用面向对象编程实现解释器，也就是说，将其作为类中的方法集合。在本书中，定义许多解释器，学习的每种语言都有一个解释器。因为每种语言都建立在前一种语言的基础上，所以它们的解释器之间有很多共性。这些公共部分只需要写下一次而不是很多次。例如，一种简单的方法是让 \LangIf{} 的解释器处理该语言的所有新特性，然后有一个默认的case分派给 \LangVar{} 的解释器。下面的代码说明这个想法。
\begin{center}
  \begin{minipage}{0.45\textwidth}
\begin{lstlisting}
(define (interp-Rvar e)
  (match e
    [(Prim '- (list e))
     (fx- 0 (interp-Rvar e))]
    ...))
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.45\textwidth}
  \begin{lstlisting}
(define (interp-Rif e)
  (match e
    [(If cnd thn els)
     (match (interp-Rif cnd)
       [#t (interp-Rif thn)]
       [#f (interp-Rif els)])]
    ...
    [else (interp-Rvar e)]))    
\end{lstlisting}
\end{minipage}
\end{center}
这种方法的问题是，它不能处理 \LangIf{} 特性，如 \code{If} 嵌套在 \LangVar{} 的情况；就像下面的程序中的 \code{-} 操作符一样。
\begin{lstlisting}
(Prim '- (list (If (Bool #t) (Int 42) (Int 0))))
\end{lstlisting}
如果我们在这个程序上调用 \code{interp-Rif} ，它会分派给\code{interp-Rvar} 来处理 \code{-} 运算符，但是它会在 \code{-}
的参数(即一个 \code{If} )上再次递归地调用 \code{interp-Rvar} 。但是在 \code{interp-Rvar} 中没有 \code{If} 的情况，所以得到一个错误!

为了使解释器具有可扩展性，我们需要一种称为
\emph{开放递归}\index{open recursion} 的方法，在这种方法中，递归结的捆绑延迟到函数组合时进行。面向对象的语言通过覆盖方法\index{method overriding}的后期绑定提供开放递归。下面的代码概述使用 Racket 的
\href{https://docs.racket-lang.org/guide/classes.html}{\code{class}}
\index{class} 特征来解释 \LangVar{} 和
\LangIf{} 的想法。我们为每种语言定义一个类，并定义一个方法来解释每个类中的表达式。 \LangIf{} 的类继承自 \LangVar{}
的类， \LangIf{} 中的 \code{interp-exp} 方法覆盖 \LangVar{} 中的\code{interp-exp} 方法。注意， \LangIf{} 中
\code{interp-exp} 的默认情况是使用 \code{super} 来调用
\code{interp-exp} ，并且由于 \LangIf{} 继承自 \LangVar{} ，因此将分派到 \LangVar{} 中的 \code{interp-exp} 。
\begin{center}
\begin{minipage}{0.45\textwidth}
\begin{lstlisting}
(define interp-Rvar-class
  (class object%
    (define/public (interp-exp e)
      (match e
        [(Prim '- (list e))
         (fx- 0 (interp-exp e))]
        ...))
    ...))
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.45\textwidth}
  \begin{lstlisting}
(define interp-Rif-class
  (class interp-Rvar-class
    (define/override (interp-exp e)
      (match e
        [(If cnd thn els)
         (match (interp-exp cnd)
           [#t (interp-exp thn)]
           [#f (interp-exp els)])]
        ...
        [else (super interp-exp e)]))
    ...
  ))
\end{lstlisting}
\end{minipage}
\end{center}
回到那个麻烦的例子，在这里重复：
\begin{lstlisting}
(define e0 (Prim '- (list (If (Bool #t) (Int 42) (Int 0)))))
\end{lstlisting}
可以在这个表达式上调用 \LangIf{} 的 \code{interp-exp}方法，方法是创建 \LangIf{} 类的一个对象，并将
\code{interp-exp} 方法和参数 \code{e0} 发送给它。
\begin{lstlisting}
(send (new interp-Rif-class) interp-exp e0)
\end{lstlisting}
\LangIf{} 中的 \code{interp-exp} 的默认情况是通过分配给 \LangVar{} 中的 \code{interp-exp}方法来处理它，该方法处理 \code{-} 操作符。但是对于递归方法调用，它将分派回 \LangIf{} 中的 \code{interp-exp} ，在那里
\code{If} 被正确处理。因此，方法覆盖，提供以可扩展的方式实现解释器所需的开放递归。

\newpage

\subsection{\LangVar{} 的定义解释器}

\begin{wrapfigure}[21]{r}[1.0in]{0.6\textwidth}
  \small
  \begin{tcolorbox}[title=作为字典的关联列表]
  \emph{关联列表} (alist) 是键-值对的列表。
  例如，可以通过一个列表来映射人们的年龄。
  \index{alist}\index{association list}
  \begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
  (define ages
    '((jane . 25) (sam . 24) (kate . 45)))
  \end{lstlisting}
  \emph{词典} 接口用于将键映射到值。
  每个列表都实现这个接口。\index{dictionary} 
  \href{https://docs.racket-lang.org/reference/dicts.html}{\code{racket/dict}}
  包提供许多使用字典的功能。以下是其中的一些：
  \begin{description}
  \item[$\LP\key{dict-ref}\,\itm{dict}\,\itm{key}\RP$]
    返回与给定 $\itm{key}$ 相关联的值。
  \item[$\LP\key{dict-set}\,\itm{dict}\,\itm{key}\,\itm{val}\RP$]
    返回一个新的字典，它将 $\itm{key}$ 映射到 $\itm{val}$
    ，但在其他方面与 $\itm{dict}$ 相同。
  \item[$\LP\code{in-dict}\,\itm{dict}\RP$] 返回  $\itm{dict}$ 中的键和值的
    \href{https://docs.racket-lang.org/reference/sequences.html}{序列}
    。例如，下面的代码创建一个新列表，其中年龄是递增的。
  \end{description}
  \vspace{-10pt}
  \begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
  (for/list ([(k v) (in-dict ages)])
    (cons k (add1 v)))
  \end{lstlisting}
\end{tcolorbox}
\end{wrapfigure}

在证明如何使用类和方法来实现解释器之后，我们转向图~\ref{fig:interp-Rvar} 中 \LangVar{}
的定义解释器。它与
\LangInt{} 的解释器相似，但是为变量和 \key{let} 添加两个新的 \key{match} 用例。对于 \key{let} ，我们需要一种方式来将绑定到变量的值传递给变量的所有引用。为了实现这一点，我们维护一个从变量到值的映射。在整个编译过程中，我们经常需要将变量映射到有关它们的信息。将这些映射称为
\emph{环境}\index{environment} 。\footnote{在编译器文献中，环境的另一个常见术语是 \emph{符号表}\index{symbol table} 。}
%
为简单起见，使用关联列表 (alist) 来表示环境。右边的侧边栏简要介绍
alists 和 \code{racket/dict} 包。\code{interp-exp}
函数将当前环境 \code{env} 作为一个额外参数。当解释器遇到一个变量时，它会使用 \code{dict-ref} 函数找到相应的值。当解释器遇到 \key{Let} 时，它计算初始表达式，使用 \code{dict-set} 将结果值绑定到变量，扩展环境，然后计算
\key{Let} 的主体。

\begin{figure}[tp]
\begin{lstlisting}
(define interp-Rvar-class
  (class object%
    (super-new)
    
    (define/public ((interp-exp env) e)
      (match e
        [(Int n) n]
        [(Prim 'read '())
         (define r (read))
         (cond [(fixnum? r) r]
               [else (error 'interp-exp "expected an integer" r)])]
        [(Prim '- (list e)) (fx- 0 ((interp-exp env) e))]
        [(Prim '+ (list e1 e2))
         (fx+ ((interp-exp env) e1) ((interp-exp env) e2))]
        [(Var x) (dict-ref env x)]
        [(Let x e body)
         (define new-env (dict-set env x ((interp-exp env) e)))
         ((interp-exp new-env) body)]))

    (define/public (interp-program p)
      (match p
        [(Program '() e) ((interp-exp '()) e)]))
    ))

(define (interp-Rvar p)
  (send (new interp-Rvar-class) interp-program p))
\end{lstlisting}
\caption{\LangVar{} 语言的解释器。}
\label{fig:interp-Rvar}
\end{figure}

本章的目标是实现一个编译器，它可以将任何用 \LangVar{} 语言编写的程序 $P_1$ 翻译成一个x86汇编程序
 $P_2$ ，使 $P_2$ 在计算机上运行时表现出与通过 \code{interp-Rvar} 解释的 $P_1$ 程序相同的行为。也就是说，它们输出的是相同的整数 $n$ 。在下图中描述这个正确性标准。
\[
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
 \node (p1) at (0,  0)   {$P_1$};
 \node (p2) at (4,  0)   {$P_2$};
 \node (o)  at (4, -2) {$n$};

 \path[->] (p1) edge [above] node {\footnotesize compile} (p2);
 \path[->] (p1) edge [left]  node {\footnotesize\code{interp-Rvar}} (o);
 \path[->] (p2) edge [right] node {\footnotesize\code{interp-x86int}} (o);
\end{tikzpicture}
\]
在下一节中，介绍x86的 \LangXInt{} 子集，它足以编译 \LangVar{} 。

\section{\LangXInt{} 汇编语言}
\label{sec:x86}
\index{x86}

图~\ref{fig:x86-int-concrete} 定义
\LangXInt{} 的具体语法。我们使用GNU汇编程序所期望的 AT\&T 语法。
%
程序以 \code{main} 标签开始，后面跟着一系列指令。\key{globl} 指令说 \key{main}
过程是外部可见的，这是操作系统可以调用它的必要条件。在语法中，省略如
$\ldots$ 用于指示一个项目序列，例如， $\Instr \ldots$ 是指令序列。\index{instruction}
%
x86程序存储在计算机的内存中。就我们的目的而言，计算机的内存是64位地址到64位值的映射。计算机在 \code{rip} 寄存器中存储一个 \emph{程序计数器} (PC)\index{program
  counter}\index{PC} ，它指向下一条要执行的指令的地址。对于大多数指令，程序计数器在指令执行后递增，因此它指向内存中的下一条指令。大多数x86指令有两个操作数，每个操作数要么是一个整型常量(称为 \emph{立即数}\index{immediate
  value}) ，要么是一个 \emph{寄存器}\index{register} ，要么是一个内存位置。

\newcommand{\allregisters}{\key{rsp} \mid \key{rbp} \mid \key{rax} \mid \key{rbx} \mid \key{rcx}
              \mid \key{rdx} \mid \key{rsi} \mid \key{rdi} \mid \\
              && \key{r8} \mid \key{r9} \mid \key{r10}
              \mid \key{r11} \mid \key{r12} \mid \key{r13}
              \mid \key{r14} \mid \key{r15}}

\begin{figure}[tp]
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{lcl}
\Reg &::=& \allregisters{} \\
\Arg &::=&  \key{\$}\Int \mid \key{\%}\Reg \mid \Int\key{(}\key{\%}\Reg\key{)}\\
\Instr &::=& \key{addq} \; \Arg\key{,} \Arg \mid
      \key{subq} \; \Arg\key{,} \Arg \mid
      \key{negq} \; \Arg \mid \key{movq} \; \Arg\key{,} \Arg \mid \\
  &&  \key{callq} \; \mathit{label} \mid
      \key{pushq}\;\Arg \mid \key{popq}\;\Arg \mid \key{retq} \mid \key{jmp}\,\itm{label} \\
  && \itm{label}\key{:}\; \Instr \\
\LangXInt{} &::= & \key{.globl main}\\
      &    & \key{main:} \; \Instr\ldots
\end{array}
\]
\end{minipage}
}
\caption{ \LangXInt{} 汇编语言的语法 (AT\&T 语法)。}
\label{fig:x86-int-concrete}
\end{figure}

寄存器是一种特殊的变量。每一个都有一个64位的值；计算机中有16个通用寄存器，它们的名称在图~\ref{fig:x86-int-concrete} 中给出。写入寄存器时， \key{\%} 后跟寄存器名，比如
\key{\%rax} 。

立即数使用符号 \key{\$}$n$ 写入，其中 $n$ 是整数。
%
%
对内存的访问是使用语法 $n(\key{\%}r)$ 指定的，它获得存储在寄存器 $r$ 中的地址，然后给地址加 $n$
个字节。生成的地址用于加载或存储到内存中，这取决于它是作为指令的源参数还是目标参数出现。

算术指令，比如 $\key{addq}\,s\key{,}\,d$ 从源 $s$ 和目标 $d$ 读取数据，应用算术运算，然后将结果写回目标 $d$ 。
%
移动指令 $\key{movq}\,s\key{,}\,d$ 从 $s$ 中读取并将结果存储在 $d$ 中。
%
 $\key{callq}\,\itm{label}$ 指令跳转到由 label 指定的过程，而 $\key{retq}$ 则从过程返回到它的调用者。
%
在本章后面和第~\ref{ch:Rfun} 章中更详细地讨论过程调用。指令 $\key{jmp}\,\itm{label}$
将程序计数器更新到指定 label 之后的指令地址。

附录~\ref{sec:x86-quick-reference} 包含这本书中使用的所有x86指令的快速参考。

图~\ref{fig:p0-x86} 描述一个相当于
\code{(+ 10 32)} 的x86程序。指令 \lstinline{movq $10, %rax}
将 $10$ 放入寄存器 \key{rax} ，然后 \lstinline{addq $32, %rax}
将 $32$ 加到 \key{rax} 中的 $10$ ，并将结果 $42$ 放回 \key{rax} 。
%
最后一条指令， \key{retq} ，通过将 \key{rax} 中的整数返回给操作系统来完成 \key{main} 函数。操作系统将这个整数解释为程序的退出码。按照惯例，退出码为0表示程序成功完成，所有其他退出码表示各种错误。然而，在本书中，返回程序的结果作为退出码。

\begin{figure}[tbp]
\begin{lstlisting}
	.globl main
main:
	movq	$10, %rax
	addq	$32, %rax
	retq
\end{lstlisting}
\caption{一个相当于 \code{(+ 10 32)} 的x86程序。}
\label{fig:p0-x86}
\end{figure}

x86汇编语言有几种不同的方式，这取决于它是在什么操作系统中组装的。这里显示的代码示例在Linux和大多数类unix平台上是正确的，但在Mac OS X上组装时，像 \key{main} 这样的标签必须加上下划线前缀，就像 \key{\_main} 一样。

在下一个示例中，演示如何使用内存存储中间结果。图~\ref{fig:p1-x86} 列出一个相当于 \code{(+ 52 (- 10))} 的x86程序。这个程序使用一个称为 \emph{过程调用栈} (或简称 \emph{栈} )的内存区域。 \index{stack}\index{procedure call stack} 堆栈由每个过程调用的独立 \emph{帧}\index{frame} 组成。单个帧的内存布局如图~\ref{fig:frame} 所示。寄存器 \key{rsp} 被称为
\emph{堆栈指针}\index{stack pointer} ，它指向堆栈顶部的项。堆栈在内存中向下增长，通过减去堆栈指针来增加堆栈的大小。
在过程调用的上下文中， \emph{返回地址}\index{return address} 是调用方调用指令之后的指令。函数调用指令
\code{callq} 在跳转到过程之前将返回地址压入堆栈。寄存器 \key{rbp} 是 \emph{基指针}\index{base pointer} ，用于访问存储在当前过程调用框架中的变量。调用者的基指针在返回地址之后被压入堆栈，然后基指针被设置为旧基指针的位置。在图~\ref{fig:frame}中，对变量编号，从 $1$ 到 $n$ 。变量 $1$ 存储在地址 $-8\key{(\%rbp)}$ ，
变量 $2$ 存储在地址 $-16\key{(\%rbp)}$ ，等等。

\begin{figure}[tbp]
\begin{lstlisting}
start:
	movq	$10, -8(%rbp)
	negq	-8(%rbp)
	movq	-8(%rbp), %rax
	addq	$52, %rax
	jmp conclusion

	.globl main
main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$16, %rsp
	jmp start
conclusion:
	addq	$16, %rsp
	popq	%rbp
	retq
\end{lstlisting}
\caption{相当于 \code{(+ 52 (- 10))} 的x86程序。}
\label{fig:p1-x86}
\end{figure}


\begin{figure}[tbp]
\centering
\begin{tabular}{|r|l|} \hline
位置 & 内容 \\ \hline
8(\key{\%rbp}) & return address \\
0(\key{\%rbp}) & old \key{rbp} \\
-8(\key{\%rbp}) & variable $1$ \\
-16(\key{\%rbp}) & variable $2$ \\
 \ldots  & \ldots \\
0(\key{\%rsp}) & variable $n$\\ \hline
\end{tabular}

\caption{帧的内存布局。}
\label{fig:frame}
\end{figure}

回到图~\ref{fig:p1-x86} 中的程序，考虑控制是如何从操作系统转移到 \code{main}
函数的。操作系统发出一个 \code{callq main} 指令，将其返回地址推送到堆栈上，然后跳转到
\code{main} 。在x86-64中，堆栈指针 \code{rsp} 在执行任何 \code{callq} 指令之前必须被16个字节整除，因此当控制到达 \code{main} 时， \code{rsp} 偏离对齐8个字节(因为 \code{callq} 推入返回地址)。前三条指令是一个程序的典型 \emph{前奏}\index{prelude}
。指令 \code{pushq \%rbp} 将调用者的基指针保存到堆栈上，并从堆栈指针中减去 $8$ 。第二个指令 \code{movq \%rsp, \%rbp} 改变基指针，使其指向旧基指针的位置。指令 \code{subq \$16, \%rsp} 将堆栈指针向下移动，以便为存储变量留出足够的空间。这个程序需要一个变量 ($8$ 个字节) ，但是四舍六入到16个字节，这样
\code{rsp} 是16字节对齐的，就可以调用其他函数。前奏的最后一条指令是 \code{jmp start}，它将控制转移到由 Racket 表达式 \code{(+ 52 (- 10))} 生成的指令。

 \code{start} 标签下的第一条指令是
\code{movq \$10, -8(\%rbp)} ，它将 $10$ 存储在变量 $1$ 中。
%
指令 \code{negq -8(\%rbp)} 将变量 $1$ 更改为 $-10$ 。
%
下一条指令将变量 $1$ 中的 $-10$ 移动到\code{rax} 寄存器中。最后， \code{addq \$52, \%rax} 将 $52$ 添加到 \code{rax} 中的值，将其值更新为 $42$ 。

 \code{conclusion} 标签下的三个指令是一个程序的典型 \emph{结论}\index{conclusion} 。前两条指令将 \code{rsp} 和 \code{rbp} 寄存器恢复到过程开始时的状态。指令 \key{addq \$16, \%rsp} 将栈指针移回指向旧的基指针。然后 \key{popq \%rbp} 返回 \key{rbp} 的旧基指针，并在堆栈指针上加 $8$ 。最后一条指令 \key{retq} 返回到调用它的过程，并将 $8$ 添加到堆栈指针。

编译器需要一个方便的表示来操作x86程序，所以在图~\ref{fig:x86-int-ast} 中为x86定义一个抽象语法。将这种语言称为
\LangXInt{} 。与
\LangXInt{} (图~\ref{fig:x86-int-concrete}) 的具体语法相比，主要区别在于不允许在每个指令前都添加标签。相反，指令被分组成 \emph{块}\index{block}\index{basic block} ，每个块都有一个标签，这就是为什么 \key{X86Program}
结构包含一个列表，将标签映射到块。在第~\ref{ch:Rif} 章中，当我们引入条件分支时，这种组织的原因就变得很明显。 \code{Block} 结构包含一个 $\itm{info}$ 字段，这个字段本章不需要，但在第~\ref{ch:register-allocation-Rvar} 章会很有用。现在，
$\itm{info}$ 字段应该包含一个空列表。同样，关于 \code{callq} 的抽象语法， \code{Callq} 结构包括一个整数，代表函数的有效性，即参数的数量，这在寄存器分配过程中会很有帮助（第~\ref{ch:register-allocation-Rvar} 章）。

\begin{figure}[tp]
\fbox{
\begin{minipage}{0.98\textwidth}
\small    
\[
\begin{array}{lcl}
\Reg &::=& \allregisters{} \\
\Arg &::=&  \IMM{\Int} \mid \REG{\Reg}
   \mid \DEREF{\Reg}{\Int} \\
\Instr &::=& \BININSTR{\code{addq}}{\Arg}{\Arg} 
       \mid \BININSTR{\code{subq}}{\Arg}{\Arg} \\
       &\mid& \BININSTR{\code{movq}}{\Arg}{\Arg}
       \mid \UNIINSTR{\code{negq}}{\Arg}\\
       &\mid& \CALLQ{\itm{label}}{\itm{int}} \mid \RETQ{} 
       \mid \PUSHQ{\Arg} \mid \POPQ{\Arg} \mid \JMP{\itm{label}} \\
\Block &::= & \BLOCK{\itm{info}}{\LP\Instr\ldots\RP} \\
\LangXInt{} &::= & \XPROGRAM{\itm{info}}{\LP\LP\itm{label} \,\key{.}\, \Block \RP\ldots\RP}
\end{array}
\]
\end{minipage}
}
\caption{\LangXInt{} 程序集的抽象语法。}
\label{fig:x86-int-ast}
\end{figure}

\section{通过 \LangCVar{} 语言计划x86之旅}
\label{sec:plan-s0-x86}

要将一种语言编译成另一种语言，关注两种语言之间的差异会有所帮助，因为编译器需要弥合这些差异。 \LangVar{}
和x86汇编有什么区别?以下是一些最重要的：

\begin{enumerate}
\item[(a)]x86算术指令通常有两个参数，并在适当的地方更新第二个参数。相反， \LangVar{} 算术操作接受两个参数并产生一个新值。
  一个x86指令最多可以有一个内存访问参数。此外，一些指令对它们的参数进行特殊的限制。

\item[(b)]  \LangVar{} 操作符的参数可以是一个嵌套很深的表达式，而x86指令将它们的参数限制为整数、常量、寄存器和内存地址。

\item[(c)] x86中的执行顺序在语法中是明确的：指令序列并跳转到标记的位置，而在
  \LangVar{} 中，评估顺序是抽象语法树从左到右的深度优先遍历。

\item[(d)] \LangVar{} 中的程序可以有任意数量的变量，而x86有16个寄存器和过程调用堆栈。

\item[(e)] \LangVar{} 中的变量可以覆盖同名的其他变量。在x86中，寄存器有唯一的名称，内存位置有唯一的地址。
\end{enumerate}

通过将问题分解为几个步骤，逐个处理上面的差异，减轻从 \LangVar{} 编译到x86的挑战。每一个步骤都被称为编译器的 \emph{通道} 。\index{pass}\index{compiler pass}
%
这个术语来自于程序的每个步骤通过 AST 的方式。
%
首先勾画出如何实现每个通道，并给它们命名。然后，计算出通道的顺序以及每个通道的输入/输出语言。第一个通道使用
\LangVar{} 作为输入语言，最后一个使用 \LangXInt{} 作为输出语言。在这两者之间，可以选择最方便表示每个通道的输出语言，无论是 \LangVar{} 、 \LangXInt{} ，还是我们设计的新 \emph{中间语言} 。最后，要实现每个通道，需要在通道输入语言的语法中为每个非终端编写一个递归函数。\index{intermediate language}

\begin{description}
\item[\key{select-instructions}] 处理
  \LangVar{} 操作和x86指令之间的区别。这个通道将每个
  \LangVar{} 操作转换为完成相同任务的短指令序列。

\item[\key{remove-complex-opera*}] 确保原语操作的每个子表达式都是变量或整数，即
  \emph{原子} 表达式。将非原子表达式称为
  \emph{复合} 表达式。这一通道引入临时变量来保存复合子表达式的结果。\index{atomic
    expression}\index{complex expression}%
  \footnote{操作的子表达式通常被称为操作符和操作数，这就解释为什么在这个通道中会有
    \code{opera*} 。}
  
\item[\key{explicate-control}] 使程序以显式方式执行。它将抽象语法树表示形式转换为控制流图，其中每个节点包含一系列语句，节点之间的边缘表示哪些节点包含到其他节点的跳转。

\item[\key{assign-homes}] 用x86中的寄存器或堆栈地址替换 \LangVar{} 中的变量。

\item[\key{uniquify}] 通过为每个变量重命名一个唯一的名称来处理变量的隐藏。
\end{description}

下一个问题是:应该以什么顺序应用这些通道?这个问题很有挑战性，因为很难提前知道哪种排序更好(更容易实现，生成更高效的代码，等等)，所以经常需要反复试验。不过，可以试着提前计划，在排序方面做出明智的选择。

相对于\key{uniquify} ， \key{explicate-control} 的顺序应该是什么? \key{uniquify} 应该放在第一位，因为
\key{explicate-control} 将所有 \key{let} 绑定的变量都变成作用域为整个程序的局部变量，这将使同名的变量产生混淆。
%
将 \key{remove-complex-opera*} 放在 \key{explicate-control}
之前，因为后者删除 \key{let} 形式，但在 \key{remove-complex-opera*} 的输出中使用 \key{let} 是很方便的。
%
 \key{uniquify} 相对于
\key{remove-complex-opera*} 的顺序无关紧要，所以我们随意选择
\key{uniquify} 排在第一位。

最后考虑 \key{select-instructions} 和 \key{assign-homes} 。
这两个通道是交织在一起的。在第~\ref{ch:Rfun} 章中，了解到，在x86中，寄存器是用来传递参数给函数的，最好是将参数赋值给相应的寄存器。另一方面，通过先选择指令，可能会在 \key{assign-homes} 中陷入死胡同。回想一下，x86指令只有一个参数可能是内存访问，但是
\key{assign-homes} 可能无法将它们中的任何一个分配到寄存器。
%
一种复杂的方法是迭代地重复两个通道，直到找到解决方案。然而，为了降低实现的复杂性，推荐一种更简单的方法，首先是 \key{select-instructions} ，然后是 \key{assign-homes} ，然后是第三个名为
\key{patch-instructions} 的方法，它使用一个保留的寄存器来修复未解决的问题。

\begin{figure}[tbp]
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (Rvar) at (0,2)  {\large \LangVar{}};
\node (Rvar-2) at (3,2)  {\large \LangVar{}};
\node (Rvar-3) at (6,2)  {\large \LangVarANF{}};
%\node (Cvar-1) at (6,0)  {\large \LangCVar{}};
\node (Cvar-2) at (3,0)  {\large \LangCVar{}};

\node (x86-2) at (3,-2)  {\large \LangXVar{}};
\node (x86-3) at (6,-2)  {\large \LangXVar{}};
\node (x86-4) at (9,-2) {\large \LangXInt{}};
\node (x86-5) at (12,-2) {\large \LangXInt{}};

\path[->,bend left=15] (Rvar) edge [above] node {\ttfamily\footnotesize uniquify} (Rvar-2);
\path[->,bend left=15] (Rvar-2) edge [above] node {\ttfamily\footnotesize remove-complex.} (Rvar-3);
\path[->,bend left=15] (Rvar-3) edge [right] node {\ttfamily\footnotesize explicate-control} (Cvar-2);
\path[->,bend right=15] (Cvar-2) edge [left] node {\ttfamily\footnotesize select-instr.} (x86-2);
\path[->,bend left=15] (x86-2) edge [above] node {\ttfamily\footnotesize assign-homes} (x86-3);
\path[->,bend left=15] (x86-3) edge [above] node {\ttfamily\footnotesize patch-instr.} (x86-4);
\path[->,bend left=15] (x86-4) edge [above] node {\ttfamily\footnotesize print-x86} (x86-5);
\end{tikzpicture}

\caption{编译 \LangVar{} 的通道示意图}
\label{fig:Rvar-passes}
\end{figure}

图~\ref{fig:Rvar-passes} 显示编译器通道的顺序，并标识每个通道的输入和输出语言。最后一个通道， \key{print-x86} ，将
\LangXInt{} 的抽象语法转换为具体语法。在接下来的两节中，将讨论 \LangCVar{} 中间语言和x86的 \LangXVar{}
方言。本章的其余部分给出图~\ref{fig:Rvar-passes} 中关于每个编译器通道的实现的提示。

%% The output of \key{uniquify} and \key{remove-complex-opera*}
%% are programs that are still in the \LangVar{} language, though the
%% output of the later is a subset of \LangVar{} named \LangVarANF{}
%% (Section~\ref{sec:remove-complex-opera-Rvar}).
%% %
%% The output of \key{explicate-control} is in an intermediate language
%% \LangCVar{} designed to make the order of evaluation explicit in its
%% syntax, which we introduce in the next section. The
%% \key{select-instruction} pass translates from \LangCVar{} to
%% \LangXVar{}. The \key{assign-homes} and

%% \key{patch-instructions}
%% passes input and output variants of x86 assembly.

\subsection{ \LangCVar{} 中间语言}

 \key{explicate-control} 的输出类似于 $C$
语言~\citep{Kernighan:1988nx} ，它为表达式和语句提供单独的语法类别，因此将其命名为 \LangCVar{} 。 图~\ref{fig:c0-syntax} 定义 \LangCVar{} 的抽象语法。
( \LangCVar{} 的具体语法见附录，图~\ref{fig:c0-concrete-syntax} 。)
%
\LangCVar{} 语言支持与 \LangVar{} 相同的操作符，但操作符的参数仅限于原子表达式。代替 \key{let} 表达式， \LangCVar{} 有赋值语句，可以使用\key{Seq} 形式按顺序执行。语句序列总是以 \key{Return} 结尾，这是
\itm{tail} 语法规则中的保证。这个非终端符的命名来自术语\emph{尾部位置}\index{tail position} ，它指的是函数中最后一个执行的表达式。

一个 \LangCVar{} 程序由一个控制流图组成，表示为一个映射标签到尾部的列表。这对于本章来说是不必要的，因为我们还没有引入跳转到标签的 \key{goto} ，但它节省我们在第~\ref{ch:Rif} 章中更改语法的时间。现在只有一个标签
\key{start} ，整个程序就是它的尾部。
%
\key{CProgram} 形式的 $\itm{info}$ 字段，在\key{explicate-control} 传递之后，包含从符号
\key{locals} 到变量列表的映射，也就是程序中使用的所有变量列表。在程序开始时，这些变量未初始化；它们在第一次赋值时开始初始化。

\begin{figure}[tbp]
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{lcl}
\Atm &::=& \INT{\Int} \mid \VAR{\Var} \\
\Exp &::=& \Atm \mid \READ{} \mid \NEG{\Atm} \\
 &\mid& \ADD{\Atm}{\Atm}\\
\Stmt &::=& \ASSIGN{\VAR{\Var}}{\Exp} \\
\Tail &::= & \RETURN{\Exp} \mid \SEQ{\Stmt}{\Tail} \\
\LangCVar{} & ::= & \CPROGRAM{\itm{info}}{\LP\LP\itm{label}\,\key{.}\,\Tail\RP\ldots\RP}
\end{array}
\]
\end{minipage}
}
\caption{中间语言 \LangCVar{} 的抽象语法。}
\label{fig:c0-syntax}
\end{figure}

 \LangCVar{} 的定义解释器在支持代码 \code{interp-Cvar.rkt} 文件中。

\subsection{\LangXVar{} 方言}

\LangXVar{} 语言是通道
\key{select-instructions} 的输出。它用无数个程序作用域变量扩展 \LangXInt{} ，并消除关于指令参数的限制。


\section{Uniquify 变量}
\label{sec:uniquify-Rvar}

\code{uniquify} 通道将 \LangVar{} 程序编译为 \LangVar{}
程序，在 \LangVar{} 程序中，每个 \key{let} 都绑定一个唯一的变量名。例如， \code{uniquify} 通道应该将左边的程序转换为右边的程序。 \\
\begin{tabular}{lll}
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
(let ([x 32])
  (+ (let ([x 10]) x) x))
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
(let ([x.1 32])
  (+ (let ([x.2 10]) x.2) x.1))
\end{lstlisting}
\end{minipage}
\end{tabular} \\
%
下面是另一个翻译示例，这一次是一个程序，在另一个 \key{let} 的初始化表达式中嵌套了一个
\key{let} 。\\
\begin{tabular}{lll}
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
(let ([x (let ([x 4])
            (+ x 1))])
  (+ x 2))
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
(let ([x.2 (let ([x.1 4])
              (+ x.1 1))])
  (+ x.2 2))
\end{lstlisting}
\end{minipage}
\end{tabular}

建议通过创建一个名为 \code{uniquify-exp} 的结构递归函数来实现 \code{uniquify} ，该函数主要只是复制一个表达式。但是，当遇到 \key{let} 时，它应该为变量生成唯一的名称，并将旧名称与列表中的新名称关联起来。\footnote{ Racket 函数
  \code{gensym} 可以方便地生成唯一的变量名。} 当
\code{uniquify-exp} 函数得到一个变量引用时，需要访问这个列表，因此为列表的 \code{uniquify-exp}添加一个参数。

 \code{uniquify-exp} 函数的框架如图~\ref{fig:uniquify-Rvar} 所示。该函数经过咖喱处理，因此可以方便地将其部分应用于一个列表，然后将其应用于不同的表达式，如图~\ref{fig:uniquify-Rvar} 中最后一种原始操作所示。Racket 的
%
\href{https://docs.racket-lang.org/reference/for.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._for%2Flist%29%29}{\key{for/list}}
%
形式对于转换列表的每个元素以生成新列表很有用。\index{for/list}

\begin{exercise}
\normalfont % I don't like the italics for exercises. -Jeremy

通过填写图~\ref{fig:uniquify-Rvar} 中的空白来完成 \code{uniquify} 传递，即在支持代码的文件 \code{compiler.rkt} 中实现变量和 \key{let} 形式的用例。
\end{exercise}

\begin{figure}[tbp]
\begin{lstlisting}
(define (uniquify-exp env)
  (lambda (e)
    (match e
      [(Var x) ___]
      [(Int n) (Int n)]
      [(Let x e body) ___]
      [(Prim op es)
       (Prim op (for/list ([e es]) ((uniquify-exp env) e)))])))

(define (uniquify p)
  (match p
    [(Program '() e) (Program '() ((uniquify-exp '()) e))]))
\end{lstlisting}
\caption{ \key{uniquify} 通道的框架。}
\label{fig:uniquify-Rvar}
\end{figure}

\begin{exercise}
\normalfont % I don't like the italics for exercises. -Jeremy

创建五个 \LangVar{} 程序，使用 \key{uniquify} 通道中最有趣的部分，也就是说，程序应该包含
\key{let} 形式、变量和相互遮掩的变量。
这五个程序应该放在名为\key{tests} 的子目录中，文件名应该以 \code{var\_test\_}
开头，后跟一个唯一的整数，以文件扩展名\key{.rkt} 结束。
%
支持代码中的 \key{run-tests.rkt} 脚本检查输出程序是否产生与输入程序相同的结果。该脚本使用 \key{utilities.rkt} 中的 \key{interp-tests} 函数
(附录~\ref{appendix:utilities}) 来测试示例程序的 \key{uniquify} 通道。  \key{interp-tests} 的 \code{passes}
参数是一个列表，在你的编译器中，每个通道都应该有一个条目。现在， \code{passes} 定义
只包含 \code{uniquify} 的一个条目，如下所示。
\begin{lstlisting}
(define passes 
  (list (list "uniquify" uniquify interp-Rvar type-check-Rvar)))
\end{lstlisting}
运行支持代码中的 \key{run-tests.rkt} 脚本，检查输出程序是否产生与输入程序相同的结果。
\end{exercise}


\section{删除复杂的操作数}
\label{sec:remove-complex-opera-Rvar}

 \code{remove-complex-opera*} 通道将 \LangVar{}程序编译成一种受限的形式，在这种形式中，操作的参数是原子表达式。换句话说，这个传递删除复杂的操作数\index{complex operand} ，例如下面程序中的表达式 \code{(- 10)}
。这是通过引入一个新的
\key{let}绑定变量来实现的，将复杂操作数绑定到新变量，然后使用新变量来代替复杂操作数，如右边的 \code{remove-complex-opera*} 的输出所示。\\
\begin{tabular}{lll}
\begin{minipage}{0.4\textwidth}
% var_test_19.rkt
\begin{lstlisting}
(+ 52 (- 10))
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
(let ([tmp.1 (- 10)])
  (+ 52 tmp.1))
\end{lstlisting}
\end{minipage}
\end{tabular}


\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{rcl}
\Atm &::=& \INT{\Int} \mid \VAR{\Var} \\
\Exp &::=& \Atm \mid \READ{} \\
     &\mid& \NEG{\Atm} \mid \ADD{\Atm}{\Atm}  \\
     &\mid&  \LET{\Var}{\Exp}{\Exp} \\
R^{\dagger}_1  &::=& \PROGRAM{\code{'()}}{\Exp}
\end{array}
\]
\end{minipage}
}
\caption{\LangVarANF{} 是 \LangVar{} 的管理标准形式 (ANF)。}
\label{fig:r1-anf-syntax}
\end{figure}

图~\ref{fig:r1-anf-syntax} 给出该通道输出的语法，即语言 \LangVarANF{} 。唯一的区别是操作符参数被限制为由 \Atm{} 非终端定义的原子表达式。特别是整数常量和变量是原子的。在文献中，将参数限制为原子表达式称为 \emph{管理规范形式} ，简称
ANF~\citep{Danvy:1991fk,Flanagan:1993cg} 。
\index{administrative normal form} \index{ANF}

建议使用两个相互递归的函数：\code{rco-atom} 和 \code{rco-exp} 来实现这个过程。其思想是将
\code{rco-atom} 应用于需要成为原子的子表达式，并将 \code{rco-exp} 应用于不需要原子的子表达式。这两个函数都接受 \LangVar{} 表达式作为输入。 \code{rco-exp} 函数返回一个表达式。 \code{rco-atom} 函数返回两个东西：原子表达式和将临时变量映射到复合子表达式的列表。你可以用 Racket \key{values} 形式从函数中返回多个东西，也可以用 \key{define-values} 形式从函数调用中接收多个东西。如果你不熟悉这些特性，请查阅 Racket 文档。
此外，在函数返回多个值的情况下，
\href{https://docs.racket-lang.org/reference/for.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._for%2Flists%29%29}{\code{for/lists}}
  形式用于将函数应用到列表的每个元素。
  \index{for/lists}

回到示例程序 \code{(+ 52 (- 10))} ，应该使用 \code{rco-atom} 函数处理子表达式 \code{(- 10)} 因为它是 \code{+} 的一个参数，因此需要变成原子的。\code{rco-atom}
应用于 \code{(- 10)} 的输出如下。

\begin{tabular}{lll}
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
(- 10)
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
tmp.1
((tmp.1 . (- 10)))
\end{lstlisting}
\end{minipage}
\end{tabular}

要特别注意下列程序，它们将变量绑定到原子表达式。应该保持这些变量绑定不变，如右边的程序所示 \\
\begin{tabular}{lll}
\begin{minipage}{0.4\textwidth}
% var_test_20.rkt
\begin{lstlisting}
(let ([a 42])
  (let ([b a])
    b))
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
(let ([a 42])
  (let ([b a])
    b))
\end{lstlisting}
\end{minipage}
\end{tabular} \\
如果不小心实现 \key{rco-exp} 和 \key{rco-atom} ，可能会产生以下带有不必要临时变量的输出。\\
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
(let ([tmp.1 42])
  (let ([a tmp.1])
    (let ([tmp.2 a])
      (let ([b tmp.2])
        b))))
\end{lstlisting}
\end{minipage}

\begin{exercise}\normalfont
%
在 \code{compiler.rkt} 实现 \code{remove-complex-opera*} 函数。
%
创建三个新的 \LangInt{} 程序，执行 \code{remove-complex-opera*} 通道中的有趣代码 (遵循与前面相同的文件名准则。)。
%
在 \code{run-tests.rkt} 脚本中，将以下条目添加到 \code{passes} 列表中，然后运行该脚本以测试编译器。
\begin{lstlisting}
(list "remove-complex" remove-complex-opera* interp-Rvar type-check-Rvar)
\end{lstlisting}
在调试编译器时，查看每个通道输出的中间程序通常是很有用的。 要打印中间程序，请在 \code{run-tests.rkt} 中的
\code{interp-tests} 调用之前放置以下内容。
\begin{lstlisting}
(debug-level 1)  
\end{lstlisting}
\end{exercise}


\section{解释控制}
\label{sec:explicate-control-Rvar}

 \code{explicate-control} 通道将 \LangVar{} 程序编译为 \LangCVar{}
程序， \LangCVar{} 程序在语法中明确了执行顺序。现在，这相当于将 \key{let} 构造成一个赋值语句序列。例如，考虑下面的
\LangVar{} 程序。\\
% var_test_11.rkt
\begin{minipage}{0.96\textwidth}
\begin{lstlisting}
(let ([y (let ([x 20])
         (+ x (let ([x 22]) x)))])
  y)
\end{lstlisting}
\end{minipage}\\
%
前面的通道和 \code{explicate-control} 的输出如下所示。回想一下， \key{let} 的右边在它的主体之前执行，所以这个程序的求值顺序是把 \code{20} 赋值给 \code{x.1} ，把 \code{22} 赋值给 \code{x.2} ，把
\code{(+ x.1 x.2)} 赋值给 \code{y} ，然后返回 \code{y} 。实际上， \code{explicate-control} 的输出使这种排序变得明确。\\
\begin{tabular}{lll}
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
(let ([y (let ([x.1 20]) 
           (let ([x.2 22])
             (+ x.1 x.2)))])
 y)
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}[language=C]
start:
  x.1 = 20;
  x.2 = 22;
  y = (+ x.1 x.2);
  return y;
\end{lstlisting}
\end{minipage}
\end{tabular}

\begin{figure}[tbp]
\begin{lstlisting}
(define (explicate-tail e)
  (match e
    [(Var x) ___]
    [(Int n) (Return (Int n))]
    [(Let x rhs body) ___]
    [(Prim op es) ___]
    [else (error "explicate-tail unhandled case" e)]))

(define (explicate-assign e x cont)
  (match e
    [(Var x) ___]
    [(Int n) (Seq (Assign (Var x) (Int n)) cont)]
    [(Let y rhs body) ___]
    [(Prim op es) ___]
    [else (error "explicate-assign unhandled case" e)]))

(define (explicate-control p)
  (match p
    [(Program info body) ___]))
\end{lstlisting}
\caption{ \key{explicate-control} 通道的框架。}
\label{fig:explicate-control-Rvar}
\end{figure}

这个通道的组织方式取决于我们之前提到的尾部位置的概念。形式上， \LangVar{} 上下文中的 \emph{尾部位置}\index{tail position} 由以下两条规则递归定义。
\begin{enumerate}
\item 在 $\PROGRAM{\code{()}}{e}$, 中，表达式 $e$ 位于尾部位置。
\item 如果 $\LET{x}{e_1}{e_2}$ 在尾部位置，那么 $e_2$ 也是。
\end{enumerate}

建议使用两个相互递归的函数，即 \code{explicate-tail} 和
\code{explicate-assign} 来实现 \code{explicate-control} ，如图~\ref{fig:explicate-control-Rvar} 的框架代码中所建议。 \code{explicate-tail}
函数应用于位于尾部位置的表达式，而
\code{explicate-assign} 函数应用于出现在 \key{let} 右侧的表达式。
%
 \code{explicate-tail} 函数接受 \LangVar{} 中的 \Exp{} 作为输入，并在 \LangCVar{} 中生成一个 \Tail{} (
见图~\ref{fig:c0-syntax})。
%
 \code{explicate-assign} 函数在 \Exp{} 中接受 \LangVar{} ，也就是要被赋值的变量，在 \Tail{} 中接受
\LangCVar{} ，表示赋值之后的代码。
\code{explicate-assign} 函数在 \LangCVar{} 中返回一个 $\Tail$ 。

 \code{explicate-assign} 函数采用累加器传递方式，因为 \code{cont} 形参用于累加输出。读者可能会试图用一种更直接的方式组织
\code{explicate-assign} ，而不使用
\code{cont} 参数，可能会使用 \code{append} 来组合状态。我们对这种替代提出警告，因为累加器通道样式是第~\ref{ch:Rif} 章中为条件表达式生成高质量代码的关键。

\begin{exercise}\normalfont
%
在 \code{compiler.rkt} 中实现 \code{explicate-control} 函数。创建三个新的 \LangInt{} 程序来执行 \code{explicate-control} 中的代码。
%
在 \code{run-tests.rkt} 脚本中，将以下条目添加到 \code{passes} 列表中，然后运行脚本来测试编译器。
\begin{lstlisting}
(list "explicate control" explicate-control interp-Cvar type-check-Cvar)  
\end{lstlisting}
\end{exercise}

\section{选择指令}
\label{sec:select-Rvar}
\index{instruction selection}

在 \code{select-instructions} 中，开始将 \LangCVar{} 转换为 \LangXVar{} 。此通道的目标语言是x86的一种变体，该变体仍使用变量，因此将形式为 $\VAR{\itm{var}}$ 的AST节点添加到 \LangXInt{} 抽象语法的 \Arg{} 非终端中 (Figure~\ref{fig:x86-int-ast}) 。建议使用三个辅助函数来实现 \code{select-instructions} ，分别针对
\LangCVar{} 的非终端： $\Atm$ 、 $\Stmt$ 和 $\Tail$ 。

 $\Atm$ 的情况很简单，变量保持不变，整数常量更改为立即数：
$\INT{n}$ 更改为 $\IMM{n}$ 。

接下来考虑 $\Stmt$ 的情况，从算术运算开始。例如，考虑加法操作。可以使用 \key{addq} 指令，但它执行一个就地更新。所以可以把 $\itm{arg}_1$ 移到左边的 \itm{var} 中，然后把 $\itm{arg}_2$ 加到 \itm{var} 中。\\
\begin{tabular}{lll}
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
|$\itm{var}$| = (+ |$\itm{arg}_1$| |$\itm{arg}_2$|);
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
movq |$\itm{arg}_1$|, |$\itm{var}$|
addq |$\itm{arg}_2$|, |$\itm{var}$|
\end{lstlisting}
\end{minipage}
\end{tabular} \\
%
还有一些情况需要特别注意，以避免生成不必要的复杂代码。例如，如果加法的一个参数与赋值的左边的变量相同，那么就不需要额外的move指令。赋值语句可以被翻译成一个 \key{addq} 指令，如下所示。\\
\begin{tabular}{lll}
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
|$\itm{var}$| = (+ |$\itm{arg}_1$| |$\itm{var}$|);
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
addq |$\itm{arg}_1$|, |$\itm{var}$|
\end{lstlisting}
\end{minipage}
\end{tabular}

 \key{read} 操作在x86汇编中没有直接对应的，所以用C语言编写的文件 \code{runtime.c} 中的函数
\code{read\_int} 来提供这个功能~\citep{Kernighan:1988nx} 。通常，将该文件中的所有功能称为 \emph{运行时系统}\index{runtime
  system} ，或简称为 \emph{运行时} 。编译生成的x86汇编代码时，需要将 \code{runtime.c} 编译为
\code{runtime.o} (使用 \code{gcc} 选项
\code{-c} 的``object file'') ，并将其链接到可执行文件中。对于我们的代码生成目的，要做的就是将
\key{read} 的赋值转换为对 \code{read\_int} 函数的调用，然后将其从 \code{rax} 移至左侧变量。(回想一下，函数的返回值进入 \code{rax} 。)  \\
\begin{tabular}{lll}
\begin{minipage}{0.3\textwidth}
\begin{lstlisting}
|$\itm{var}$| = (read);
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.3\textwidth}
\begin{lstlisting}
callq read_int
movq %rax, |$\itm{var}$|
\end{lstlisting}
\end{minipage}
\end{tabular} 

 $\Tail$ 非终端有两种情况： \key{Return} 和
\key{Seq} 。关于 \key{Return} ，我们建议将其视为对 \key{rax} 寄存器的赋值，然后跳转到程序的结尾 (所以结论需要标注)。
对于 $\SEQ{s}{t}$ ，可以递归地翻译语句 $s$ 和尾部 $t$
，然后附加产生的指令。

\begin{exercise}
\normalfont 实现\code{compiler.rkt} 中的 \key{select-instructions} 通道。创建三个新的示例程序，它们被设计来练习本步骤中所有有趣的情况。
%
在 \code{run-tests.rkt} 脚本中，将以下条目添加到 \code{passes} 列表中，然后运行脚本来测试编译器。
\begin{lstlisting}
(list "instruction selection" select-instructions interp-pseudo-x86-0)
\end{lstlisting}
\end{exercise}


\section{分配空间}
\label{sec:assign-Rvar}

 \key{assign-homes} 将 \LangXVar{} 程序编译成不再使用程序变量的
\LangXVar{} 程序。
因此， \key{assign-homes} 通道负责将所有程序变量放入寄存器或堆栈中。为了提高运行时的效率，最好是将变量放在寄存器中，但是由于只有16个寄存器，一些程序必须求助于将一些变量放在堆栈中。在本章中，重点讨论在堆栈中放置变量的机制。在第~\ref{ch:register-allocation-Rvar} 章中研究一种在寄存器中放置变量的算法。

再次考虑第 ~\ref{sec:remove-complex-opera-Rvar} 节中的 \LangVar{} 程序。
% var_test_20.rkt
\begin{lstlisting}
(let ([a 42])
  (let ([b a])
    b))
\end{lstlisting}
 \code{select-instructions} 的输出显示在左边， \code{assign-homes} 的输出显示在右边。在本例中，将变量 \code{a} 分配给堆栈位置 \code{-8(\%rbp)} ，将变量 \code{b} 分配给堆栈位置 \code{-16(\%rbp)} 。\\
\begin{tabular}{l}
  \begin{minipage}{0.4\textwidth}
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
locals-types:
    a : Integer, b : Integer
start: 
    movq $42, a
    movq a, b
    movq b, %rax
    jmp conclusion
\end{lstlisting}
\end{minipage}
{$\Rightarrow$}
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
stack-space: 16
start:
    movq $42, -8(%rbp)
    movq -8(%rbp), -16(%rbp)
    movq -16(%rbp), %rax
    jmp conclusion
\end{lstlisting}
\end{minipage}
\end{tabular} 

\code{X86Program} 节点 $\itm{info}$ 中的 \code{locals-types} 条目是一个将程序中的所有变量映射到它们类型 (目前仅为 \code{Integer}) 的列表。
\code{assign-homes} 通道应将所有这些变量的使用替换为堆栈位置。顺便说一句， \code{locals-types} 条目由支持代码中的 \code{type-check-Cvar} 计算，将其安装在 $\itm{info}$ 节点的 \code{CProgram} 字段中，应传播到 \code{X86Program} 节点。

在为堆栈位置赋值变量的过程中，可以方便地在 \key{X86Program} 节点的 $\itm{info}$ 字段中计算和存储帧的大小(以字节为单位)，使用键 \code{stack-space} ，稍后生成 \code{main} 过程的结论时需要这个键。x86-64标准要求帧大小是16字节的倍数。\index{frame}

\begin{exercise}\normalfont
实现 \code{compiler.rkt} 中的 \key{assign-homes} 通道，为非终端 \Arg{} 、\Instr{} 和
\Block{} 定义辅助函数。建议辅助函数使用一个额外的参数，该参数是将变量名称映射到空间（现在为堆栈位置）的清单。
%
在 \code{run-tests.rkt} 脚本中，将以下条目添加到 \code{passes} 列表中，然后运行脚本来测试编译器。
\begin{lstlisting}
(list "assign homes" assign-homes interp-x86-0)
\end{lstlisting}
\end{exercise}


\section{补丁说明}
\label{sec:patch-s0}

 \code{patch-instructions} 通道从 \LangXVar{} 编译到
\LangXInt{} 方法是确保每条指令都遵守一个限制：一条指令最多只能有一个参数是一个内存引用。

我们回到下面的例子。
% var_test_20.rkt
\begin{lstlisting}
   (let ([a 42])
     (let ([b a])
       b))
\end{lstlisting}
 \key{assign-homes} 通道为该程序生成以下输出。\\
\begin{minipage}{0.5\textwidth}
\begin{lstlisting}
stack-space: 16
start:
    movq $42, -8(%rbp)
    movq -8(%rbp), -16(%rbp)
    movq -16(%rbp), %rax
    jmp conclusion
\end{lstlisting}
\end{minipage}\\
第二个 \key{movq} 指令有问题，因为两个参数都是堆栈位置。建议从源位置移动到寄存器 \key{rax} ，然后从 \key{rax} 移动到目标位置来解决这个问题，如下所示。
\begin{lstlisting}
   movq -8(%rbp), %rax
   movq %rax, -16(%rbp)
\end{lstlisting}

\begin{exercise}
\normalfont 在 \key{patch-instructions} 中实现
\code{compiler.rkt} 通道。创建三个新的示例程序，它们被设计来练习本步骤中所有有趣的情况。
%
在 \code{run-tests.rkt} 脚本中，将以下条目添加到 \code{passes} 列表中，然后运行脚本来测试编译器。
\begin{lstlisting}
(list "patch instructions" patch-instructions interp-x86-0)
\end{lstlisting}
\end{exercise}


\section{打印 x86}
\label{sec:print-x86}

编译器从 \LangVar{} 到x86的最后一步是将
\LangXInt{} AST (在图~\ref{fig:x86-int-ast} 中定义) 转换为字符串表示 (在图~\ref{fig:x86-int-concrete} 中定义) 。 Racket 的 \key{format} 和
\key{string-append} 函数在这方面很有用。这个步骤需要完成的主要工作是创建 \key{main} 函数及其前奏和结论的标准指令，如 ~\ref{sec:x86} 节的图 ~\ref{fig:p1-x86} 所示。您需要知道堆栈帧所需的空间大小，这可以从 \key{X86Program} 节点的 $\itm{info}$ 字段中的 \code{stack-space} 条目中获得。

在Mac OS X上运行时，编译器应该在 \key{main} 这样的标签前加上下划线前缀。 Racket 调用 \code{(system-type 'os)} 用于判断编译器运行在哪个操作系统上。它返回 \code{'macosx} 、\code{'unix} 或 \code{'windows} 。

\begin{exercise}\normalfont
%
在 \key{print-x86} 中实现 \code{compiler.rkt} 通道。
%
在 \code{run-tests.rkt} 脚本中，将以下条目添加到 \code{passes} 列表中，然后运行脚本来测试编译器。
\begin{lstlisting}
(list "print x86" print-x86 #f)
\end{lstlisting}
%  
取消对 \key{compiler-tests} 函数
(附录~\ref{appendix:utilities}) 的调用的注释，该函数通过执行生成的x86代码来测试完整的编译器。编译提供的
\key{runtime.c} 文件到 \key{runtime.o} ，使用 \key{gcc}. 运行脚本来测试编译器。
\end{exercise}


\section{挑战： \LangVar{} 的部分求值器}
\label{sec:pe-Rvar}
\index{partial evaluation}

本节描述一些可选的挑战练习，这些练习涉及到调整和改进第 ~\ref{sec:partial-evaluation} 节中介绍的 \LangInt{} 的部分求值器。

\begin{exercise}\label{ex:pe-Rvar}
\normalfont
  
调整~\ref{sec:partial-evaluation} 节
(图~\ref{fig:pe-arith}) 中的部分求值程序，使其适用于 \LangVar{} 程序，而不是 \LangInt{} 程序。回想一下， \LangVar{} 将 \key{let} 绑定和变量添加到 \LangInt{} 语言中，所以你需要在 \code{pe-exp} 函数中为它们添加用例。完成后，将部分求值通道添加到编译器前端，并确保编译器仍然通过所有测试。
\end{exercise}

下一个练习以练习~\ref{ex:pe-Rvar} 为基础。

\begin{exercise}
\normalfont

用更了解算术的函数替换 \code{pe-neg} 和
\code{pe-add} 辅助函数，改进部分求值器。例如，部分求值程序应该将
\[
\code{(+ 1 (+ (read) 1))} \qquad \text{翻译为} \qquad
\code{(+ 2 (read))}
\]
为此， \code{pe-exp} 函数应该以以下语法的 $\itm{residual}$ 非终端的形式产生输出。其思想是，当处理一个加法表达式时，我们总是可以产生：1)一个整数常数；2)左边有一个整数常数，而右边没有整数常数的加法表达式；3)一个子表达式中没有一个是整数常数的加法表达式。
\[
\begin{array}{lcl}
\itm{inert} &::=& \Var \mid \LP\key{read}\RP \mid \LP\key{-} \;\Var\RP
    \mid \LP\key{-} \;\LP\key{read}\RP\RP
    \mid \LP\key{+} \; \itm{inert} \; \itm{inert}\RP\\
  &\mid& \LP\key{let}~\LP\LS\Var~\itm{inert}\RS\RP~ \itm{inert} \RP \\
\itm{residual} &::=& \Int \mid \LP\key{+}\; \Int\; \itm{inert}\RP \mid \itm{inert} 
\end{array}
\]
 \code{pe-add} 和 \code{pe-neg} 函数可以假设它们的输入是 $\itm{residual}$ 表达式，它们应该返回
$\itm{residual}$ 表达式。一旦改进完成，确保编译器仍然通过所有的测试。毕竟，如果产生不正确的结果，快速的代码是无用的!
\end{exercise}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{寄存器分配}
\label{ch:register-allocation-Rvar}

\index{register allocation}

在第~\ref{ch:Rvar} 章中，学习如何在栈中存储变量。在本章中，学习如何通过在寄存器中放置一些变量来提高生成代码的性能。CPU可以在一个周期内访问寄存器，而访问堆栈需要10到100个周期。图~\ref{fig:reg-eg}
中的程序是一个运行示例。源程序在左侧，指令选择的输出在右侧。这个程序几乎是用x86汇编语言编写的，但它仍然使用变量。

\begin{figure}
\begin{minipage}{0.45\textwidth}
Example \LangVar{} program:
% var_test_28.rkt
\begin{lstlisting}
(let ([v 1])
  (let ([w 42])
    (let ([x (+ v 7)])
      (let ([y x])
	(let ([z (+ x w)])
	  (+ z (- y)))))))
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.45\textwidth}
After instruction selection:
\begin{lstlisting}
locals-types:
    x : Integer, y : Integer,
    z : Integer, t : Integer,
    v : Integer, w : Integer
start:
    movq $1, v
    movq $42, w
    movq v, x
    addq $7, x
    movq x, y
    movq x, z
    addq w, z
    movq y, t
    negq t
    movq z, %rax
    addq t, %rax
    jmp conclusion
\end{lstlisting}
\end{minipage}
\caption{一个寄存器分配的运行示例。}
\label{fig:reg-eg}
\end{figure}

寄存器分配的目标是将尽可能多的变量放入寄存器中。有些程序的变量比寄存器多，所以我们不能总是将每个变量映射到不同的寄存器。幸运的是，在程序执行期间的不同时间需要不同的变量是很常见的，在这种情况下，几个变量可以映射到同一个寄存器。
考虑图~\ref{fig:reg-eg} 中的变量 \code{x} 和 \code{z} 。变量 \code{x} 移动到 \code{z} 后就不再需要它了。另一方面，变量 \code{z} 只在这一点之后才使用，因此 \code{x} 和 \code{z} 可以共享相同的寄存器。第~\ref{sec:liveness-analysis-Rvar} 节的主题是如何计算哪里需要变量。一旦有了这些信息，就计算同时需要哪些变量，即哪些变量相互
\emph{干扰} ，并将这种关系表示为一个无向图，顶点是变量，边表示两个变量干扰(第~\ref{sec:build-interference} 节) 。然后将寄存器分配模型化为一个图着色问题(第~\ref{sec:graph-coloring} 节)。

如果用尽所有的寄存器，就把剩余的变量放在堆栈上，就像在第~\ref{ch:Rvar} 章中所做的那样。通常使用动词 \emph{溢出}
将变量赋值给堆栈位置。溢出变量的决定将作为图形着色过程的一部分进行处理（第~\ref{sec:graph-coloring} 节)。

做一个简化的假设，即每个变量都被分配到一个位置(寄存器或堆栈地址)。更复杂的方法是将变量分配到程序不同区域中的一个或多个位置。例如，如果一个变量在短序列中被多次使用，然后在许多其他指令之后才再次使用，那么在初始序列期间将该变量赋值给一个寄存器，然后在其剩余的生命周期中将其移动到堆栈中可能会更有效。建议感兴趣的读者向
\citet{Cooper:2011aa} 了解有关该方法的更多信息。

% discuss prioritizing variables based on how much they are used.

\section{寄存器和调用约定}
\label{sec:calling-conventions}
\index{calling conventions}

当执行寄存器分配时，需要注意在x86中的控制函数调用如何执行
\emph{调用约定} \index{calling conventions} 。
%
即使 \LangVar{} 不包括程序员定义的函数，生成的代码也包含一个由操作系统调用的 \code{main} 函数，并且生成的代码包含对\code{read\_int} 函数的调用。

函数调用需要两段代码之间的协调，这两段代码可能由不同的程序员编写或由不同的编译器生成。这里我们遵循Linux和MacOS上的GNU C编译器使用的System V调用约定~\citep{Bryant:2005aa,Matz:2013aa} 。
%
调用约定包括关于函数如何共享寄存器使用的规则。特别是，调用方负责在函数调用之前释放一些寄存器，供被调用方使用。
这些被称为 \emph{调用者保存寄存器}
\index{caller-saved registers}
，它们是
\begin{lstlisting}
rax rcx rdx rsi rdi r8 r9 r10 r11
\end{lstlisting}
另一方面，被调用方负责保留 \emph{调用者保存寄存器} ，\index{callee-saved registers}
即
\begin{lstlisting}
rsp rbp rbx r12 r13 r14 r15
\end{lstlisting}

我们可以从调用方视图和被调用方视图两个角度来考虑这个调用方/被调用方约定:
\begin{itemize}
\item 调用方应该假定所有调用方保存的寄存器都被调用方用任意值重写。另一方面，调用者可以安全地假设所有被调用者保存的寄存器在调用后包含与调用前相同的值。
\item 被调用方可以自由地使用任何调用方保存的寄存器。
  但是，如果被调用方希望使用被调用方保存的寄存器，被调用方必须在返回给调用方之前安排将原始值放回寄存器中。这可以通过将值保存到函数前奏中的堆栈中，并在函数的结论中恢复值来实现。
\end{itemize}

在x86中，寄存器还用于向函数传递参数和返回值。特别地，函数的前六个参数按以下顺序，在以下六个寄存器中传递。
\begin{lstlisting}
rdi rsi rdx rcx r8 r9
\end{lstlisting}
如果有六个以上的参数，则约定是将调用方框架上的空间用于其余参数。然而，在第~\ref{ch:Rfun} 章中，将不需要超过6个参数。目前，关心的唯一函数是 \code{read\_int} ，它接受零参数。
%
寄存器 \code{rax} 用于函数的返回值。

下一个问题是这些调用约定如何影响寄存器分配。考虑图~\ref{fig:example-calling-conventions} 中的 \LangVar{} 程序。首先从调用者的角度分析这个例子，然后从被调用者的角度分析。

该程序两次调用 \code{read} 函数。另外，变量 \code{x} 在第二次调用 \code{read} 时被使用，所以需要确保 \code{x} 中的值不会在调用 \code{read} 时被意外地删除。一种明显的方法是，在每次函数调用之前，将调用方保存的寄存器中的所有值保存到堆栈中，并在每次调用之后恢复它们。这样，如果寄存器分配器选择将 \code{x}
分配给调用方保存的寄存器，那么它的值将在调用 \code{read} 的过程中被保留。然而，保存和恢复到堆栈相对较慢。如果 \code{x} 没有被多次使用，那么最好首先将 \code{x} 分配给一个堆栈位置。或者更好的是，如果可以将 \code{x} 放置在被调用者保存的寄存器中，那么它就不需要在函数调用期间保存和恢复。

对于在函数调用期间使用的变量，推荐的方法是将它们赋值给被调用方保存的寄存器，或者将它们溢出到堆栈中。另一方面，对于在函数调用期间没有使用的变量，按顺序尝试以下替代方法： 1) 寻找一个可用的调用者保存的寄存器(为被调用者保存的寄存器中的其他变量留出空间)； 2) 查找被调用者保存的寄存器； 3) 将变量溢出到堆栈中。

在一个图着色寄存器分配器中实现这种方法很简单。首先，我们知道每个函数调用过程中使用了哪些变量，因为我们为每条指令计算了这些信息(第~\ref{sec:liveness-analysis-Rvar} 节)。其次，当构建干扰图(第~\ref{sec:build-interference}节)时，我们可以在这些变量和干扰图中的调用者保存的寄存器之间放置一条边。这防止图着色算法将这些变量分配给调用者保存的寄存器。

回到图~\ref{fig:example-calling-conventions} 中的示例，分析右边生成的x86代码，重点关注
\code{start} 块。注意变量 \code{x} 被赋值给
\code{rbx} ，一个被调用者保存的寄存器。因此，在第二次调用 \code{read\_int} 时，它已经在一个安全的地方。接下来，注意变量 \code{y} 被赋值给 \code{rcx} ，一个调用者保存的寄存器，因为在块的其余部分没有函数调用。

接下来从调用者的角度来分析这个例子，重点是 \code{main} 函数的前奏和结论。像往常一样，前奏从将 \code{rbp} 寄存器保存到堆栈并将 \code{rbp} 设置为当前堆栈指针开始处。现在我们知道为什么需要保存 \code{rbp} ：它是一个被调用者保存的寄存器。
然后，前奏将 \code{rbx} 推入堆栈，因为： 1) \code{rbx}
是被调用者保存的寄存器； 2) \code{rbx} 赋值给变量
(\code{x}) 。其他被调用者保存的寄存器没有保存在前奏中，因为它们没有被使用。前奏从 \code{rsp} 中减去8个字节以使其对齐16个字节，然后跳转到
\code{start} 块。将注意力转移到 \code{conclusion} 上，看到 \code{rbx} 用 \code{popq}
指令从堆栈中恢复。  \index{prelude}\index{conclusion}

\begin{figure}[tp]
\begin{minipage}{0.45\textwidth}
 \LangVar{} 示例程序：
%var_test_14.rkt
\begin{lstlisting}
(let ([x (read)])
  (let ([y (read)])
    (+ (+ x y) 42)))
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.45\textwidth}
生成的x86汇编：
\begin{lstlisting}
start:
	callq	read_int
	movq	%rax, %rbx
	callq	read_int
	movq	%rax, %rcx
	addq	%rcx, %rbx
	movq	%rbx, %rax
	addq	$42, %rax
	jmp _conclusion

	.globl main
main:
	pushq	%rbp
	movq	%rsp, %rbp
	pushq	%rbx
	subq	$8, %rsp
	jmp start
conclusion:
	addq	$8, %rsp
	popq	%rbx
	popq	%rbp
	retq
\end{lstlisting}
\end{minipage}
\caption{一个函数调用的例子}
  \label{fig:example-calling-conventions}
\end{figure}

\clearpage

\section{活性分析}
\label{sec:liveness-analysis-Rvar}
\index{liveness analysis}


 \code{uncover-live} 通道执行 \emph{活性分析} ，也就是说，它发现程序的不同区域中哪些变量在使用。
%
如果一个变量或寄存器的当前值在程序的后面某个点被使用，那么这个变量或寄存器在程序的某个点就是 \emph{活} 的。把变量和寄存器统称为 \emph{位置} 。
%
考虑下面的代码片段，其中有两次对
\code{b} 的写操作。 \code{a} 和 \code{b} 是同时活的吗?
\begin{center}
  \begin{minipage}{0.96\textwidth}
\begin{lstlisting}[numbers=left,numberstyle=\tiny]
movq $5, a
movq $30, b
movq a, c
movq $10, b
addq b, c
\end{lstlisting}
\end{minipage}
\end{center}
答案是否定的，因为 \code{a} 从1到3行是活的，
\code{b} 从4到5行是活的。在第2行写入 \code{b} 的整数从未被使用，因为它在下一次读取(第5行)之前被覆盖(第4行)。

\begin{wrapfigure}[19]{l}[1.0in]{0.6\textwidth}
  \small
  \begin{tcolorbox}[title=\href{https://docs.racket-lang.org/reference/sets.html}{ Racket 集合包}]
    \emph{set} 是没有重复的无序元素集合。
    \index{set}
  \begin{description}
  \item[$\LP\code{set}\,v\,\ldots\RP$] 构造一个包含指定元素的集合。
  \item[$\LP\code{set-union}\,set_1\,set_2\RP$] 返回两个集合的并集。
  \item[$\LP\code{set-subtract}\,set_1\,set_2\RP$] 返回两个集合的差值。
  \item[$\LP\code{set-member?}\,set\,v\RP$] $v$ 是 $set$ 中的元素吗？
  \item[$\LP\code{set-count}\,set\RP$] $set$ 集合中有多少个元素？
  \item[$\LP\code{set->list}\,set\RP$] 集合转换成列表。
  \end{description}
  \end{tcolorbox}
\end{wrapfigure}

活动位置可以通过将指令序列往回遍历(即按执行顺序向后遍历)来计算。设
$I_1,\ldots, I_n$ 为指令序列。我们在指令  $I_k$ 之后为活动位置集写为
$L_{\mathsf{after}}(k)$ ，在指令 $I_k$ 之前为活动位置集写为 $L_{\mathsf{before}}(k)$ 。一条指令之后的活动位置总是与下一条指令之前的活动位置相同。 \index{live-after} \index{live-before}
\begin{equation} \label{eq:live-after-before-next}
  L_{\mathsf{after}}(k) = L_{\mathsf{before}}(k+1)
\end{equation}
开始时，在最后一条指令之后没有实时位置，所以
\begin{equation}\label{eq:live-last-empty}
  L_{\mathsf{after}}(n) = \emptyset
\end{equation}
然后我们重复应用以下规则，将指令序列从头到尾遍历。
\begin{equation}\label{eq:live-before-after-minus-writes-plus-reads}
  L_{\mathtt{before}}(k) = (L_{\mathtt{after}}(k) - W(k)) \cup R(k),
\end{equation}
其中 $W(k)$ 是指令 $I_k$ 写入的位置，
$R(k)$ 是指令 $I_k$ 读取的位置。

对于 \code{jmp} 指令有一个特殊情况。在 \code{jmp} 之前存在的位置应该是
$L_{\mathtt{before}}$ 中跳转目标的位置。因此，建议维护一个名为 \code{label->live} 的列表，该列表针对其块中的第一条指令将每个标签映射到 $L_{\mathtt{before}}$ 。目前， \LangXVar{} 程序中唯一的 \code{jmp} 是结尾的那个。(例如，如图~\ref{fig:reg-eg} 所示。)
结论从 \ttm{rax} 和 \ttm{rsp} 读取，所以列表应该将结论映射到集合 $\{\ttm{rax},\ttm{rsp}\}$ 。

回顾一下上面的例子，从第5行开始应用这些公式。在图
~\ref{fig:liveness-example-0} 中收集答案。\code{addq b, c} 指令的 $L_{\mathsf{after}}$ 是 $\emptyset$ ，因为它是最后一条指令(公式~\ref{eq:live-last-empty})。这个指令的
$L_{\mathsf{before}}$ 是 $\{\ttm{b} ，\ttm{c}\}$
，因为它从变量 \code{b} 和 \code{c}
(公式~\ref{eq:live-before-after-minus-writes-plus-reads}) 中读取数据，即
\[
   L_{\mathsf{before}}(5) = (\emptyset - \{\ttm{c}\}) \cup \{ \ttm{b}, \ttm{c} \} = \{ \ttm{b}, \ttm{c} \}
\]
继续移动第4行指令 \code{movq \$10, b} ，将第5行中的 live-before 集合复制为该指令的 live-after 集合(公式~\ref{eq:live-after-before-next})。
\[
  L_{\mathsf{after}}(4) = \{ \ttm{b}, \ttm{c} \}
\]
这个 move 指令写入 \code{b} ，而不从任何变量中读取，所以有以下live-before集合(公式~\ref{eq:live-before-after-minus-writes-plus-reads})。
\[
  L_{\mathsf{before}}(4) = (\{\ttm{b},\ttm{c}\} - \{\ttm{b}\}) \cup \emptyset = \{ \ttm{c} \}
\]
 \code{movq a, c}的 live-before 是 $\{\ttm{a}\}$ ，因为它向 $\{\ttm{c}\}$ 写入并从 $\{\ttm{a}\}$
读取(公式~\ref{eq:live-before-after-minus-writes-plus-reads}) 。\code{movq \$30, b} 的
live-before 是 $\{\ttm{a}\}$ ，因为它写入一个非活动的变量，不从变量中读取。
最后， \code{movq \$5, a} 的 live-before 是 $\emptyset$
，因为它写入变量 \code{a} 。

\begin{figure}[tbp]
\begin{minipage}{0.45\textwidth}
\begin{lstlisting}[numbers=left,numberstyle=\tiny]
movq $5, a
movq $30, b
movq a, c
movq $10, b
addq b, c
\end{lstlisting}
\end{minipage}
\vrule\hspace{10pt}
\begin{minipage}{0.45\textwidth}
\begin{align*}
L_{\mathsf{before}}(1)=  \emptyset, 
L_{\mathsf{after}}(1)=  \{\ttm{a}\}\\
L_{\mathsf{before}}(2)=  \{\ttm{a}\},
L_{\mathsf{after}}(2)=  \{\ttm{a}\}\\
L_{\mathsf{before}}(3)=  \{\ttm{a}\},
L_{\mathsf{after}}(2)=  \{\ttm{c}\}\\
L_{\mathsf{before}}(4)=  \{\ttm{c}\},
L_{\mathsf{after}}(4)=  \{\ttm{b},\ttm{c}\}\\
L_{\mathsf{before}}(5)=  \{\ttm{b},\ttm{c}\},
L_{\mathsf{after}}(5)=  \emptyset
\end{align*}
\end{minipage}
\caption{在一个简短的示例上输出活性分析的示例。}
\label{fig:liveness-example-0}
\end{figure}

\begin{exercise}\normalfont
  对图~\ref{fig:reg-eg} 中运行的示例执行活性分析，计算每个指令的 live-before 和 live-after 集合。将您的答案与图~\ref{fig:live-eg} 中所示的解决方案进行比较。
\end{exercise}

\begin{figure}[tp]
\hspace{20pt}
\begin{minipage}{0.45\textwidth}
\begin{lstlisting}
                       |$\{\ttm{rsp}\}$|    
    movq $1, v
                       |$\{\ttm{v},\ttm{rsp}\}$|    
    movq $42, w
                       |$\{\ttm{v},\ttm{w},\ttm{rsp}\}$|    
    movq v, x
                       |$\{\ttm{w},\ttm{x},\ttm{rsp}\}$|    
    addq $7, x
                       |$\{\ttm{w},\ttm{x},\ttm{rsp}\}$|    
    movq x, y
                       |$\{\ttm{w},\ttm{x},\ttm{y},\ttm{rsp}\}$|    
    movq x, z
                       |$\{\ttm{w},\ttm{y},\ttm{z},\ttm{rsp}\}$|    
    addq w, z
                       |$\{\ttm{y},\ttm{z},\ttm{rsp}\}$|
    movq y, t
                       |$\{\ttm{t},\ttm{z},\ttm{rsp}\}$|    
    negq t
                       |$\{\ttm{t},\ttm{z},\ttm{rsp}\}$|    
    movq z, %rax
                       |$\{\ttm{rax},\ttm{t},\ttm{rsp}\}$|    
    addq t, %rax
                       |$\{\ttm{rax},\ttm{rsp}\}$|
    jmp conclusion
\end{lstlisting}
\end{minipage}

\caption{这个正在运行的例子说明 live-after 集合。}
\label{fig:live-eg}
\end{figure}

\begin{exercise}\normalfont
实现 \code{uncover-live} 通道。将 live-after 集合序列存储在 \code{Block}
结构的 $\itm{info}$ 字段中。
%
建议创建一个辅助函数，接受一个指令列表和一个初始的l live-after 集合(通常为空)，并返回 live-after 集合列表。
%
还建议创建辅助函数： 1) 计算出现在 \Arg{} 的位置集； 2) 计算指令读取的位置( $R$ 函数)； 3) 指令所写的位置( $W$ 函数)。 \code{callq} 指令应该在其写集 $W$ 中包含所有调用者保存的寄存器，因为调用约定说，这些寄存器可以在函数调用期间写入。同样， \code{callq} 指令应该在其读集 $R$ 中包含适当的参数传递寄存器，这取决于被调用函数的种类。 (这就是为什么 \code{callq} 的抽象语法包含细节。)
\end{exercise}

\clearpage

\section{构建干涉图}
\label{sec:build-interference}

\begin{wrapfigure}[18]{r}[1.0in]{0.6\textwidth}
  \small
  \begin{tcolorbox}[title=\href{https://docs.racket-lang.org/graph/index.html}{ Racket 图形库}]
     \emph{图} 是顶点和边的集合，其中每条边连接两个顶点。如果图的每条边都从源指向目标，那么图就是 \emph{有向} 的。否则，图是
    \emph{无向} 的。
    \index{graph}\index{directed graph}\index{undirected graph}
  \begin{description}
  %% We currently don't use directed graphs. We instead use
  %% directed multi-graphs. -Jeremy
  %% \item[$\LP\code{directed-graph}\,\itm{edges}\RP$] constructs a
  %%   directed graph from a list of edges. Each edge is a list
  %%   containing the source and target vertex.
  \item[$\LP\code{undirected-graph}\,\itm{edges}\RP$] 从一列边构造一个无向图。每条边都由一个包含两个顶点的列表表示。
  \item[$\LP\code{add-vertex!}\,\itm{graph}\,\itm{vertex}\RP$]
    在图中插入一个顶点。
  \item[$\LP\code{add-edge!}\,\itm{graph}\,\itm{source}\,\itm{target}\RP$]
   在两个顶点之间插入一条边到图中。
  \item[$\LP\code{in-neighbors}\,\itm{graph}\,\itm{vertex}\RP$]
   返回给定顶点的所有邻近点的序列。
  \item[$\LP\code{in-vertices}\,\itm{graph}\RP$]
  返回图形中所有顶点的序列。
  \end{description}
\end{tcolorbox}
\end{wrapfigure}

根据活体分析，我们知道每个地方都在哪里。
但是，在分配寄存器时，需要回答具体形式的问题： $u$ 和 $v$ 位置是同时存在的吗?
(因此不能分配给同一个寄存器。) 为了更有效地回答这个问题，创建一个显式的数据结构， \emph{干涉图}\index{interference graph} 。干涉图是一个在两个位置之间有一条边的无向图，如果它们同时存在，也就是说，如果它们相互干扰。

计算干涉图的一种明显方法是查看每个指令和下一个指令之间的活动位置集合，并为同一集合中的每一对变量在图中添加一条边。这种方法并不理想，原因有二：首先，它很昂贵，因为在
 $n$ 活动位置的集合中，每对花费的时间为 $O(n^2)$ ；第二，在特殊情况下，两个位置拥有相同的值(因为一个被分配给另一个)，它们可以同时存在，而不会相互干扰。

计算干涉图的更好方法是关注写操作~\citep{Appel:2003fk} 。指令执行的写操作不能覆盖活动位置中的内容。因此，对于每条指令，在被写入的位置和活动的位置之间创建一条边。 (除了一个位置不能创造自交边。) 注意，对于 \key{callq} 指令，我们将所有被写入的调用者保存的寄存器都考虑在内，因此在每个活变量和每个调用者保存的寄存器之间添加一条边。对于
\key{movq} ，处理上述特殊情况时，如果 $v$ 与源匹配，则不在活动变量 $v$
和目标变量之间添加一条边。

\begin{enumerate}
\item 如果指令 $I_k$ 是一个移动，如 \key{movq} $s$\key{,}
  $d$ ，则对每一个 $v \in
  L_{\mathsf{after}}(k)$ 添加边 $(d,v)$ ，除非 $v = d$ 或 $v = s$ 。

\item 对于任何其他指令 $I_k$ ，对于每一个 $d \in W(k)$ ，
  为 $v \in L_{\mathsf{after}}(k)$ 增加一条边 $(d,v)$ ，除非 $v = d$ 。
  
%% \item If instruction $I_k$ is an arithmetic instruction such as
%%   \code{addq} $s$\key{,} $d$, then add the edge $(d,v)$ for every $v \in
%%   L_{\mathsf{after}}(k)$ unless $v = d$.

%% \item If instruction $I_k$ is of the form \key{callq}
%%   $\mathit{label}$, then add an edge $(r,v)$ for every caller-saved
%%   register $r$ and every variable $v \in L_{\mathsf{after}}(k)$.
\end{enumerate}

从图~\ref{fig:live-eg} 的顶部到底部，将上述规则应用于每个指令。强调一些说明。第一个指令是 \lstinline{movq $1, v} 和
live-after 集合是 $\{\ttm{v},\ttm{rsp}\}$ 。规则1适用，所以 \code{v}
干扰 \code{rsp} 。
%
第四个指令是 \lstinline{addq $7, x} 和 live-after
集合是 $\{\ttm{w},\ttm{x},\ttm{rsp}\}$ 。规则2适用于 $\ttm{x}$
干扰 \ttm{w} 和 \ttm{rsp} 。
%
下一个指令是 \lstinline{movq x, y} 和 live-after 集合是 $\{\ttm{w},\ttm{x},\ttm{y},\ttm{rsp}\}$ 。规则1适用，所以 \ttm{y}
会干扰 \ttm{w} 和 \ttm{rsp} ，但不会干扰 \ttm{x} ，因为 \ttm{x}
是移动的来源，因此 \ttm{x} 和 \ttm{y} 保持相同的值。图~\ref{fig:interference-results} 列出所有指令的干扰结果，得到的干扰图如图~\ref{fig:interfere} 所示。


\begin{figure}[tbp]
\begin{quote}
\begin{tabular}{ll}
\lstinline!movq $1, v!& \ttm{v} 干扰 \ttm{rsp},\\
\lstinline!movq $42, w!& \ttm{w} 干扰 \ttm{v} 和 \ttm{rsp},\\
\lstinline!movq v, x!& \ttm{x} 干扰 \ttm{w} 和 \ttm{rsp},\\
\lstinline!addq $7, x!& \ttm{x} 干扰 \ttm{w} 和 \ttm{rsp},\\
\lstinline!movq x, y!& \ttm{y} 干扰 \ttm{w} 和 \ttm{rsp} ，\ttm{x} 除外,\\
\lstinline!movq x, z!& \ttm{z} 干扰 \ttm{w} 、\ttm{y} 和 \ttm{rsp},\\
\lstinline!addq w, z!& \ttm{z} 干扰 \ttm{y} 和 \ttm{rsp}, \\
\lstinline!movq y, t!& \ttm{t} 干扰 \ttm{z} 和 \ttm{rsp}, \\
\lstinline!negq t!& \ttm{t} 干扰 \ttm{z} 和 \ttm{rsp}, \\
\lstinline!movq z, %rax!   & \ttm{rax} 干扰 \ttm{t} 和 \ttm{rsp}, \\
\lstinline!addq t, %rax! & \ttm{rax} 干扰 \ttm{rsp}. \\
\lstinline!jmp conclusion!& 没有干扰。
\end{tabular}
\end{quote}
\caption{运行示例的干扰结果。}
\label{fig:interference-results}
\end{figure}


\begin{figure}[tbp]
\large
\[
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (rax) at (0,0) {$\ttm{rax}$};
\node (rsp) at (9,2) {$\ttm{rsp}$};
\node (t1) at (0,2) {$\ttm{t}$};
\node (z) at (3,2)  {$\ttm{z}$};
\node (x) at (6,2)  {$\ttm{x}$};
\node (y) at (3,0)  {$\ttm{y}$};
\node (w) at (6,0)  {$\ttm{w}$};
\node (v) at (9,0)  {$\ttm{v}$};


\draw (t1) to (rax);
\draw (t1) to (z);
\draw (z) to (y);
\draw (z) to (w);
\draw (x) to (w);
\draw (y) to (w);
\draw (v) to (w);

\draw (v) to (rsp);
\draw (w) to (rsp);
\draw (x) to (rsp);
\draw (y) to (rsp);
\path[-.,bend left=15] (z) edge node {} (rsp);
\path[-.,bend left=10] (t1) edge node {} (rsp);
\draw (rax) to (rsp);
\end{tikzpicture}
\]
\caption{示例程序的干涉图。}
\label{fig:interfere}
\end{figure}

%% Our next concern is to choose a data structure for representing the
%% interference graph. There are many choices for how to represent a
%% graph, for example, \emph{adjacency matrix}, \emph{adjacency list},
%% and \emph{edge set}~\citep{Cormen:2001uq}. The right way to choose a
%% data structure is to study the algorithm that uses the data structure,
%% determine what operations need to be performed, and then choose the
%% data structure that provide the most efficient implementations of
%% those operations. Often times the choice of data structure can have an
%% effect on the time complexity of the algorithm, as it does here. If
%% you skim the next section, you will see that the register allocation
%% algorithm needs to ask the graph for all of its vertices and, given a
%% vertex, it needs to known all of the adjacent vertices. Thus, the
%% correct choice of graph representation is that of an adjacency
%% list. There are helper functions in \code{utilities.rkt} for
%% representing graphs using the adjacency list representation:
%% \code{make-graph}, \code{add-edge}, and \code{adjacent}
%% (Appendix~\ref{appendix:utilities}).
%% %
%% \margincomment{\footnotesize To do: change to use the
%%     Racket graph library. \\ --Jeremy}
%% %
%% In particular, those functions use a hash table to map each vertex to
%% the set of adjacent vertices, and the sets are represented using
%% Racket's \key{set}, which is also a hash table.

\begin{exercise}\normalfont
根据上面建议的算法实现名为 \code{build-interference} 的编译器通道。建议使用 \code{graph}
包来创建和检查干涉图。这个通道的输出图应该存储在程序的 $\itm{info}$ 字段中，在 \code{conflicts} 键下。
\end{exercise}

  
\section{通过数独进行图形着色}
\label{sec:graph-coloring}
\index{graph coloring}
\index{Sudoku}
\index{color}

我们来看看主要事件，将变量映射到寄存器和堆栈位置。相互干扰的变量必须映射到不同的位置。就干涉图而言，这意味着相邻的顶点必须映射到不同的位置。如果把位置看作颜色，那么寄存器分配问题就变成图着色问题~\citep{Balakrishnan:1996ve,Rosen:2002bh} 。

读者可能比他或她意识到的更熟悉图形着色问题；流行的数独游戏就是图着色问题的一个例子。下面描述如何从最初的数独板构建一个图。
\begin{itemize}
\item 图中每个数独方格都有一个顶点。
\item 如果对应的正方形在同一行、同一列，或者正方形在相同的 $3\times 3$ 区域，则两个顶点之间存在一条边。
\item 选择九种颜色对应数字 $1$ 到 $9$ 。
\item 在数独棋盘上初始分配数字的基础上，给图中相应的顶点分配相应的颜色。
\end{itemize}
如果可以用这9种颜色给图中剩余的顶点上色，那么你也解决相应的数独游戏。
图~\ref{fig:sudoku-graph} 显示一个初始数独游戏板和相应的带有彩色顶点的图形。将数独数字1映射为蓝色，2映射为黄色，3映射为红色。只对采样的顶点(有颜色的顶点)显示边，因为显示所有顶点的边会使图形不可读。

\begin{figure}[tbp]
\includegraphics[width=0.45\textwidth]{figs/sudoku}
\includegraphics[width=0.5\textwidth]{figs/sudoku-graph}
\caption{一个数独游戏的棋盘和相应的彩色图表。}
\label{fig:sudoku-graph}
\end{figure}

结果表明，玩数独游戏的一些技术对应于图着色算法中使用的启发式。例如，数独游戏的一个基本技巧是铅笔标记。这个方法是用消元法来确定哪些数在方框中不存在，然后把这些数写在方框中(写得很小)。例如，如果数字 $1$ 被分配给一个正方形，那么在同一行、同列和同区域的所有正方形上用铅笔写上 $1$ 。
%
铅笔标记技术对应于由于 \cite{Brelaz:1979eu} 而产生的
\emph{饱和度}\index{saturation} 概念。顶点的饱和，用数独的术语来说，就是一组不再可用的数字。在图形术语中，有以下定义：
\begin{equation*}
  \mathrm{饱和度}(u) = \{ c \;|\; \exists v. v \in \mathrm{邻点}(u)
     \text{ 和 } \mathrm{颜色}(v) = c \}
\end{equation*}
其中 $\mathrm{邻点}(u)$ 是与 $u$ 共享一条边的顶点集合。

使用铅笔标记技术可以得到一个简单的数字填充策略:如果一个方格中只剩下一个可能的数字，那么就选择那个数字!但如果没有方格，只剩下一种可能呢?一种蛮力方法是尝试所有的方法:选择第一个，如果它最终能引出一个解决方案，那很好。如果没有，就回头选择下一个可能性。铅笔标记的一个优点是它减少搜索树的分支程度。然而，回溯可能非常耗时。减少回溯数量的一种方法是使用最受约束优先启发式。也就是说，当选择一个方块时，总是选择一个剩余可能性最小的(饱和度最高的顶点)。这个想法是，尽早选择高约束的方块，因为较低约束在高度饱和的方块中可能没有任何剩余的可能性。

然而，寄存器分配比数独更容易，因为寄存器分配器可以在寄存器耗尽时将变量映射到堆栈位置。因此，用贪婪搜索取代回溯是有意义的：在当做出最佳选择并继续前进。仍然希望最小化所需的颜色数量，因此在贪婪搜索中使用最受约束优先启发式。
图~\ref{fig:satur-algo} 给出基于饱和和最受约束优先启发式的寄存器分配的简单贪婪算法的伪代码。它大致相当于 DSATUR
算法~\citep{Brelaz:1979eu,Gebremedhin:1999fk,Omari:2006uq} 。就像在数独游戏中一样，这个算法用整数表示颜色。从 $0$ 到 $k-1$ 的整数对应于寄存器分配的 $k$ 个寄存器。整数 $k$ 及以上对应的是堆栈位置。不用于寄存器分配的寄存器(如 \code{rax} ）被分配给负整数。特别地，把 $-1$ 赋给 \code{rax} ，把 $-2$ 赋给 \code{rsp} 。

%% One might wonder why we include registers at all in the liveness
%% analysis and interference graph. For example, we never allocate a
%% variable to \code{rax} and \code{rsp}, so it would be harmless to
%% leave them out.  As we see in Chapter~\ref{ch:Rvec}, when we begin
%% to use register for passing arguments to functions, it will be
%% necessary for those registers to appear in the interference graph
%% because those registers will also be assigned to variables, and we
%% don't want those two uses to encroach on each other. Regarding
%% registers such as \code{rax} and \code{rsp} that are not used for
%% variables, we could omit them from the interference graph but that
%% would require adding special cases to our algorithm, which would
%% complicate the logic for little gain.


\begin{figure}[btp]
  \centering
\begin{lstlisting}[basicstyle=\rmfamily,deletekeywords={for,from,with,is,not,in,find},morekeywords={while},columns=fullflexible]
算法： DSATUR
输入： 图 |$G$|
输出：每个顶点 |$v \in G$| 的赋值 |$\mathrm{颜色}[v]$| 

|$W \gets \mathrm{顶点}(G)$|
while |$W \neq \emptyset$| do
    从 |$W$| 中选择一个饱和度最高的顶点 |$u$| ，随机打破束缚
    找到不属于 |$\{ \mathrm{颜色}[v] \;:\; v \in \mathrm{邻点}(u)\}$| 的最低颜色 |$c$| 
    |$\mathrm{颜色}[u] \gets c$|
    |$W \gets W - \{u\}$|
\end{lstlisting}
  \caption{基于饱和的贪心图着色算法。}
  \label{fig:satur-algo}
\end{figure}

有了 DSATUR 算法之后，回到正在运行的示例，考虑如何给图~\ref{fig:interfere} 中的干涉图上色。
%
首先将寄存器节点分配给它们自己的颜色。例如， \code{rax} 被赋予颜色 $-1$ ， \code{rsp} 被赋予颜色 $-2$ 。这些变量还没有着色，所以用破折号对它们进行注释。然后更新与寄存器相邻的顶点的饱和度，得到以下注释图。例如， \code{t} 的饱和度是 $\{-1,-2\}$ ，因为它干扰 \code{rax} 和 \code{rsp} 。
\[
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (rax) at (0,0) {$\ttm{rax}:-1,\{-2\}$};
\node (rsp) at (10,2) {$\ttm{rsp}:-2,\{-1\}$};
\node (t1) at (0,2) {$\ttm{t}:-,\{-1,-2\}$};
\node (z) at (3,2)  {$\ttm{z}:-,\{-2\}$};
\node (x) at (6,2)  {$\ttm{x}:-,\{-2\}$};
\node (y) at (3,0)  {$\ttm{y}:-,\{-2\}$};
\node (w) at (6,0)  {$\ttm{w}:-,\{-2\}$};
\node (v) at (10,0)  {$\ttm{v}:-,\{-2\}$};

\draw (t1) to (rax);
\draw (t1) to (z);
\draw (z) to (y);
\draw (z) to (w);
\draw (x) to (w);
\draw (y) to (w);
\draw (v) to (w);

\draw (v) to (rsp);
\draw (w) to (rsp);
\draw (x) to (rsp);
\draw (y) to (rsp);
\path[-.,bend left=15] (z) edge node {} (rsp);
\path[-.,bend left=10] (t1) edge node {} (rsp);
\draw (rax) to (rsp);
\end{tikzpicture}
\]
算法要求选择一个最大饱和顶点。我们取
$\ttm{t}$ ，用第一个整数，也就是
$0$ ，给它上色。我们标记： $0$ 不再适用于 $\ttm{z}$ 、$\ttm{rax}$
和 \ttm{rsp} ，因为它们与 $\ttm{t}$ 相干扰。
\[
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (rax) at (0,0) {$\ttm{rax}:-1,\{0,-2\}$};
\node (rsp) at (10,2) {$\ttm{rsp}:-2,\{-1,0\}$};
\node (t1) at (0,2) {$\ttm{t}:0,\{-1,-2\}$};
\node (z) at (3,2)  {$\ttm{z}:-,\{0,-2\}$};
\node (x) at (6,2)  {$\ttm{x}:-,\{-2\}$};
\node (y) at (3,0)  {$\ttm{y}:-,\{-2\}$};
\node (w) at (6,0)  {$\ttm{w}:-,\{-2\}$};
\node (v) at (10,0)  {$\ttm{v}:-,\{-2\}$};

\draw (t1) to (rax);
\draw (t1) to (z);
\draw (z) to (y);
\draw (z) to (w);
\draw (x) to (w);
\draw (y) to (w);
\draw (v) to (w);

\draw (v) to (rsp);
\draw (w) to (rsp);
\draw (x) to (rsp);
\draw (y) to (rsp);
\path[-.,bend left=15] (z) edge node {} (rsp);
\path[-.,bend left=10] (t1) edge node {} (rsp);
\draw (rax) to (rsp);
\end{tikzpicture}
\]
重复这个过程，选择下一个最大饱和顶点，也就是 \code{z} ，然后用第一个可用的数字，也就是 $1$ 给它上色。给相邻的顶点\code{t} 、\code{y} 、\code{w} 和 \code{rsp} 的饱和度加 $1$ 。
\[
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (rax) at (0,0) {$\ttm{rax}:-1,\{0,-2\}$};
\node (rsp) at (10,2) {$\ttm{rsp}:-2,\{-1,0,1\}$};
\node (t1) at (0,2) {$\ttm{t}:0,\{-1,1,-2\}$};
\node (z) at (3,2)  {$\ttm{z}:1,\{0,-2\}$};
\node (x) at (6,2)  {$\ttm{x}:-,\{-2\}$};
\node (y) at (3,0)  {$\ttm{y}:-,\{1,-2\}$};
\node (w) at (6,0)  {$\ttm{w}:-,\{1,-2\}$};
\node (v) at (10,0)  {$\ttm{v}:-,\{-2\}$};

\draw (t1) to (rax);
\draw (t1) to (z);
\draw (z) to (y);
\draw (z) to (w);
\draw (x) to (w);
\draw (y) to (w);
\draw (v) to (w);

\draw (v) to (rsp);
\draw (w) to (rsp);
\draw (x) to (rsp);
\draw (y) to (rsp);
\path[-.,bend left=15] (z) edge node {} (rsp);
\path[-.,bend left=10] (t1) edge node {} (rsp);
\draw (rax) to (rsp);
\end{tikzpicture}
\]
现在最饱和的顶点是 \code{w} 和 \code{y} 。用第一个可用的颜色为
\code{w} 上色，即 $0$ 。
\[
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (rax) at (0,0) {$\ttm{rax}:-1,\{0,-2\}$};
\node (rsp) at (10,2) {$\ttm{rsp}:-2,\{-1,0,1\}$};
\node (t1) at (0,2) {$\ttm{t}:0,\{-1,1,-2\}$};
\node (z) at (3,2)  {$\ttm{z}:1,\{0,-2\}$};
\node (x) at (6,2)  {$\ttm{x}:-,\{0,-2\}$};
\node (y) at (3,0)  {$\ttm{y}:-,\{0,1,-2\}$};
\node (w) at (6,0)  {$\ttm{w}:0,\{1,-2\}$};
\node (v) at (10,0)  {$\ttm{v}:-,\{0,-2\}$};

\draw (t1) to (rax);
\draw (t1) to (z);
\draw (z) to (y);
\draw (z) to (w);
\draw (x) to (w);
\draw (y) to (w);
\draw (v) to (w);

\draw (v) to (rsp);
\draw (w) to (rsp);
\draw (x) to (rsp);
\draw (y) to (rsp);
\path[-.,bend left=15] (z) edge node {} (rsp);
\path[-.,bend left=10] (t1) edge node {} (rsp);
\draw (rax) to (rsp);
\end{tikzpicture}
\]
现在顶点 \code{y} 是最饱和的，所以用 \code{y}
给 $2$ 上色。不能选择 $0$ 或 $1$ ，因为这些数字在
\code{y} 的饱和集合中。实际上， \code{y} 会干扰 \code{w}
和 \code{z} ，它们的颜色分别为 $0$ 和 $1$ 。
\[
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (rax) at (0,0) {$\ttm{rax}:-1,\{0,-2\}$};
\node (rsp) at (10,2) {$\ttm{rsp}:-2,\{-1,0,1,2\}$};
\node (t1) at (0,2) {$\ttm{t}:0,\{-1,1,-2\}$};
\node (z) at (3,2)  {$\ttm{z}:1,\{0,2,-2\}$};
\node (x) at (6,2)  {$\ttm{x}:-,\{0,-2\}$};
\node (y) at (3,0)  {$\ttm{y}:2,\{0,1,-2\}$};
\node (w) at (6,0)  {$\ttm{w}:0,\{1,2,-2\}$};
\node (v) at (10,0)  {$\ttm{v}:-,\{0,-2\}$};

\draw (t1) to (rax);
\draw (t1) to (z);
\draw (z) to (y);
\draw (z) to (w);
\draw (x) to (w);
\draw (y) to (w);
\draw (v) to (w);

\draw (v) to (rsp);
\draw (w) to (rsp);
\draw (x) to (rsp);
\draw (y) to (rsp);
\path[-.,bend left=15] (z) edge node {} (rsp);
\path[-.,bend left=10] (t1) edge node {} (rsp);
\draw (rax) to (rsp);
\end{tikzpicture}
\]
现在 \code{x} 和 \code{v} 是最饱和的，所以 \code{v} 的颜色是 $1$ 。
\[
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (rax) at (0,0) {$\ttm{rax}:-1,\{0,-2\}$};
\node (rsp) at (10,2) {$\ttm{rsp}:-2,\{-1,0,1,2\}$};
\node (t1) at (0,2) {$\ttm{t}:0,\{-1,1,-2\}$};
\node (z) at (3,2)  {$\ttm{z}:1,\{0,2,-2\}$};
\node (x) at (6,2)  {$\ttm{x}:-,\{0,-2\}$};
\node (y) at (3,0)  {$\ttm{y}:2,\{0,1,-2\}$};
\node (w) at (6,0)  {$\ttm{w}:0,\{1,2,-2\}$};
\node (v) at (10,0)  {$\ttm{v}:1,\{0,-2\}$};

\draw (t1) to (rax);
\draw (t1) to (z);
\draw (z) to (y);
\draw (z) to (w);
\draw (x) to (w);
\draw (y) to (w);
\draw (v) to (w);

\draw (v) to (rsp);
\draw (w) to (rsp);
\draw (x) to (rsp);
\draw (y) to (rsp);
\path[-.,bend left=15] (z) edge node {} (rsp);
\path[-.,bend left=10] (t1) edge node {} (rsp);
\draw (rax) to (rsp);
\end{tikzpicture}
\]
在算法的最后一步，用 $1$ 给 \code{x} 上色。
\[
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (rax) at (0,0) {$\ttm{rax}:-1,\{0,-2\}$};
\node (rsp) at (10,2) {$\ttm{rsp}:-2,\{-1,0,1,2\}$};
\node (t1) at (0,2) {$\ttm{t}:0,\{-1,1,-2\}$};
\node (z) at (3,2)  {$\ttm{z}:1,\{0,2,-2\}$};
\node (x) at (6,2)  {$\ttm{x}:1,\{0,-2\}$};
\node (y) at (3,0)  {$\ttm{y}:2,\{0,1,-2\}$};
\node (w) at (6,0)  {$\ttm{w}:0,\{1,2,-2\}$};
\node (v) at (10,0)  {$\ttm{v}:1,\{0,-2\}$};

\draw (t1) to (rax);
\draw (t1) to (z);
\draw (z) to (y);
\draw (z) to (w);
\draw (x) to (w);
\draw (y) to (w);
\draw (v) to (w);

\draw (v) to (rsp);
\draw (w) to (rsp);
\draw (x) to (rsp);
\draw (y) to (rsp);
\path[-.,bend left=15] (z) edge node {} (rsp);
\path[-.,bend left=10] (t1) edge node {} (rsp);
\draw (rax) to (rsp);
\end{tikzpicture}
\]

\begin{wrapfigure}[20]{r}[1.0in]{0.6\textwidth}
  \small
  \begin{tcolorbox}[title=优先排队]
    \emph{优先排队} 是项的集合，其中项的移除由优先级控制。在“min”队列中，首先删除优先级较低的项。一个实现在支持代码
    \code{priority\_queue.rkt} 中。  \index{priority
      queue} \index{minimum priority queue}
  \begin{description}
  \item[$\LP\code{make-pqueue}\,\itm{cmp}\RP$] 构造一个空优先级队列，该队列使用 $\itm{cmp}$ 谓词来确定其第一个参数的优先级是否低于或等于其第二个参数。
  \item[$\LP\code{pqueue-count}\,\itm{queue}\RP$] 返回队列中的项数。
  \item[$\LP\code{pqueue-push!}\,\itm{queue}\,\itm{item}\RP$] 将项插入队列中并返回队列中项的句柄。
  \item[$\LP\code{pqueue-pop!}\,\itm{queue}\RP$] 返回具有最低优先级的项。
  \item[$\LP\code{pqueue-decrease-key!}\,\itm{queue}\,\itm{handle}\RP$]
    通知队列与给定句柄关联的项的优先级已降低。
  \end{description}
\end{tcolorbox}
\end{wrapfigure}

建议创建一个名为 \code{color-graph}
的辅助函数，它接受一个干涉图和程序中所有变量的列表。这个函数应该返回变量与其颜色(用自然数表示)的映射。通过创建这个辅助函数，在第~\ref{ch:Rfun}
章中添加对函数的支持时重用它。

为了优先处理
\code{color-graph}函数中高度饱和的节点，建议使用优先队列数据结构(参见右边的边栏)。此外，还需要在优先队列中维护一个从变量到它们的“句柄”的映射，这样当它们的饱和度发生变化时，您就可以通知优先队列。

着色完成后，就完成对寄存器和堆栈位置变量的赋值。将前 $k$ 种颜色映射到 $k$
个寄存器，其余的颜色映射到堆栈位置。假设现在只有一个用于寄存器分配的寄存器 \key{rcx} 。然后有以下从颜色到位置的地图。
\[
  \{ 0 \mapsto \key{\%rcx}, \; 1 \mapsto \key{-8(\%rbp)}, \; 2 \mapsto \key{-16(\%rbp)} \}
\]
将这个映射与着色组合在一起，得到以下将变量赋值到位置的方法。
\begin{gather*}
  \{ \ttm{v} \mapsto \key{-8(\%rbp)}, \,
     \ttm{w} \mapsto \key{\%rcx},  \,
     \ttm{x} \mapsto \key{-8(\%rbp)}, \,
     \ttm{y} \mapsto \key{-16(\%rbp)}, \\
     \ttm{z} \mapsto \key{-8(\%rbp)}, \,
     \ttm{t} \mapsto \key{\%rcx} \}
\end{gather*}

改写 \code{assign-homes} 通道的的代码(~\ref{sec:assign-Rvar} 节) ，用它们所分配的位置替换变量。将上面的赋值应用到左边正在运行的示例中，将生成右边的程序。
% why frame size of 32? -JGS
\begin{center}
  \begin{minipage}{0.3\textwidth}
\begin{lstlisting}
movq $1, v
movq $42, w
movq v, x
addq $7, x
movq x, y
movq x, z
addq w, z
movq y, t
negq t
movq z, %rax
addq t, %rax
jmp conclusion
\end{lstlisting}
\end{minipage}
$\Rightarrow\qquad$
\begin{minipage}{0.45\textwidth}
\begin{lstlisting}
movq $1, -8(%rbp)
movq $42, %rcx
movq -8(%rbp), -8(%rbp)
addq $7, -8(%rbp)
movq -8(%rbp), -16(%rbp)
movq -8(%rbp), -8(%rbp)
addq %rcx, -8(%rbp)
movq -16(%rbp), %rcx
negq %rcx
movq -8(%rbp), %rax
addq %rcx, %rax
jmp conclusion
\end{lstlisting}
\end{minipage}
\end{center}

\begin{exercise}\normalfont
%
实现编译器通道 \code{allocate-registers} 。
%
创建五个程序来执行所有的寄存器分配算法，包括将变量溢出到堆栈。
%
将\code{run-tests.rkt} 脚本中 \code{passes} 列表中 \code{assign-homes} 替换为三个新的通道：
\code{uncover-live} 、\code{build-interference} 和
\code{allocate-registers} 。
%
暂时从通道列表中删除 \code{print-x86} 通道和对 \code{compiler-tests} 的调用。
%
运行脚本来测试寄存器分配器。
\end{exercise}


\section{补丁说明}
\label{sec:patch-instructions}

编译到x86的剩余步骤是确保指令最多有一个参数，即内存访问。
在运行的示例中， \code{movq -8(\%rbp), -16(\%rbp)}
指令有问题。修正是先将 \code{-8(\%rbp)}
移动到 \code{rax} ，然后将 \code{rax} 移动到 \code{-16(\%rbp)} 。
%
从 \code{-8(\%rbp)} 到 \code{-8(\%rbp)} 的两次移动也有问题，但可以通过简单地删除它们来修复。一般来说，建议删除所有源和目标位置相同的琐碎移动。
%
下面是运行示例的 \code{patch-instructions} 的输出。
\begin{center}
  \begin{minipage}{0.4\textwidth}
\begin{lstlisting}
movq $1, -8(%rbp)
movq $42, %rcx
movq -8(%rbp), -8(%rbp)
addq $7, -8(%rbp)
movq -8(%rbp), -16(%rbp)
movq -8(%rbp), -8(%rbp)
addq %rcx, -8(%rbp)
movq -16(%rbp), %rcx
negq %rcx
movq -8(%rbp), %rax
addq %rcx, %rax
jmp conclusion
\end{lstlisting}
\end{minipage}
$\Rightarrow\qquad$
\begin{minipage}{0.45\textwidth}
\begin{lstlisting}
movq $1, -8(%rbp)
movq $42, %rcx
addq $7, -8(%rbp)
movq -8(%rbp), %rax
movq %rax, -16(%rbp)
addq %rcx, -8(%rbp)
movq -16(%rbp), %rcx
negq %rcx
movq -8(%rbp), %rax
addq %rcx, %rax
jmp conclusion
\end{lstlisting}
\end{minipage}
\end{center}
  
\begin{exercise}\normalfont
%
实现 \code{patch-instructions} 编译器通道。
%
将其插入 \code{run-tests.rkt} 脚本中的 \code{passes} 列表中的 \code{allocate-registers} 之后。
%
运行脚本来测试 \code{patch-instructions} 是否通过。
\end{exercise}


\section{打印 x86}
\label{sec:print-x86-reg-alloc}
\index{calling conventions}
\index{prelude}\index{conclusion}

回想一下， \code{print-x86} 通道生成的前奏和结论指令满足x86调用约定(第~\ref{sec:calling-conventions} 节)。随着寄存器分配器的增加，寄存器分配器使用的被调用保存寄存器必须保存在前奏中，并在结论中恢复。
在 \code{allocate-registers} 通道中，将一个条目添加到名为 \code{used-callee} 的
 \code{X86Program} 的 \itm{info} 中，该条目存储分配给变量的被调用者保存的寄存器集。然后
\code{print-x86} 通道可以访问此信息，以决定需要保存和恢复哪些被调用保存的寄存器。
%
在前奏中计算调整 \code{rsp} 的帧的大小时，确保考虑到用于保存被调用保存寄存器的空间。另外，不要忘记帧必须是16字节的倍数!

图~\ref{fig:reg-alloc-passes} 显示所有涉及到寄存器分配的通道的概览。

\begin{figure}[tbp]
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (Rvar) at (0,2)  {\large \LangVar{}};
\node (Rvar-2) at (3,2)  {\large \LangVar{}};
\node (Rvar-3) at (6,2)  {\large \LangVar{}};
\node (Cvar-1) at (3,0)  {\large \LangCVar{}};

\node (x86-2) at (3,-2)  {\large \LangXVar{}};
\node (x86-3) at (6,-2)  {\large \LangXVar{}};
\node (x86-4) at (9,-2) {\large \LangXInt{}};
\node (x86-5) at (9,-4) {\large \LangXInt{}};

\node (x86-2-1) at (3,-4)  {\large \LangXVar{}};
\node (x86-2-2) at (6,-4)  {\large \LangXVar{}};

\path[->,bend left=15] (Rvar) edge [above] node {\ttfamily\footnotesize uniquify} (Rvar-2);
\path[->,bend left=15] (Rvar-2) edge [above] node {\ttfamily\footnotesize remove-complex.} (Rvar-3);
\path[->,bend left=15] (Rvar-3) edge [right] node {\ttfamily\footnotesize explicate-control} (Cvar-1);
\path[->,bend right=15] (Cvar-1) edge [left] node {\ttfamily\footnotesize select-instr.} (x86-2);
\path[->,bend left=15] (x86-2) edge [right] node {\ttfamily\footnotesize uncover-live} (x86-2-1);
\path[->,bend right=15] (x86-2-1) edge [below] node {\ttfamily\footnotesize build-inter.} (x86-2-2);
\path[->,bend right=15] (x86-2-2) edge [right] node {\ttfamily\footnotesize allocate-reg.} (x86-3);
\path[->,bend left=15] (x86-3) edge [above] node {\ttfamily\footnotesize patch-instr.} (x86-4);
\path[->,bend left=15] (x86-4) edge [right] node {\ttfamily\footnotesize print-x86} (x86-5);
\end{tikzpicture}
\caption{带寄存器分配的 \LangVar{} 通道图。}
\label{fig:reg-alloc-passes}
\end{figure}

\begin{exercise}\normalfont
按照本节的描述更新 \code{print-x86} 通道。
%
在 \code{run-tests.rkt} 脚本中，恢复通道列表中的 \code{print-x86} 和对 \code{compiler-tests} 的调用。
%
运行脚本来测试执行寄存器分配的 \LangVar{} 的完整编译器。
\end{exercise}

\section{挑战：移动偏压}
\label{sec:move-biasing}
\index{move biasing}

本节描述对注册表分配器的改进，供那些寻求额外挑战或对注册表分配有更深兴趣的学生使用。

为了激发对移动偏置的需求，我们回到运行的例子，但这次使用所有通用寄存器。所以我们有以下颜色数字到寄存器的映射。
\[
  \{ 0 \mapsto \key{\%rcx}, \; 1 \mapsto \key{\%rdx}, \; 2 \mapsto \key{\%rsi} \}
\]
使用上一节中描述的寄存器分配器生成的相同的对颜色数字的变量赋值，得到以下程序。
\begin{center}
\begin{minipage}{0.3\textwidth}
\begin{lstlisting}
movq $1, v
movq $42, w
movq v, x
addq $7, x
movq x, y
movq x, z
addq w, z
movq y, t
negq t
movq z, %rax
addq t, %rax
jmp conclusion
\end{lstlisting}
\end{minipage}
$\Rightarrow\qquad$
\begin{minipage}{0.45\textwidth}
\begin{lstlisting}
movq $1, %rdx
movq $42, %rcx
movq %rdx, %rdx
addq $7, %rdx
movq %rdx, %rsi
movq %rdx, %rdx
addq %rcx, %rdx
movq %rsi, %rcx
negq %rcx
movq %rdx, %rax
addq %rcx, %rax
jmp conclusion
\end{lstlisting}
\end{minipage}
\end{center}
在上面的输出代码中，有两个 \key{movq} 指令可以删除，因为它们的源和目标是相同的。但是，如果将 \key{t} 、\key{v} 、\key{x} 和 \key{y} 放入同一个寄存器中，则可以删除三 \key{movq} 指令。可以通过考虑哪些变量和哪些其他变量出现在
\key{movq} 指令中来实现这一点。

我们说，如果两个变量 $p$ 和 $q$ 一起参与
\key{movq} 指令，即 \key{movq} $p$\key{,} $q$ 或
\key{movq} $q$\key{,} $p$ ，则它们是 \emph{移动相关}\index{move related} 。当寄存器分配器为一个变量选择颜色时，它应该选择一个已经为一个与移动相关的变量使用过的颜色(假设它们不会干扰)。当然，这个首选项不应该覆盖寄存器优先于堆栈位置的首选项。当在寄存器之间进行选择或在堆栈位置之间进行选择时，他的偏好应该被用作平局打破者。

建议用图形表示移动关系，就像表示干涉一样。下面是运行示例的 \emph{移动图} 。
\[
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (rax) at (0,0) {$\ttm{rax}$};
\node (rsp) at (9,2) {$\ttm{rsp}$};
\node (t) at (0,2) {$\ttm{t}$};
\node (z) at (3,2)  {$\ttm{z}$};
\node (x) at (6,2)  {$\ttm{x}$};
\node (y) at (3,0)  {$\ttm{y}$};
\node (w) at (6,0)  {$\ttm{w}$};
\node (v) at (9,0)  {$\ttm{v}$};

\draw (v) to (x);
\draw (x) to (y);
\draw (x) to (z);
\draw (y) to (t);
\end{tikzpicture}
\]

现在回放图形着色，暂停看
\code{y} 的着色。回想一下下面的配置。饱和的顶点是 \code{w} 和 \code{y} 。
\[
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (rax) at (0,0) {$\ttm{rax}:-1,\{0,-2\}$};
\node (rsp) at (9,2) {$\ttm{rsp}:-2,\{-1,0,1,2\}$};
\node (t1) at (0,2) {$\ttm{t}:0,\{1,-2\}$};
\node (z) at (3,2)  {$\ttm{z}:1,\{0,-2\}$};
\node (x) at (6,2)  {$\ttm{x}:-,\{-2\}$};
\node (y) at (3,0)  {$\ttm{y}:-,\{1,-2\}$};
\node (w) at (6,0)  {$\ttm{w}:-,\{1,-2\}$};
\node (v) at (9,0)  {$\ttm{v}:-,\{-2\}$};

\draw (t1) to (rax);
\draw (t1) to (z);
\draw (z) to (y);
\draw (z) to (w);
\draw (x) to (w);
\draw (y) to (w);
\draw (v) to (w);

\draw (v) to (rsp);
\draw (w) to (rsp);
\draw (x) to (rsp);
\draw (y) to (rsp);
\path[-.,bend left=15] (z) edge node {} (rsp);
\path[-.,bend left=10] (t1) edge node {} (rsp);
\draw (rax) to (rsp);
\end{tikzpicture}
\]
%
上次用 $0$ 给 \code{w}色。但是这次看到， \code{w} 和任何顶点都没有关系，但是 \code{y} 和 \code{t} 有关系。所以用和 \code{t}, $0$ 一样的颜色来表示 \code{y} 。
\[
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (rax) at (0,0) {$\ttm{rax}:-1,\{0,-2\}$};
\node (rsp) at (9,2) {$\ttm{rsp}:-2,\{-1,0,1,2\}$};
\node (t1) at (0,2) {$\ttm{t}:0,\{1,-2\}$};
\node (z) at (3,2)  {$\ttm{z}:1,\{0,-2\}$};
\node (x) at (6,2)  {$\ttm{x}:-,\{-2\}$};
\node (y) at (3,0)  {$\ttm{y}:0,\{1,-2\}$};
\node (w) at (6,0)  {$\ttm{w}:-,\{0,1,-2\}$};
\node (v) at (9,0)  {$\ttm{v}:-,\{-2\}$};

\draw (t1) to (rax);
\draw (t1) to (z);
\draw (z) to (y);
\draw (z) to (w);
\draw (x) to (w);
\draw (y) to (w);
\draw (v) to (w);

\draw (v) to (rsp);
\draw (w) to (rsp);
\draw (x) to (rsp);
\draw (y) to (rsp);
\path[-.,bend left=15] (z) edge node {} (rsp);
\path[-.,bend left=10] (t1) edge node {} (rsp);
\draw (rax) to (rsp);
\end{tikzpicture}
\]
现在 \code{w} 是最饱和的，所以把它涂成 $2$ 。
\[
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (rax) at (0,0) {$\ttm{rax}:-1,\{0,-2\}$};
\node (rsp) at (9,2) {$\ttm{rsp}:-2,\{-1,0,1,2\}$};
\node (t1) at (0,2) {$\ttm{t}:0,\{1,-2\}$};
\node (z) at (3,2)  {$\ttm{z}:1,\{0,2,-2\}$};
\node (x) at (6,2)  {$\ttm{x}:-,\{2,-2\}$};
\node (y) at (3,0)  {$\ttm{y}:0,\{1,2,-2\}$};
\node (w) at (6,0)  {$\ttm{w}:2,\{0,1,-2\}$};
\node (v) at (9,0)  {$\ttm{v}:-,\{2,-2\}$};

\draw (t1) to (rax);
\draw (t1) to (z);
\draw (z) to (y);
\draw (z) to (w);
\draw (x) to (w);
\draw (y) to (w);
\draw (v) to (w);

\draw (v) to (rsp);
\draw (w) to (rsp);
\draw (x) to (rsp);
\draw (y) to (rsp);
\path[-.,bend left=15] (z) edge node {} (rsp);
\path[-.,bend left=10] (t1) edge node {} (rsp);
\draw (rax) to (rsp);
\end{tikzpicture}
\]
在这一点上，顶点 \code{x} 和 \code{v} 是最饱和的，但是
\code{x} 是与 \code{y} 和 \code{z} 相关的，所以给
\code{x} 上色为 $0$ 来匹配 \code{y} 。最后，把 \code{v} 涂成 $0$ 。
\[
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (rax) at (0,0) {$\ttm{rax}:-1,\{0,-2\}$};
\node (rsp) at (9,2) {$\ttm{rsp}:-2,\{-1,0,1,2\}$};
\node (t) at (0,2) {$\ttm{t}:0,\{1,-2\}$};
\node (z) at (3,2)  {$\ttm{z}:1,\{0,2,-2\}$};
\node (x) at (6,2)  {$\ttm{x}:0,\{2,-2\}$};
\node (y) at (3,0)  {$\ttm{y}:0,\{1,2,-2\}$};
\node (w) at (6,0)  {$\ttm{w}:2,\{0,1,-2\}$};
\node (v) at (9,0)  {$\ttm{v}:0,\{2,-2\}$};

\draw (t1) to (rax);
\draw (t) to (z);
\draw (z) to (y);
\draw (z) to (w);
\draw (x) to (w);
\draw (y) to (w);
\draw (v) to (w);

\draw (v) to (rsp);
\draw (w) to (rsp);
\draw (x) to (rsp);
\draw (y) to (rsp);
\path[-.,bend left=15] (z) edge node {} (rsp);
\path[-.,bend left=10] (t1) edge node {} (rsp);
\draw (rax) to (rsp);
\end{tikzpicture}
\]

对寄存器进行如下的变量赋值。
\begin{gather*}
  \{ \ttm{v} \mapsto \key{\%rcx}, \,
     \ttm{w} \mapsto \key{\%rsi}, \,
     \ttm{x} \mapsto \key{\%rcx}, \,
     \ttm{y} \mapsto \key{\%rcx}, \,
     \ttm{z} \mapsto \key{\%rdx}, \,
     \ttm{t} \mapsto \key{\%rcx} \}
\end{gather*}

将这个寄存器赋值应用到左边正在运行的示例，以获得中间的代码。然后， \code{patch-instructions} 删除三个简单的步骤，以获得右边的代码。

\begin{minipage}{0.25\textwidth}
\begin{lstlisting}
movq $1, v
movq $42, w
movq v, x
addq $7, x
movq x, y
movq x, z
addq w, z
movq y, t
negq t
movq z, %rax
addq t, %rax
jmp conclusion
\end{lstlisting}
\end{minipage}
$\Rightarrow\qquad$
\begin{minipage}{0.25\textwidth}
\begin{lstlisting}
movq $1, %rcx
movq $42, %rsi
movq %rcx, %rcx
addq $7, %rcx
movq %rcx, %rcx
movq %rcx, %rdx
addq %rsi, %rdx
movq %rcx, %rcx
negq %rcx
movq %rdx, %rax
addq %rcx, %rax
jmp conclusion
\end{lstlisting}
\end{minipage}
$\Rightarrow\qquad$
\begin{minipage}{0.25\textwidth}
\begin{lstlisting}
movq $1, %rcx
movq $42, %rsi
addq $7, %rcx
movq %rcx, %rdx
addq %rsi, %rdx
negq %rcx
movq %rdx, %rax
addq %rcx, %rax
jmp conclusion
\end{lstlisting}
\end{minipage}

\begin{exercise}\normalfont
改变你的 \code{allocate-registers} 的实现来考虑移动偏置。创建两个新的测试，其中至少包含一个移动偏置的机会，并直观地检查输出的x86程序，以确保你的移动偏置工作正常。确保编译器仍然通过所有测试。
\end{exercise}

\margincomment{\footnotesize To do: another neat challenge would be to do
  live range splitting~\citep{Cooper:1998ly}. \\ --Jeremy}

%% \subsection{Output of the Running Example}
%% \label{sec:reg-alloc-output}

图~\ref{fig:running-example-x86} 显示为运行示例(图~\ref{fig:reg-eg}) 生成的带有寄存器分配和移动偏置的x86代码。为了演示寄存器和堆栈的使用，将寄存器分配器限制为仅使用两个寄存器： \code{rbx} 和 \code{rcx} 。在\index{prelude}
 \code{main} 函数的前奏中，将 \code{rbx} 压入堆栈，因为它是一个被调用保存的寄存器，并且它被寄存器分配器分配给变量。在前奏的最后从 \code{rsp} 中减去 \code{8} ，为溢出的变量保留空间。
在这个减法之后， \code{rsp} 对齐到16字节。

移到 \code{start} 块，看到寄存器是如何分配的。变量 \code{v} 、\code{x} 和 \code{y} 被赋给
\code{rbx} ，变量 \code{z} 被赋给 \code{rcx} 。变量
\code{w} 溢出到堆栈位置 \code{-16(\%rbp)} 。回想一下前奏曲将被调用保存寄存器 \code{rbx} 保存到堆栈中。溢出的变量必须放置在堆栈上低于保存的被调用者保存寄存器的位置，因此在这种情况下 \code{w} 被放置在
\code{-16(\%rbp)} 。

在 \code{conclusion}\index{conclusion} 中，撤销在前奏中所做的工作。将堆栈指针向上移动 \code{8} 个字节(用于溢出变量的空间)，然后弹出
\code{rbx} 和 \code{rbp} (被调用者保存的寄存器)的旧值，并以
\code{retq} 结束，将控制权交还给操作系统。

  
\begin{figure}[tbp]
  % var_test_28.rkt
  % (use-minimal-set-of-registers! #t)
  % and only rbx rcx
% tmp 0 rbx
% z 1  rcx
% y 0  rbx
% w 2  16(%rbp)
% v 0  rbx
% x 0  rbx
\begin{lstlisting}
start:
	movq	$1, %rbx
	movq	$42, -16(%rbp)
	addq	$7, %rbx
	movq	%rbx, %rcx
	addq	-16(%rbp), %rcx
	negq	%rbx
	movq	%rcx, %rax
	addq	%rbx, %rax
	jmp conclusion

	.globl main
main:
	pushq	%rbp
	movq	%rsp, %rbp
	pushq	%rbx
	subq	$8, %rsp
	jmp start
        
conclusion:
	addq	$8, %rsp
	popq	%rbx
	popq	%rbp
	retq
\end{lstlisting}
\caption{运行示例中的x86输出 (图~\ref{fig:reg-eg})。}
\label{fig:running-example-x86}
\end{figure}

% challenge: prioritize variables based on execution frequencies
%   and the number of uses of a variable

% challenge: enhance the coloring algorithm using Chaitin's
%  approach of prioritizing high-degree variables
%  by removing low-degree variables (coloring them later)
%  from the interference graph


\section{延伸阅读}
\label{sec:register-allocation-further-reading}

早期的寄存器分配算法是在20世纪50年代为Fortran编译器开发的~\citep{Horwitz:1966aa,Backus:1978aa} 。图着色的使用始于20世纪70年代末和80年代初，当时 \citet{Chaitin:1981vl} 在PL/I的优化编译器上工作。该算法基于19世纪70年代对
\citet{Kempe:1879aa} 的观察。如果一个图 $G$ 有一个顶点 $v$
的度小于 $k$ ，那么 $G$ 是 $k$ 可着色的，如果 $G$ 去掉 $v$ 的子图也是 $k$ 可着色的。假设子图 $k$ 是可着色的。在最坏的情况下， $v$ 的邻居被分配不同的颜色，但是因为它们的数量少于 $k$ ，所以 $G$ 中会剩下一种或更多的颜色来给 $v$ 。

 \citet{Chaitin:1981vl} 的算法从图中移除度小于 $k$ 的顶点 $v$ ，并递归地为图的其余部分着色。当从递归返回时，它用一个可用的颜色给 $v$ 上色并返回。 \citet{Chaitin:1982vn} 对该算法进行如下扩充，以处理溢出。如果没有度数小于 $k$ 的顶点，则随机选择一个顶点，溢出它，从图中移除它，然后递归地为图的其余部分着色。

在着色之前，, \citet{Chaitin:1981vl} 合并与移动相关且互不干扰的变量，这个过程被称为 \emph{合并}。虽然合并减少移动的次数，但它会使图形更难着色。 \citet{Briggs:1994kx} 提出 \emph{保守合并} ，即只有当两个变量的高阶邻居小于 $k$
时，才会合并。 \citet{George:1996aa} 观察到，保守的合并有时过于保守，通过迭代合并，移除低阶顶点，使其更加激进。
%
从不同的角度来解决这个问题， \citet{Briggs:1994kx}
还提出 \emph{偏色} ，即一个变量被赋予与另一个与移动相关的变量相同的颜色，如第~\ref{sec:move-biasing} 节所述。
%
 \citet{Chaitin:1981vl} 算法及其成功子算法迭代地执行合并、图着色和溢出码插入，直到所有变量都被分配到一个位置。

\citet{Briggs:1994kx} 观察到， \citet{Chaitin:1982vn} 有时会溢出一些不必要的变量；如果一个高度变量的许多邻居被赋予相同的颜色，那么它就可以被着色。
\citet{Briggs:1994kx} 提出 \emph{乐观着色法} ，即高度顶点不会立即溢出。相反，决策被推迟到递归调用之后，这时就可以清楚地看到是否存在可用的颜色。我们观察到，如果将前  $k$ 
个颜色作为寄存器，其余的颜色作为堆栈位置，那么这个算法等价于最小最后排序算法~\citep{Matula:1972aa} 。
%% biased coloring
印第安纳大学
\citep{Dybvig:2010aa} 编译课程的早期版本是基于
\citet{Briggs:1994kx} 的算法。

最小最后排序算法是众多 \emph{贪婪}
着色算法中的一种。贪婪着色算法以特定的顺序访问所有顶点，并为每个顶点分配第一个可用的颜色。 \emph{离线} 贪婪算法在分配颜色之前预先选择排序。
\citet{Chaitin:1981vl}算法应该被认为是离线的，因为顶点排序不依赖于分配的颜色，所以算法可以分为两个阶段。其他的命令也是可能的。例如， \citet{Chow:1984ys} 的顺序变量根据运行时成本的估计。

 \emph{在线} 贪婪着色算法使用关于当前颜色分配的信息来影响其余顶点着色的顺序。本章所描述的基于饱和的算法就是这样一种算法。我们选择使用饱和着色是因为通过数独引入图形着色很有趣。

寄存器分配器可以选择将每个变量仅映射到一个位置，如 \citet{Chaitin:1981vl}，也可以选择将一个变量映射到一个或多个位置。后者可以通过
\emph{活动范围分割}来实现，其中一个变量被多个变量替换，每个变量处理其活动范围的一部分~\citep{Chow:1984ys,Briggs:1994kx,Cooper:1998ly} 。

%% 1950s, Sheldon Best, Fortran \cite{Backus:1978aa}, Belady's page
%% replacement algorithm, bottom-up local
%% \citep{Horwitz:1966aa} straight-line programs, single basic block, 

%% Cooper: top-down (priority bassed), bottom-up

%% top-down
%%   order variables by priority (estimated cost)
%%   caveat: split variables into two groups:
%%     constrained (>k neighbors) and unconstrained (<k neighbors)
%%     color the constrained ones first

%% \citet{Schwartz:1975aa} graph-coloring, no spill
%% cite J. Cocke for an algorithm that colors variables
%%   in a high-degree first ordering

%Register Allocation via Usage Counts, Freiburghouse CACM

\citet{Palsberg:2007si} 观察到JoeQ编译器中Java程序产生的许多干涉图都是 \emph{弦状}的，也就是说，每个有4条或更多边的循环有一条边不是循环的一部分，但它连接循环上的两个顶点。这样的图可以通过贪婪算法最优着色，顶点排序由最大基数搜索确定。

在编译时间非常重要的情况下，例如在即时编译器中，图着色算法可能过于昂贵，而 \citet{Poletto:1999uq} 的线性扫描可能更合适。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{布尔和控制流}
\label{ch:Rif}
\index{Boolean}
\index{control flow}
\index{conditional expression}

 \LangInt{} 和 \LangVar{} 语言只有一种值：整数。在本章中，添加第二种值，布尔值，来创建 \LangIf{} 语言。布尔值
\emph{true} 和 \emph{false} 在 Racket 中分别表示为 \key{\#t} 和 \key{\#f}
。 \LangIf{} 语言包括几个涉及布尔值 (\key{and} 、\key{not} 、\key{eq?}
、\key{<} 等) 和条件式 \key{if} 表达式。通过添加 \key{if} ，程序可以具有重要的控制流，这将影响显式控制和动态分析。另外，因为现在有两种类型的值，所以需要处理对错误类型的值应用操作的程序，比如 \code{(not 1)} 。

对于这种情况，有两种语言设计选项。一种选择是发出错误信号，另一种选择是提供对操作的更广泛的解释。Racket语言混合使用这两种选项，这取决于操作和值的类型。例如，在 Racket 中\code{(not 1)} 的结果是
\code{\#f} ，因为 Racket 将非零整数视为
\code{\#t} 。另一方面， \code{(car 1)} 在Racket中导致运行时错误，因为 \code{car} 期望一对。

类型 Racket 的设计选择与 Racket 相似，只是大部分错误检测发生在编译时而不是运行时。类型
Racket 接受并运行 \code{(not 1)} ，产生 \code{\#f} 。但是在 \code{(car 1)} ，类型 Racket 报告一个编译时错误，因为类型 Racket 期望参数的类型是 \code{(Listof T)} 或 \code{(Pairof T1 T2)} 的形式。

 \LangIf{} 语言在编译期间执行类型检查，就像类型 Racket 。在第~\ref{ch:type-dynamic} 章中，研究另一种选择，即像 Racket 这样的动态类型语言。
 \LangIf{} 语言是类型化 Racket 的子集；对于某些操作，我们有更多的限制，例如，拒绝
\code{(not 1)} 。

本章组织如下。首先定义 \LangIf{} 语言的语法和解释器(第~\ref{sec:lang-if} 节)。然后介绍类型检查的概念，并为 \LangIf{}
构建一个类型检查器(第~\ref{sec:type-check-Rif} 节)。为了编译 \LangIf{} ，需要将中间语言 \LangCVar{} 放大为 \LangCIf{}
(~\ref{sec:Cif} 节) ，将 \LangXInt{} 放大为 \LangXIf{}
(~\ref{sec:x86-if} 节) 。本章的其余部分将讨论编译器如何更改通道以适应布尔值和条件控制流。还有一个名为 \code{shrink}的新通道，它将一些操作符转换为其他操作符，从而减少在以后的通道中需要处理的操作符的数量。最大的变化发生在 \code{explicate-control} ，将
\code{if} 表达式转换为控制流图(第~\ref{sec:explicate-control-Rif} 节)。关于寄存器分配，现在活性分析有多个基本块需要处理，并且存在一个有趣的问题，即如何处理条件跳转。


\section{ \LangIf{} 语言}
\label{sec:lang-if}

图~\ref{fig:Rif-concrete-syntax} 定义 \LangIf{} 语言的具体语法，图~\ref{fig:Rif-syntax} 定义抽象语法。 \LangIf{} 语言包括所有的
\LangVar{} (以灰色显示) 、布尔文字 \code{\#t} 和
\code{\#f} ，以及条件 \code{if} 表达式。将操作符扩展为包括
\begin{enumerate}
\item 整数减法；
\item 逻辑运算符 \key{and} 、\key{or} 和 \key{not} ；
\item  \key{eq?} 操作用于比较两个整数或两个布尔值；
\item  \key{<} 、\key{<=} 、\key{>} 和 \key{>=} 用于比较整数的操作。
\end{enumerate}
重新组织图~\ref{fig:Rif-syntax}中基本操作的抽象语法，对所有这些操作只使用一条语法规则。这意味着语法不再检查操作符的数量是否与实参的数量匹配。这个职责被转移到 \LangIf{} 的类型检查器上，我们将在~\ref{sec:type-check-Rif} 节中介绍它。

\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{lcl}
  \itm{bool} &::=& \key{\#t} \mid \key{\#f} \\  
  \itm{cmp} &::= & \key{eq?} \mid \key{<} \mid \key{<=} \mid \key{>} \mid \key{>=} \\
  \Exp &::=& \gray{ \Int \mid \CREAD{} \mid \CNEG{\Exp} \mid \CADD{\Exp}{\Exp} }  \mid \CSUB{\Exp}{\Exp} \\
     &\mid&  \gray{ \Var \mid \CLET{\Var}{\Exp}{\Exp} } \\
     &\mid& \itm{bool}
      \mid (\key{and}\;\Exp\;\Exp) \mid (\key{or}\;\Exp\;\Exp)
      \mid (\key{not}\;\Exp) \\
      &\mid& (\itm{cmp}\;\Exp\;\Exp) \mid \CIF{\Exp}{\Exp}{\Exp} \\
  \LangIf{} &::=& \Exp
\end{array}
\]
\end{minipage}
}
\caption{ \LangIf{} 的具体语法，用布尔值和条件符扩展 \LangVar{}
  (图~\ref{fig:r1-concrete-syntax}) }
\label{fig:Rif-concrete-syntax}
\end{figure}

\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{lcl}
  \itm{bool} &::=& \code{\#t} \mid \code{\#f} \\
  \itm{cmp} &::= & \code{eq?} \mid \code{<} \mid \code{<=} \mid \code{>} \mid \code{>=} \\
  \itm{op} &::= & \itm{cmp} \mid \code{read} \mid \code{+} \mid \code{-}
    \mid \code{and} \mid \code{or} \mid \code{not} \\
  \Exp &::=& \gray{ \INT{\Int} \mid \VAR{\Var} \mid \LET{\Var}{\Exp}{\Exp} } \\
     &\mid& \PRIM{\itm{op}}{\Exp\ldots}\\
     &\mid& \BOOL{\itm{bool}} \mid \IF{\Exp}{\Exp}{\Exp} \\
  \LangIf{} &::=& \PROGRAM{\code{'()}}{\Exp}
\end{array}
\]
\end{minipage}
}
\caption{ \LangIf{} 的抽象语法。}
\label{fig:Rif-syntax}
\end{figure}

图~\ref{fig:interp-Rif} 定义 \LangIf{} 的解释器，它继承自 \LangVar{}
的解释器(图~\ref{fig:interp-Rvar}) 。字面量 \code{\#t} 和 \code{\#f}
计算为相应的布尔值。条件表达式 $(\key{if}\, \itm{cnd}\,\itm{thn}\,\itm{els})$ 计算
\itm{cnd} ，然后根据 \itm{cnd} 生成的是 \code{\#t} 还是 \code{\#f} ，计算 \itm{thn} 或 \itm{els} 。逻辑操作 \code{not} 和 \code{and} 的行为与可能期望的一样，但请注意 \code{and} 操作是短路的。也就是说，给定表达式 $(\key{and}\,e_1\,e_2)$ ，如果 $e_1$ 计算为 \code{\#f} ，则不计算表达式 $e_2$ 。

随着原语操作数量的增加，解释器将变得重复而无需多加注意。我们重构 \code{Prim} 的案例，将每个操作不同的代码移到图 \code{interp-op} 中所示的~\ref{fig:interp-op-Rif} 方法中。分开处理 \code{and} 操作，因为它的短路行为。

\begin{figure}[tbp]
\begin{lstlisting}
(define interp-Rif-class
  (class interp-Rvar-class
    (super-new)

    (define/public (interp-op op) ...)

    (define/override ((interp-exp env) e)
      (define recur (interp-exp env))
      (match e
        [(Bool b) b]
        [(If cnd thn els)
         (match (recur cnd)
           [#t (recur thn)]
           [#f (recur els)])]
        [(Prim 'and (list e1 e2))
         (match (recur e1)
           [#t (match (recur e2) [#t #t] [#f #f])]
           [#f #f])]
        [(Prim op args)
         (apply (interp-op op) (for/list ([e args]) (recur e)))]
        [else ((super interp-exp env) e)]))
    ))

(define (interp-Rif p)
  (send (new interp-Rif-class) interp-program p))
\end{lstlisting}
\caption{ \LangIf{} 语言的解释器。 (请参见图~\ref{fig:interp-op-Rif} 中的 \code{interp-op} 。)}
\label{fig:interp-Rif}
\end{figure}

\begin{figure}[tbp]
\begin{lstlisting}
(define/public (interp-op op)
  (match op
    ['+ fx+]
    ['- fx-]
    ['read read-fixnum]
    ['not (lambda (v) (match v [#t #f] [#f #t]))]
    ['or (lambda (v1 v2)
           (cond [(and (boolean? v1) (boolean? v2))
                  (or v1 v2)]))]
    ['eq? (lambda (v1 v2)
            (cond [(or (and (fixnum? v1) (fixnum? v2))
                       (and (boolean? v1) (boolean? v2))
                       (and (vector? v1) (vector? v2)))
                   (eq? v1 v2)]))]
    ['< (lambda (v1 v2)
          (cond [(and (fixnum? v1) (fixnum? v2))
                 (< v1 v2)]))]
    ['<= (lambda (v1 v2)
           (cond [(and (fixnum? v1) (fixnum? v2))
                  (<= v1 v2)]))]
    ['> (lambda (v1 v2)
          (cond [(and (fixnum? v1) (fixnum? v2))
                 (> v1 v2)]))]
    ['>= (lambda (v1 v2)
           (cond [(and (fixnum? v1) (fixnum? v2))
                  (>= v1 v2)]))]
    [else (error 'interp-op "unknown operator")]))
\end{lstlisting}
\caption{ \LangIf{} 语言中原语操作符的解释器。}
\label{fig:interp-op-Rif}
\end{figure}


\section{类型检查 \LangIf{} 程序}
\label{sec:type-check-Rif}
\index{type checking}
\index{semantic analysis}

用两种互补的方式来考虑类型检查是很有帮助的。类型检查器预测程序中每个表达式将产生的值的类型。对于 \LangIf{} ，只有两种类型，
\key{Integer} 和 \key{Boolean} 。所以类型检查器应该预测
\begin{lstlisting}
   (+ 10 (- (+ 12 20)))
\end{lstlisting}
产生一个 \key{Integer} ，而
\begin{lstlisting}
   (and (not #f) #t)
\end{lstlisting}
生成一个 \key{Boolean} 。

另一种考虑类型检查的方式是，它强制一组规则，规定哪些操作符可以应用于哪些类型的值。例如， \LangIf{} 类型检查器会为下面的表达式发出错误信号
\begin{lstlisting}
   (not (+ 10 (- (+ 12 20))))
\end{lstlisting}
子表达式 \code{(+ 10 (- (+ 12 20)))} 的类型为 \key{Integer}
，但类型检查器强制规定 \code{not}
的参数必须是 \key{Boolean} 。

我们使用类和方法实现类型检查，因为它们提供重用代码所需的开放递归，将在后面的章节扩展类型检查器，类似于为解释器使用类和方法(第~\ref{sec:extensible-interp} 节)。

将 \LangVar{} 片段的类型检查器分离到它自己的类中，如图~\ref{fig:type-check-Rvar} 所示。
\LangIf{} 的类型检查器如图~\ref{fig:type-check-Rif} 所示，它继承自 \LangVar{} 的类型检查器。这些类型检查器在支持代码的 \code{type-check-Rvar.rkt} 和 \code{type-check-Rif.rkt} 文件中。
%
每个类型检查器都是AST上的结构递归函数。
给定一个输入表达式 \code{e} ，类型检查器要么发出错误信号，要么返回一个表达式及其类型 (\key{Integer} 或
\key{Boolean}) 。它返回一个表达式，因为在某些情况下我们想要更改或更新表达式。

接下来，讨论图~\ref{fig:type-check-Rvar} 中的 \code{type-check-exp} 的 \code{match} 用例。
整型常量的类型为
\code{Integer} 。要处理变量，类型检查器使用环境 \code{env} 将变量映射到类型。考虑一下 \key{let} 的情况。对初始化表达式进行类型检查以获得其类型 \key{T} ，然后将类型 \code{T} 与用于 \key{let} 主体类型检查的环境中的变量
\code{x} 关联起来。因此，当类型检查器遇到变量
\code{x} 的使用时，它可以在环境中找到它的类型。对于基元操作符，递归地分析实参，然后调用 \code{type-check-op} 来检查是否允许实参类型。

在类型检查器中使用几种辅助方法。
\code{operator-types} 方法定义一个将操作符名称映射到它们的形参和返回类型的字典。 \code{type-equal?}
方法确定两种类型是否相等，目前它只是分派给 \code{equal?}  (深度相等) 。如果两种类型不相等，
\code{check-type-equal?} 方法会触发错误。 \code{type-check-op} 方法在 \code{operator-types} 字典中查找操作符，然后检查实参类型是否等于形参类型。结果是操作符的返回类型。

\begin{figure}[tbp]
%\begin{framed}
\begin{lstlisting}
(define type-check-Rvar-class
  (class object%
    (super-new)

    (define/public (operator-types)
      '((+ . ((Integer Integer) . Integer))
        (- . ((Integer) . Integer))
        (read . (() . Integer))))

    (define/public (type-equal? t1 t2) (equal? t1 t2))

    (define/public (check-type-equal? t1 t2 e)
      (unless (type-equal? t1 t2)
        (error 'type-check "~a != ~a\nin ~v" t1 t2 e)))

    (define/public (type-check-op op arg-types e)
      (match (dict-ref (operator-types) op)
        [`(,param-types . ,return-type)
         (for ([at arg-types] [pt param-types])
           (check-type-equal? at pt e))
         return-type]
        [else (error 'type-check-op "unrecognized ~a" op)]))

    (define/public (type-check-exp env)
      (lambda (e)
        (match e
          [(Int n)  (values (Int n) 'Integer)]
          [(Var x)  (values (Var x) (dict-ref env x))]
          [(Let x e body)
           (define-values (e^ Te) ((type-check-exp env) e))
           (define-values (b Tb) ((type-check-exp (dict-set env x Te)) body))
           (values (Let x e^ b) Tb)]
          [(Prim op es)
           (define-values (new-es ts)
             (for/lists (exprs types) ([e es]) ((type-check-exp env) e)))
           (values (Prim op new-es) (type-check-op op ts e))]
          [else (error 'type-check-exp "couldn't match" e)])))
\end{lstlisting}
\end{figure}
\begin{figure}[tbp]
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
    (define/public (type-check-program e)
      (match e
        [(Program info body)
         (define-values (body^ Tb) ((type-check-exp '()) body))
         (check-type-equal? Tb 'Integer body)
         (Program info body^)]
        [else (error 'type-check-Rvar "couldn't match ~a" e)]))
    ))

(define (type-check-Rvar p)
  (send (new type-check-Rvar-class) type-check-program p))
\end{lstlisting}
\caption{ \LangVar{} 语言的类型检查器。}
\label{fig:type-check-Rvar}
%\end{framed}
\end{figure}

\begin{figure}[tbp]
\begin{lstlisting}
(define type-check-Rif-class
  (class type-check-Rvar-class
    (super-new)
    (inherit check-type-equal?)
    
    (define/override (operator-types)
      (append '((- . ((Integer Integer) . Integer))
                (and . ((Boolean Boolean) . Boolean))
                (or . ((Boolean Boolean) . Boolean))
                (< . ((Integer Integer) . Boolean))
                (<= . ((Integer Integer) . Boolean))
                (> . ((Integer Integer) . Boolean))
                (>= . ((Integer Integer) . Boolean))
                (not . ((Boolean) . Boolean))
                )
              (super operator-types)))

    (define/override (type-check-exp env)
      (lambda (e)
        (match e
          [(Prim 'eq? (list e1 e2))
           (define-values (e1^ T1) ((type-check-exp env) e1))
           (define-values (e2^ T2) ((type-check-exp env) e2))
           (check-type-equal? T1 T2 e)
           (values (Prim 'eq? (list e1^ e2^)) 'Boolean)]
          [(Bool b) (values (Bool b) 'Boolean)]
          [(If cnd thn els)
           (define-values (cnd^ Tc) ((type-check-exp env) cnd))
           (define-values (thn^ Tt) ((type-check-exp env) thn))
           (define-values (els^ Te) ((type-check-exp env) els))
           (check-type-equal? Tc 'Boolean e)
           (check-type-equal? Tt Te e)
           (values (If cnd^ thn^ els^) Te)]
          [else ((super type-check-exp env) e)])))
    ))

(define (type-check-Rif p)
  (send (new type-check-Rif-class) type-check-program p))
\end{lstlisting}
\caption{ \LangIf{} 语言的类型检查器。}
\label{fig:type-check-Rif}
\end{figure}

接下来讨论图~\ref{fig:type-check-Rif} 中 \LangIf{} 的类型检查器。操作符 \code{eq?} 要求两个参数具有相同的类型。布尔常量的类型是
\code{Boolean} 。 \code{if} 的条件必须是
\code{Boolean} 类型，并且两个分支必须具有相同的类型。
\code{operator-types} 函数为其他新操作符添加字典条目。

\begin{exercise}\normalfont
在 \LangIf{} 中创建10个新的测试程序。一半的程序应该有一个类型错误。对于这些程序，创建一个具有相同基名但文件扩展名为 \code{.tyerr} 的空文件。例如，如果测试 \code{cond\_test\_14.rkt} 预计会出错，则创建一个名为 \code{cond\_test\_14.tyerr} 的空文件。这指示
\code{interp-tests} 和 \code{compiler-tests} 预期会出现类型错误。另一半的测试程序不应该有类型错误。

在 \code{run-tests.rkt} 脚本中，将
\code{interp-tests} 和 \code{compiler-tests} 的第二个参数更改为
\code{type-check-Rif} ，这将导致类型检查器在编译器通过之前运行。暂时将 \code{passes} 更改为空列表并运行脚本，从而检查新的测试程序是否如预期的那样进行类型检查。
\end{exercise}


\section{ \LangCIf{} 中间语言}
\label{sec:Cif}

图~\ref{fig:c1-syntax} 定义
\LangCIf{} 中间语言的抽象语法。 (具体的语法见附录，图~\ref{fig:c1-concrete-syntax} 。)  与
\LangCVar{} 相比， \LangCIf{} 语言将逻辑运算符和比较运算符添加到 \Exp{} 非终端中，将文字 \key{\#t} 和
\key{\#f} 添加到 \Arg{} 非终端中。

对于控制流， \LangCIf{} 将 \key{goto} 和 \code{if}
语句添加到 \Tail{} 非终端中。 \code{if}
语句的条件是比较操作，分支是 \code{goto}
语句，这使得将 \code{if} 语句编译到x86非常简单。


\begin{figure}[tp]
\fbox{
\begin{minipage}{0.96\textwidth}
\small    
\[
\begin{array}{lcl}
\Atm &::=& \gray{\INT{\Int} \mid \VAR{\Var}} \mid \BOOL{\itm{bool}} \\
\itm{cmp} &::= & \key{eq?} \mid \key{<}  \\
\Exp &::= & \gray{ \Atm \mid \READ{} }\\
     &\mid& \gray{ \NEG{\Atm} \mid \ADD{\Atm}{\Atm} } \\
     &\mid& \UNIOP{\key{'not}}{\Atm} 
     \mid \BINOP{\key{'}\itm{cmp}}{\Atm}{\Atm} \\
\Stmt &::=& \gray{ \ASSIGN{\VAR{\Var}}{\Exp} } \\
\Tail &::= & \gray{\RETURN{\Exp} \mid \SEQ{\Stmt}{\Tail} } 
    \mid \GOTO{\itm{label}} \\
    &\mid& \IFSTMT{\BINOP{\itm{cmp}}{\Atm}{\Atm}}{\GOTO{\itm{label}}}{\GOTO{\itm{label}}} \\
\LangCIf{} & ::= & \gray{\CPROGRAM{\itm{info}}{\LP\LP\itm{label}\,\key{.}\,\Tail\RP\ldots\RP}}
\end{array}
\]
\end{minipage}
}
\caption{ \LangCIf{} 的抽象语法， \LangCVar{} 的扩展
  (图~\ref{fig:c0-syntax})。}
\label{fig:c1-syntax}
\end{figure}

\section{ \LangXIf{} 语言}
\label{sec:x86-if}

\index{x86} 为了实现新的逻辑操作、比较操作和 \key{if} 表达式，需要进一步研究x86语言。图~\ref{fig:x86-1-concrete} 和 \ref{fig:x86-1}
定义x86的 \LangXIf{} 子集的具体和抽象语法，其中包括用于逻辑操作、比较和条件跳转的指令。

一个挑战是x86没有提供直接实现逻辑否定的指令(在 \LangIf{} 和
\LangCIf{} 中是 \code{not}) 。但是， \code{xorq} 指令可以用来编码 \code{not} 。 \key{xorq} 指令接受两个参数，对其参数的每一位执行一个成对异或 ($\mathrm{XOR}$) 操作，并将结果写入第二个参数。
回想一下异或的真值表：
\begin{center}
\begin{tabular}{l|cc}
   & 0 & 1 \\ \hline
0  & 0 & 1 \\
1  & 1 & 0
\end{tabular}
\end{center}
例如，对二进制数
$0011$ 和 $0101$ 的每一位应用 $\mathrm{XOR}$ ，结果是 $0110$ 。注意，在表中第 $1$ 位的行中，结果与第2位相反。因此， \code{not} 操作可以由 \code{xorq} 以 $1$ 作为第一个参数来实现：
\[
\Var~ \key{=}~ \LP\key{not}~\Arg\RP\key{;}
\qquad\Rightarrow\qquad
\begin{array}{l}
\key{movq}~ \Arg\key{,} \Var\\
\key{xorq}~ \key{\$1,} \Var
\end{array}
\]


\begin{figure}[tp]
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{lcl}
  \itm{bytereg} &::=& \key{ah} \mid \key{al} \mid \key{bh} \mid \key{bl}
    \mid \key{ch} \mid \key{cl} \mid \key{dh} \mid \key{dl} \\
\Arg &::=& \gray{ \key{\$}\Int \mid \key{\%}\Reg \mid \Int\key{(}\key{\%}\Reg\key{)} } \mid \key{\%}\itm{bytereg}\\
\itm{cc} & ::= & \key{e} \mid \key{l} \mid \key{le} \mid \key{g} \mid \key{ge} \\
\Instr &::=& \gray{ \key{addq} \; \Arg\key{,} \Arg \mid
      \key{subq} \; \Arg\key{,} \Arg \mid
      \key{negq} \; \Arg \mid \key{movq} \; \Arg\key{,} \Arg \mid } \\
  &&  \gray{ \key{callq} \; \itm{label} \mid
      \key{pushq}\;\Arg \mid \key{popq}\;\Arg \mid \key{retq} \mid \key{jmp}\,\itm{label} } \\
  && \gray{ \itm{label}\key{:}\; \Instr }
     \mid \key{xorq}~\Arg\key{,}~\Arg
     \mid \key{cmpq}~\Arg\key{,}~\Arg  \mid \\
  &&  \key{set}cc~\Arg
     \mid \key{movzbq}~\Arg\key{,}~\Arg
     \mid \key{j}cc~\itm{label}
     \\
\LangXIf{} &::= & \gray{ \key{.globl main} }\\
      &    & \gray{ \key{main:} \; \Instr\ldots }
\end{array}
\]
\end{minipage}
}
\caption{\LangXIf{} 的具体语法 (扩展图~\ref{fig:x86-int-concrete} 中的 \LangXInt{} )。}
\label{fig:x86-1-concrete}
\end{figure}

\begin{figure}[tp]
\fbox{
\begin{minipage}{0.98\textwidth}
\small    
\[
\begin{array}{lcl}
\itm{bytereg} &::=& \key{ah} \mid \key{al} \mid \key{bh} \mid \key{bl}
    \mid \key{ch} \mid \key{cl} \mid \key{dh} \mid \key{dl} \\
\Arg &::=&  \gray{\IMM{\Int} \mid \REG{\Reg} \mid \DEREF{\Reg}{\Int}} 
     \mid \BYTEREG{\itm{bytereg}} \\
\itm{cc} & ::= & \key{e} \mid \key{l} \mid \key{le} \mid \key{g} \mid \key{ge} \\
\Instr &::=& \gray{ \BININSTR{\code{addq}}{\Arg}{\Arg} 
       \mid \BININSTR{\code{subq}}{\Arg}{\Arg} } \\
       &\mid& \gray{ \BININSTR{\code{'movq}}{\Arg}{\Arg} 
       \mid \UNIINSTR{\code{negq}}{\Arg} } \\
       &\mid& \gray{ \CALLQ{\itm{label}}{\itm{int}} \mid \RETQ{} 
       \mid \PUSHQ{\Arg} \mid \POPQ{\Arg} \mid \JMP{\itm{label}} } \\
       &\mid& \BININSTR{\code{xorq}}{\Arg}{\Arg}
       \mid \BININSTR{\code{cmpq}}{\Arg}{\Arg}\\
       &\mid& \BININSTR{\code{set}}{\itm{cc}}{\Arg} 
       \mid \BININSTR{\code{movzbq}}{\Arg}{\Arg}\\
       &\mid&  \JMPIF{\itm{cc}}{\itm{label}} \\
\Block &::= & \gray{\BLOCK{\itm{info}}{\LP\Instr\ldots\RP}} \\
\LangXIf{} &::= & \gray{\XPROGRAM{\itm{info}}{\LP\LP\itm{label} \,\key{.}\, \Block \RP\ldots\RP}}
\end{array}
\]
\end{minipage}
}
\caption{ \LangXIf{} 的抽象语法 (扩展图~\ref{fig:x86-int-ast} 中的 \LangXInt{} )。}
\label{fig:x86-1}
\end{figure}

接下来，我们考虑与编译比较操作相关的x86指令。 \key{cmpq} 指令比较它的两个参数来确定一个参数是小于、等于还是大于另一个参数。 \key{cmpq} 指令在参数的顺序和结果放置的位置上是不同寻常的。参数顺序颠倒：如果你想测试是否
$x < y$ ，那么写 \code{cmpq} $y$\code{,} $x$ 。
\key{cmpq} 的结果被放置在特殊的EFLAGS寄存器中。这个寄存器不能直接访问，但可以通过许多指令进行查询，包括 \key{set} 指令。指令
$\key{set}cc~d$ 根据条件代码 \itm{cc} (\key{e} 表示等于， \key{l} 表示小于， \key{le}
表示不等于， \key{g} 表示大于， \key{ge} 表示大于等于) ，将 \key{1} 或 \key{0} 放入目标 $d$ 中。 \key{set} 指令有一个令人讨厌的怪癖，因为它的目标参数必须是单字节寄存器，例如
\code{al} (低位为 L ) 或 \code{ah} (高位为 H )，它们是 \code{rax} 寄存器的一部分。值得庆幸的是，可以使用 \key{movzbq}
指令将单个字节寄存器移到普通64位寄存器。 \code{set}
指令的抽象语法不同于具体语法，因为它将指令名与条件代码分开。

x86条件跳转指令与 \key{if} 表达式的编译有关。指令
$\key{j}\itm{cc}~\itm{label}$ 更新程序计数器指向 \itm{label} 之后的指令，这取决于EFLAGS寄存器中的结果是否与条件代码 \itm{cc} 匹配，否则跳转指令将跳转到下一条指令。与 \code{set} 的抽象语法一样，条件跳转的抽象语法将指令名与条件代码分开。
例如， \code{(JmpIf le foo)} 对应于 \code{jle foo} 。因为条件跳转指令依赖于EFLAGS寄存器，所以通常它前面会立即有一个 \key{cmpq} 指令来设置EFLAGS寄存器。


\section{缩小 \LangIf{} 语言}
\label{sec:shrink-Rif}

 \LangIf{} 语言包含几个操作符，可以很容易地用其他操作符表示。例如，减法可以用加法和否定来表示。
\[
 \key{(-}\; e_1 \; e_2\key{)} \quad \Rightarrow \quad \LP\key{+} \; e_1 \; \LP\key{-} \; e_2\RP\RP
\]
一些比较操作可以使用小于和逻辑否定来表示。
\[
\LP\key{<=}\; e_1 \; e_2\RP \quad \Rightarrow \quad
\LP\key{let}~\LP\LS\key{tmp.1}~e_1\RS\RP~\LP\key{not}\;\LP\key{<}\;e_2\;\key{tmp.1})\RP\RP
\]
在上面的转换中需要 \key{let} ，以确保表达式 $e_1$ 在 $e_2$ 之前求值。

通过在编译器前端执行这些转换，编译器后面的通道不需要处理这些操作符，使得通道更短。

%% On the other hand, sometimes
%% these translations make it more difficult to generate the most
%% efficient code with respect to the number of instructions. However,
%% these differences typically do not affect the number of accesses to
%% memory, which is the primary factor that determines execution time on
%% modern computer architectures.

\begin{exercise}\normalfont
通过将它们转换为 \LangIf{} 中的其他结构，实现 \code{shrink} 通道来从语言中删除减法、 \key{and} 、
\key{or} 、 \key{<=} 、 \key{>} 和 \key{>=} 。
%
创建6个包含这些操作符的测试程序。
%
在 \code{run-tests.rkt} 脚本中，将下面的
\code{shrink} 条目添加到通道列表中(此时它应该是唯一的传递)。
\begin{lstlisting}
(list "shrink" shrink interp-Rif type-check-Rif)
\end{lstlisting}
这指示 \code{interp-tests} 在 \code{shrink} 输出上运行解释器
\code{interp-Rif} 和类型检查器 \code{type-check-Rif} 。
%
运行该脚本在所有测试程序上测试编译器。

\end{exercise}

\section{统一变量}
\label{sec:uniquify-Rif}

将个案添加到 \code{uniquify-exp} 以处理布尔常量和
\code{if} 表达式。

\begin{exercise}\normalfont
更新 \LangIf{} 的 \code{uniquify-exp} ，并将以下条目添加到 \code{run-tests.rkt} 脚本中的 \code{passes} 列表中。
\begin{lstlisting}
(list "uniquify" uniquify interp-Rif type-check-Rif)
\end{lstlisting}
运行脚本来测试编译器。
\end{exercise}

\section{去除复杂的操作数}
\label{sec:remove-complex-opera-Rif}

此通道的输出语言是 \LangIfANF{}
(图~\ref{fig:Rif-anf-syntax}) ，
\LangIf{} 的管理标准形式。 \code{Bool} 形式是一个原子表达式，但
\code{If} 不是。 \code{If} 的三个子表达式都可以是复杂表达式，但 \code{not} 的操作数和比较操作数必须是原子。

在 \code{rco-exp} 和
\code{rco-atom} 函数中添加 \code{Bool} 和 \code{If} 的情况，根据输出是需要
\Exp{} 还是在 \LangIfANF{} 语法中指定的 \Atm{} 。
关于 \code{If} ，特别重要的是 \textbf{not}
将其条件替换为临时变量，因为这干扰在
\code{explicate-control} 通道中生成高质量的输出。

\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{rcl}
\Atm &::=& \gray{ \INT{\Int} \mid \VAR{\Var} } \mid \BOOL{\itm{bool}}\\
\Exp &::=& \gray{ \Atm \mid \READ{} } \\
     &\mid& \gray{ \NEG{\Atm} \mid \ADD{\Atm}{\Atm} } \\
     &\mid& \gray{ \LET{\Var}{\Exp}{\Exp} } \\
     &\mid& \UNIOP{\key{not}}{\Atm} \\
      &\mid& \BINOP{\itm{cmp}}{\Atm}{\Atm} \mid \IF{\Exp}{\Exp}{\Exp} \\
R^{\dagger}_2  &::=& \PROGRAM{\code{()}}{\Exp}
\end{array}
\]
\end{minipage}
}
\caption{\LangIfANF{} 是管理范式(ANF)中的 \LangIf{} 。}
\label{fig:Rif-anf-syntax}
\end{figure}


\begin{exercise}\normalfont
%
在 \code{compiler.rkt} 中的 \code{rco-atom}
和 \code{rco-exp} 函数中添加布尔常量和 \code{if} 的大小写。
%
创建三个新的 \LangInt{} 程序来执行本文中有趣的代码。
%
在 \code{run-tests.rkt} 脚本中，将以下条目添加到 \code{passes} 列表中，然后运行该脚本来测试编译器。
\begin{lstlisting}
(list "remove-complex" remove-complex-opera* interp-Rif type-check-Rif)
\end{lstlisting}
\end{exercise}


\section{说明控制}
\label{sec:explicate-control-Rif}

回想一下， \code{explicate-control} 的目的是使程序语法中的求值顺序显式。加上 \key{if} 这个会更有趣。

下面的程序有一个
\key{if} 表达式嵌套在另一个 \key{if} 的谓词中，这是一个有启发性的例子。
% cond_test_41.rkt
\begin{center}
\begin{minipage}{0.96\textwidth}
\begin{lstlisting}
(let ([x (read)])
  (let ([y (read)])
    (if (if (< x 1) (eq? x 0)  (eq? x 2))
        (+ y 2)
        (+ y 10))))
\end{lstlisting}
\end{minipage}
\end{center}
%
编译 \key{if} 和比较的简单方法是孤立地处理它们中的每一个，而不考虑它们的上下文。每次比较都将被转换为一个 \key{cmpq} 指令，后面跟着两个指令，将结果从EFLAGS寄存器移动到一个通用寄存器或堆栈位置。每个 \key{if} 都将被翻译成一个 \key{cmpq} 指令，后面跟着一个条件跳转。上面例子中为内部 \key{if} 生成的代码如下所示。
\begin{center}
\begin{minipage}{0.96\textwidth}
\begin{lstlisting}
    ...
    cmpq $1, x          ;; (< x 1)
    setl %al
    movzbq %al, tmp
    cmpq $1, tmp        ;; (if ...)
    je then_branch_1
    jmp else_branch_1
    ...
\end{lstlisting}
\end{minipage}
\end{center}
但是，如果考虑到上下文，可以做得更好，并减少使用 \key{cmpq} 指令来访问EFLAG寄存器。

我们的目标是编译 \key{if} 表达式，以便相关的比较指令直接出现在条件跳转之前。
例如，希望为内部 \code{if} 生成以下代码。
\begin{center}
\begin{minipage}{0.96\textwidth}
\begin{lstlisting}
    ...
    cmpq $1, x
    je then_branch_1
    jmp else_branch_1
    ...
\end{lstlisting}
\end{minipage}
\end{center}
实现这一点的一种方法是在
\LangIf{} 级别上重新组织代码，将外部的 \key{if} 推到内部的 \key{if} 中，产生以下代码。
\begin{center}
\begin{minipage}{0.96\textwidth}
\begin{lstlisting}
(let ([x (read)])
  (let ([y (read)])
    (if (< x 1) 
      (if (eq? x 0)
        (+ y 2)
        (+ y 10))
      (if (eq? x 2)
        (+ y 2)
        (+ y 10)))))
\end{lstlisting}
\end{minipage}
\end{center}
不幸的是，这种方法从外部的 \code{if} 复制两个分支，编译器绝对不能复制代码!

需要一种方法来执行上述转换，但又不复制代码。也就是说，需要一种方法让程序的不同部分引用同一段代码。在x86汇编的层次上，这是很简单的，因为可以为每个分支标记代码，并在需要执行分支的所有地方插入跳转。在中间语言中，需要远离抽象的语法 \emph{树} ，而使用 \emph{图} 。特别是，使用一种称为
\emph{控制流图} (CFG) 的标准程序表示，这是由 Frances Elizabeth
\citet{Allen:1970uq} 提出的。 \index{control-flow graph} 每个顶点是一个标记的代码序列，称为 \emph{基本块} ，每条边表示到另一个块的跳转。
\LangCVar{} 的 \LangCIf{} 的 \key{CProgram} 结构包含一个控制流图，表示为一个将标签映射到基本块的列表。每个基本块都由 $\Tail$ 非终端表示。

图~\ref{fig:explicate-control-s1-38} 显示示例程序中
\code{remove-complex-opera*} 通道和
\code{explicate-control} 通道的输出。遍历输出程序，然后讨论算法。
%
按照
\code{remove-complex-opera*} 输出中的求值顺序，首先对 \code{(read)}
进行两次调用，然后对内部 \key{if} 谓词中的比较 \lstinline{(< x 1)} 进行调用。在 \code{explicate-control} 的输出中，在标记为 \code{start} 的块中，是两个赋值语句，后面跟着一个
\code{if} 语句，该语句分支到 \code{block40} 或
\code{block41} 。与这些标签相关的块分别包含代码 \lstinline{(eq? x 0)} 和 \lstinline{(eq? x 2)} 的翻译。特别地，以比较 \lstinline{(eq? x 0)}  开始 \code{block40} ，然后分支到 \code{block38} 或
\code{block39} ，这是外部 \key{if} 的两个分支，即
\lstinline{(+ y 2)} 和 \lstinline{(+ y 10)} 。
\code{block41} 的情况也类似。

\begin{figure}[tbp]
\begin{tabular}{lll}
\begin{minipage}{0.4\textwidth}
% cond_test_41.rkt
\begin{lstlisting}
(let ([x (read)])
   (let ([y (read)])
      (if (if (< x 1)
             (eq? x 0)
             (eq? x 2))
         (+ y 2)
         (+ y 10))))
\end{lstlisting}
\hspace{40pt}$\Downarrow$
\begin{lstlisting}
(let ([x (read)])
   (let ([y (read)])
      (if (if (< x 1)
             (eq? x 0)
             (eq? x 2))
         (+ y 2)
         (+ y 10))))
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.55\textwidth}
\begin{lstlisting}
start:
    x = (read);
    y = (read);
    if (< x 1) goto block40;
    else goto block41;
block40:
    if (eq? x 0) goto block38;
    else goto block39;
block41:
    if (eq? x 2) goto block38;
    else goto block39;
block38:
    return (+ y 2);
block39:
    return (+ y 10);
\end{lstlisting}
\end{minipage}
\end{tabular} 

\caption{通过 \code{explicate-control} 将 \LangIf{} 转换为 \LangCIf{} 。}
\label{fig:explicate-control-s1-38}
\end{figure}

%% The nice thing about the output of \code{explicate-control} is that
%% there are no unnecessary comparisons and every comparison is part of a
%% conditional jump.

%% The down-side of this output is that it includes
%% trivial blocks, such as the blocks labeled \code{block92} through
%% \code{block95}, that only jump to another block. We discuss a solution
%% to this problem in Section~\ref{sec:opt-jumps}.

回想一下，在~\ref{sec:explicate-control-Rvar} 节中，使用两个相互递归的函数， \code{explicate-tail} 和 \code{explicate-assign}
来实现 \LangVar{} 的 \code{explicate-control} 。前一个函数在尾部位置转换表达式，而后一个函数在
\key{let} 的右侧转换表达式。随着在 \LangIf{} 中添加 \key{if} 表达式，我们有一种新的位置需要处理： \key{if} 语句的谓语位置。我们需要另一个函数， \code{explicate-pred} 它需要一个 \LangIf{} 表达式，然后为 then-branch 和
else-branch 分配两个块。 \code{explicate-pred} 的输出是一个块。
%
在下面的段落中，讨论\code{explicate-pred} 函数的具体情况，以及
\code{explicate-tail} 和 \code{explicate-assign} 函数的补充。

\begin{figure}[tbp]
\begin{lstlisting}
(define (explicate-pred cnd thn els)
  (match cnd
    [(Var x) ___]
    [(Let x rhs body) ___]
    [(Prim 'not (list e)) ___]
    [(Prim op es) #:when (or (eq? op 'eq?) (eq? op '<))
     (IfStmt (Prim op arg*) (force (block->goto thn))
              (force (block->goto els)))]
    [(Bool b) (if b thn els)]
    [(If cnd^ thn^ els^) ___]
    [else (error "explicate-pred unhandled case" cnd)]))
\end{lstlisting}
\caption{ \key{explicate-pred} 辅助功能的骨架。}
\label{fig:explicate-pred}
\end{figure}

 \code{explicate-pred} 函数的框架如图~\ref{fig:explicate-pred} 所示。对于每一个可以有 \code{Boolean} 类型的表达式，它都有大小写。在这里详细介绍几个案例，其余的留给读者。这个函数的输入是一个表达式和两个块， \code{thn} 和 \code{els} ，用于封闭 \key{if} 的两个分支。
%
考虑图~\ref{fig:explicate-pred} 中布尔常量的情况。执行一种部分计算\index{partial evaluation} 并根据常数是真还是假输出 \code{thn}
或 \code{els} 分支。这个例子说明有时会丢弃输入到 \code{explicate-pred} 中的 \code{thn}
或 \code{els} 块。

 \code{explicate-pred} 中 \key{if} 的例子特别具有启发性，因为它处理上面讨论的关于嵌套的 \key{if} 表达式的挑战
(图~\ref{fig:explicate-control-s1-38}) 。 \key{if} 的 \lstinline{thn^} 和
\lstinline{els^} 分支从当前上下文继承它们的上下文，即谓词上下文。所以应该递归应用 \code{explicate-pred} 到 \lstinline{thn^} 和
\lstinline{els^} 分支。对于这两个递归调用，传递
\code{thn} 和 \code{els} 作为额外参数。因此， \code{thn}
和 \code{els}可以使用两次，每次在递归调用中使用一次。如前所述，为了避免代码重复，需要将它们添加到控制流图中，以便可以通过名称引用它们并使用 \key{goto} 执行它们。然而，正如在上面的布尔常量案例中所看到的，块 \code{thn} 和 \code{els} 可能根本不会被使用，如果它们最终被丢弃，不想过早地将它们添加到控制流图中。

这个难题的解决方案是使用 \emph{惰性求值}\index{lazy evaluation}\citep{Friedman:1976aa} 来延迟将块添加到控制流图中，直到我们知道将使用它们的点。Racket 通过
\href{https://docs.racket-lang.org/reference/Delayed_Evaluation.html}{\code{racket/promise}}
包提供对惰性求值的支持。表达式 \key{(delay} $e_1 \ldots e_n$\key{)}
\index{delay} 创建一个 \emph{承诺}\index{promise} ，其中表达式的求值被推迟。当 \key{(force}
$p$\key{)}\index{force} 第一次应用于承诺 $p$ 时，表达式 $e_1 \ldots e_n$ 被计算，
$e_n$ 的结果被缓存在承诺中并返回。如果 \code{force} 再次应用于相同的承诺，则返回缓存的结果。
如果将 \code{force} 应用于不是承诺的参数，则
\code{force} 只会返回该参数。

对函数 \code{explicate-pred} 和 \code{explicate-assign} 的输入和输出块以及 \code{explicate-tail} 的输出块使用惰性求值。所以它们不是拿回方块，而是拿回承诺。此外，当遇到一个区块可能被多次使用的情况时，例如在 \code{explicate-pred} 的 \code{if} 情况下，将承诺转换为一个新的承诺，该新的承诺会将区块添加到 控制流图并返回 \code{goto} 。下面的辅助函数 \code{block->goto} 将完成此任务。它以 \code{delay} 开始，以创造一个承诺。当这个承诺被强迫的时候，这个承诺就会强迫原来的承诺。如果返回 \code{goto} (因为块已经添加到控制流图中) ，则返回
\code{goto} 。否则，使用另一个名为 \code{add-node} 的辅助函数将块添加到控制流图中。该函数返回新块的标签，用它来创建
\code{goto} 。
\begin{lstlisting}
(define (block->goto block)
  (delay
    (define b (force block))
    (match b
      [(Goto label) (Goto label)]
      [else (Goto (add-node b))])))
\end{lstlisting}

回到 \code{explicate-pred}
的讨论(图~\ref{fig:explicate-pred}) ，考虑比较运算符的情况。这是递归函数的基本情况之一，所以我们将比较转换为 \code{if} 语句。将
\code{block->goto} 应用于 \code{thn} 和 \code{els} 以获得两个承诺，这两个承诺将把then添加到控制流图中，可以立即进行
\code{force} 获得
\code{if} 语句分支中的两个 goto 。

%% Getting back to the case for \code{if} in \code{explicate-pred}, we
%% make the recursive calls to \code{explicate-pred} on the ``then'' and
%% ``else'' branches with the arguments \code{(block->goto} $B_1$\code{)}
%% and \code{(block->goto} $B_2$\code{)}. Let $B_3$ and $B_4$ be the
%% results from the two recursive calls.  We complete the case for
%% \code{if} by recursively apply \code{explicate-pred} to the condition
%% of the \code{if} with the promised blocks $B_3$ and $B_4$ to obtain
%% the result $B_5$.
%% \[
%% (\key{if}\; \itm{cnd}\; \itm{thn}\; \itm{els})
%% \quad\Rightarrow\quad
%% B_5
%% \]

 \code{explicate-tail} 和 \code{explicate-assign} 函数需要额外的布尔常量和 \key{if} 。
%
在 \code{if} 的情况下，两个分支继承当前上下文，所以在 \code{explicate-tail} 中它们处于尾部位置，在
\code{explicate-assign} 中它们处于赋值位置。在两次递归调用中都使用 \code{explicate-assign} 的
\code{cont} 参数，所以请确保使用 \code{block->goto} 。

%% In the case for \code{if} in \code{explicate-tail}, the two branches
%% inherit the current context, so they are in tail position. Thus, the
%% recursive calls on the ``then'' and ``else'' branch should be calls to
%% \code{explicate-tail}.
%% %
%% We need to pass $B_0$ as the accumulator argument for both of these
%% recursive calls, but we need to be careful not to duplicate $B_0$.
%% Thus, we first apply \code{block->goto} to $B_0$ so that it gets added
%% to the control-flow graph and obtain a promised goto $G_0$.
%% %
%% Let $B_1$ be the result of \code{explicate-tail} on the ``then''
%% branch and $G_0$ and let $B_2$ be the result of \code{explicate-tail}
%% on the ``else'' branch and $G_0$.  Let $B_3$ be the result of applying
%% \code{explicate-pred} to the condition of the \key{if}, $B_1$, and
%% $B_2$.  Then the \key{if} as a whole translates to promise $B_3$.
%% \[
%%     (\key{if}\; \itm{cnd}\; \itm{thn}\; \itm{els}) \quad\Rightarrow\quad B_3
%% \]

%% In the above discussion, we use the metavariables $B_1$, $B_2$, and
%% $B_3$ to refer to blocks for the purposes of our discussion, but they
%% should not be confused with the labels for the blocks that appear in
%% the generated code. We initially construct unlabeled blocks; we only
%% attach labels to blocks when we add them to the control-flow graph, as
%% we see in the next case.

%% Next consider the case for \key{if} in the \code{explicate-assign}
%% function. The context of the \key{if} is an assignment to some
%% variable $x$ and then the control continues to some promised block
%% $B_1$.  The code that we generate for both the ``then'' and ``else''
%% branches needs to continue to $B_1$, so to avoid duplicating $B_1$ we
%% apply \code{block->goto} to it and obtain a promised goto $G_1$.  The
%% branches of the \key{if} inherit the current context, so they are in
%% assignment positions.  Let $B_2$ be the result of applying
%% \code{explicate-assign} to the ``then'' branch, variable $x$, and
%% $G_1$.  Let $B_3$ be the result of applying \code{explicate-assign} to
%% the ``else'' branch, variable $x$, and $G_1$. Finally, let $B_4$ be
%% the result of applying \code{explicate-pred} to the predicate
%% $\itm{cnd}$ and the promises $B_2$ and $B_3$. The \key{if} as a whole
%% translates to the promise $B_4$.
%% \[
%% (\key{if}\; \itm{cnd}\; \itm{thn}\; \itm{els}) \quad\Rightarrow\quad B_4
%% \]
%% This completes the description of \code{explicate-control} for \LangIf{}.


 \code{shrink} 通过转换逻辑操作的方式，如 \code{and} 和 \code{or} 可以影响由 \code{explicate-control} 生成的代码的质量。例如，考虑下面的程序。
% cond_test_21.rkt
\begin{lstlisting}
(if (and (eq? (read) 0) (eq? (read) 1))
    0
    42)  
\end{lstlisting}
 \code{and} 操作应该转换成一些东西，
\code{explicate-pred} 函数仍然可以分析和下降，以达到潜在的 \code{eq?} 条件。理想情况下，
\code{explicate-control} 通道应该为上面的程序生成类似如下的代码。
\begin{center}
\begin{lstlisting}
start:
    tmp1 = (read);
    if (eq? tmp1 0) goto block40;
    else goto block39;
block40:
    tmp2 = (read);
    if (eq? tmp2 1) goto block38;
    else goto block39;
block38:
    return 0;
block39:
    return 42;
\end{lstlisting}
\end{center}

\begin{exercise}\normalfont
通过在 \code{explicate-tail} 和
\code{explicate-assign} 中添加布尔常量和 \key{if} 来实现 \code{explicate-control} 的通道。为谓词上下文实现辅助函数
\code{explicate-pred} 。
%
创建测试用例，测试代码中的所有新用例。
%
将以下条目添加到
\code{run-tests.rkt} 中的  \code{passes}  列表中，然后运行此脚本来测试编译器。
\begin{lstlisting}
(list "explicate-control" explicate-control interp-Cif type-check-Cif)
\end{lstlisting}

\end{exercise}


\section{选择指令}
\label{sec:select-Rif}
\index{instruction selection}

 \code{select-instructions} 通道将 \LangCIf{} 转换为
\LangXIfVar{} 。回想一下，使用三个辅助函数来实现这个通道，分别是非终端 $\Atm$ 、
$\Stmt$ 和 $\Tail$ 。

对于 $\Atm$ ，有一些新的布尔值案例。通常的方法将它们编码为整数，true为1，false为0。
\[
\key{\#t} \Rightarrow \key{1}
\qquad
\key{\#f} \Rightarrow \key{0}
\]

对于 $\Stmt$ ，讨论几个案例。正如在本节开始时讨论的那样， \code{not} 操作可以通过 \code{xorq} 实现。给定赋值
$\itm{var}$ \key{=} \key{(not} $\Atm$\key{);} ，如果左边的 $\itm{var}$ 与
 $\Atm$ 相同，那么只要 \code{xorq} 就足够了。
\[
\Var~\key{=}~ \key{(not}\; \Var\key{);}
\quad\Rightarrow\quad
\key{xorq}~\key{\$}1\key{,}~\Var
\]
否则，需要一个 \key{movq} 来适应x86的就地更新语义。将 $\Arg$ 设为 $\Atm$ 转换为x86的结果。然后我们有
\[
\Var~\key{=}~ \key{(not}\; \Atm\key{);}
\quad\Rightarrow\quad
\begin{array}{l}
\key{movq}~\Arg\key{,}~\Var\\
\key{xorq}~\key{\$}1\key{,}~\Var
\end{array}
\]

接下来考虑 \code{eq?} 和小于比较的情况。
由于上面讨论的 \key{cmpq} 指令的不寻常性质，将这些操作转换到x86稍微有些困难。建议将 \code{eq?} 中的赋值翻译成以下三个指令序列。 \\
\begin{tabular}{lll}
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
|$\Var$| = (eq? |$\Atm_1$| |$\Atm_2$|);
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
cmpq |$\Arg_2$|, |$\Arg_1$|
sete %al
movzbq %al, |$\Var$|
\end{lstlisting}
\end{minipage}
\end{tabular}  \\

关于 $\Tail$ 非终端，有两个新的例子： \key{goto}
和 \key{if} 语句。两者转换到x86都很简单。一个 \key{goto} 变成一个跳转指令。
\[
\key{goto}\; \ell\key{;} \quad \Rightarrow \quad \key{jmp}\;\ell
\]
 \key{if} 语句变成一个比较指令，后面跟着一个条件跳转(对于" then "分支来说)，而跌落是一个常规跳转(对于" else "分支来说)。\\
\begin{tabular}{lll}
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
if (eq? |$\Atm_1$| |$\Atm_2$|) goto |$\ell_1$|;
else goto |$\ell_2$|;
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
cmpq |$\Arg_2$|, |$\Arg_1$|
je |$\ell_1$|
jmp |$\ell_2$|
\end{lstlisting}
\end{minipage}
\end{tabular}  \\

\begin{exercise}\normalfont
扩展你的 \code{select-instructions} 通道来处理 \LangIf{} 语言的新特性。
%
将以下条目添加到\code{run-tests.rkt} 中的 \code{passes} 列表中
\begin{lstlisting}
(list "select-instructions" select-instructions interp-pseudo-x86-1)
\end{lstlisting}
%
运行该脚本在所有测试程序上测试编译器。
\end{exercise}

\section{寄存器分配}
\label{sec:register-allocation-Rif}

\index{register allocation}
 \LangIf{} 所需的变化影响活性分析、构建干扰图和分配域，但图着色算法本身不改变。

\subsection{活性分析}
\label{sec:liveness-analysis-Rif}
\index{liveness analysis}

回想一下，对于 \LangVar{} ，我们为单个基本块实现活性分析(第~\ref{sec:liveness-analysis-Rvar} 节)。 通过在 \LangIf{} 中添加 \key{if} 表达式， \code{explicate-control}
生成许多基本块，这些块被安排在一个控制流图中。建议创建一个新的辅助函数，名为
\code{uncover-live-CFG} ，将活性分析应用到控制流图。

第一个问题是：应该以什么顺序处理控制流图中的基本块? 回想一下，要在一个基本块上执行活性分析，需要知道它的live-after 集合。如果一个基本块没有继任者(即在控制流图中没有外边)，那么它就有一个空的live-after集，可以立即对它应用live-after分析。如果一个基本块有一些后继体，那么需要先完成这些块的活性分析。在图论中，如果一个节点的每个顶点在其后续顶点之前，那么这个节点序列就是 \emph{拓扑顺序}\index{topological order} 。我们需要反义词，这样就可以在计算拓扑顺序之前转置这个图。
%
用 Racket \code{graph} 包的 \code{tsort} 和 \code{transpose} 函数来实现这一点。
%
另外，拓扑顺序只有在图中不包含任何循环时才保证存在。这确实是我们从 \LangIf{} 程序生成的控制流图的情况。
然而，在第~\ref{ch:Rwhile} 章中，在 \LangLoop{} 中添加循环，并学习如何在控制流图中处理循环。

您需要构造一个有向图来表示控制流图。不要使用 \code{graph} 包中的 \code{directed-graph} ，因为它最多只允许在每一对顶点之间有一条边，但是一个控制流图可能在一对顶点之间有多条边。支持代码中的 \code{multigraph.rkt} 文件实现一种图表示，允许一对顶点之间有多条边。

下一个问题是如何分析跳跃指令。回想一下，在第~\ref{sec:liveness-analysis-Rvar} 节中，我们维护一个名为
\code{label->live} 的列表，它将每个标签映射到其块开始处的live位置集。使用 \code{label->live} 来确定每个 $\JMP{\itm{label}}$ 指令的live-before设置。现在有许多基本的块， \code{label->live} 需要在处理这些块时进行更新。特别是，在对一个块执行活性分析之后，取其第一个指令的 live-before 集合，并将其与\code{label->live} 中的块的标签相关联。

在 \LangXIfVar{} 中，还需要处理条件跳转
$\JMPIF{\itm{cc}}{\itm{label}}$ 。这条指令的动态分析特别有趣，因为在编译期间，不知道条件跳转将朝哪个方向发展。因此，不知道是否使用live-before设置为下面的指令或live-before设置为 $\itm{label}$ 。然而，如果将更多的位置划分为实时位置，而不是在特定的指令执行过程中实际运行的位置，则不会对编译器的正确性造成损害。因此，可以从下面的指令和
 \code{label->live} 中的 $\itm{label}$ 映射中获得live-before集合的并集。

用于计算指令参数中的变量和用于计算指令从 ($R$)
或写入 ($W$) 的变量的辅助函数需要被更新，以处理 \LangXIfVar{} 中的新类型的参数和指令。

\begin{exercise}\normalfont
更新 \code{uncover-live} 通道，并实现
\code{uncover-live-CFG} 辅助函数，将活性分析应用到控制流图中。将以下条目添加到
 \code{run-tests.rkt} 脚本中的 \code{passes} 列表中。
\begin{lstlisting}
(list "uncover-live" uncover-live interp-pseudo-x86-1)
\end{lstlisting}
\end{exercise}

\subsection{构建干涉图}
\label{sec:build-interference-Rif}

 \LangXIfVar{} 中的许多新指令可以用与 \LangXVar{} 中的指令相同的方式处理。因此，如果代码已经相当通用，那么就不需要更改代码来处理新的指令。如果代码不够通用，建议将代码更改为更通用的代码。例如，可以将每种指令的读写集计算分解为两个辅助函数。

注意，与 \key{movq} 指令类似， \key{movzbq} 指令需要一些特殊的注意事项。参见~\ref{sec:build-interference} 节规则1。

\begin{exercise}\normalfont
更新 \LangXIfVar{} 的 \code{build-interference} 通道，并将以下条目添加到 \code{run-tests.rkt} 的 \code{passes} 列表中。
\begin{lstlisting}
(list "build-interference" build-interference interp-pseudo-x86-1)
(list "allocate-registers" allocate-registers interp-x86-1)
\end{lstlisting}
运行该脚本在所有的 \LangIf{} 测试程序上测试编译器。
\end{exercise}


\section{补丁说明}

 \key{cmpq} 指令的第二个参数不能是立即值(例如整数)。因此，如果正在比较两个即时对象，建议插入一个 \key{movq} 指令，将第二个参数放入 \key{rax} 中。另外，记住，指令最多只能有一个内存引用。
%
 \key{movzbq} 的第二个参数必须是一个寄存器。
%
对于跳转指令没有特殊的限制。

\begin{exercise}\normalfont
%
更新 \LangXIfVar{} 的 \code{patch-instructions} 通道。
%  
将以下条目添加到 \code{run-tests.rkt} 的 \code{passes} 列表中，然后运行此脚本来测试编译器。
\begin{lstlisting}
(list "patch-instructions" patch-instructions interp-x86-1)
\end{lstlisting}
\end{exercise}

\begin{figure}[tbp]
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (Rif) at (0,2)  {\large \LangIf{}};
\node (Rif-2) at (3,2)  {\large \LangIf{}};
\node (Rif-3) at (6,2)  {\large \LangIf{}};
\node (Rif-4) at (9,2)  {\large \LangIf{}};
\node (Rif-5) at (12,2)  {\large \LangIf{}};
\node (C1-1) at (3,0)  {\large \LangCIf{}};

\node (x86-2) at (3,-2)  {\large \LangXIfVar{}};
\node (x86-2-1) at (3,-4)  {\large \LangXIfVar{}};
\node (x86-2-2) at (6,-4)  {\large \LangXIfVar{}};
\node (x86-3) at (6,-2)  {\large \LangXIfVar{}};
\node (x86-4) at (9,-2) {\large \LangXIf{}};
\node (x86-5) at (9,-4) {\large \LangXIf{}};

\path[->,bend left=15] (Rif) edge [above] node {\ttfamily\footnotesize type-check} (Rif-2);
\path[->,bend left=15] (Rif-2) edge [above] node {\ttfamily\footnotesize shrink} (Rif-3);
\path[->,bend left=15] (Rif-3) edge [above] node {\ttfamily\footnotesize uniquify} (Rif-4);
\path[->,bend left=15] (Rif-4) edge [above] node {\ttfamily\footnotesize remove-complex.} (Rif-5);
\path[->,bend left=15] (Rif-5) edge [left] node {\ttfamily\footnotesize explicate-control} (C1-1);
\path[->,bend right=15] (C1-1) edge [left] node {\ttfamily\footnotesize select-instructions} (x86-2);
\path[->,bend left=15] (x86-2) edge [right] node {\ttfamily\footnotesize uncover-live} (x86-2-1);
\path[->,bend right=15] (x86-2-1) edge [below] node {\ttfamily\footnotesize build-inter.} (x86-2-2);
\path[->,bend right=15] (x86-2-2) edge [right] node {\ttfamily\footnotesize allocate-reg.} (x86-3);
\path[->,bend left=15] (x86-3) edge [above] node {\ttfamily\footnotesize patch-instr.} (x86-4);
\path[->,bend left=15] (x86-4) edge [right] node {\ttfamily\footnotesize print-x86 } (x86-5);
\end{tikzpicture}
\caption{带条件的 \LangIf{} 语言的通道图。}
 \label{fig:Rif-passes}
\end{figure}

图~\ref{fig:Rif-passes} 列出编译 \LangIf{} 所需的所有步骤。

\section{一个例子的翻译}

图~\ref{fig:if-example-x86} 是一个简单的
\LangIf{} 翻译成x86的示例程序，显示
\code{explicate-control}, \code{select-instructions} 的结果，以及最终的x86汇编代码。

\begin{figure}[tbp]
\begin{tabular}{lll}
\begin{minipage}{0.4\textwidth}
% cond_test_20.rkt
\begin{lstlisting}
(if (eq? (read) 1) 42 0)
\end{lstlisting}
$\Downarrow$
\begin{lstlisting}
start:
    tmp7951 = (read);
    if (eq? tmp7951 1)
       goto block7952;
    else
       goto block7953;
block7952:
    return 42;
block7953:
    return 0;
\end{lstlisting}
$\Downarrow$
\begin{lstlisting}
start:
    callq read_int
    movq %rax, tmp7951
    cmpq $1, tmp7951
    je block7952
    jmp block7953
block7953:
    movq $0, %rax
    jmp conclusion
block7952:
    movq $42, %rax
    jmp conclusion
\end{lstlisting}
\end{minipage}
&
$\Rightarrow\qquad$
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
start:
	callq	read_int
	movq	%rax, %rcx
	cmpq	$1, %rcx
	je block7952
	jmp block7953
block7953:
	movq	$0, %rax
	jmp conclusion
block7952:
	movq	$42, %rax
	jmp conclusion

	.globl main
main:
	pushq	%rbp
	movq	%rsp, %rbp
	pushq	%r13
	pushq	%r12
	pushq	%rbx
	pushq	%r14
	subq	$0, %rsp
	jmp start
conclusion:
	addq	$0, %rsp
	popq	%r14
	popq	%rbx
	popq	%r12
	popq	%r13
	popq	%rbp
	retq
\end{lstlisting}
\end{minipage}
\end{tabular}
\caption{将 \key{if} 表达式编译到x86的示例。}
\label{fig:if-example-x86}
\end{figure}


\section{挑战:删除跳转}
\label{sec:opt-jumps}

%% Recall that in the example output of \code{explicate-control} in
%% Figure~\ref{fig:explicate-control-s1-38}, \code{block57} through
%% \code{block60} are trivial blocks, they do nothing but jump to another
%% block. The first goal of this challenge assignment is to remove those
%% blocks. Figure~\ref{fig:optimize-jumps} repeats the result of
%% \code{explicate-control} on the left and shows the result of bypassing
%% the trivial blocks on the right. Let us focus on \code{block61}.  The
%% \code{then} branch jumps to \code{block57}, which in turn jumps to
%% \code{block55}. The optimized code on the right of
%% Figure~\ref{fig:optimize-jumps} bypasses \code{block57}, with the
%% \code{then} branch jumping directly to \code{block55}. The story is
%% similar for the \code{else} branch, as well as for the two branches in
%% \code{block62}. After the jumps in \code{block61} and \code{block62}
%% have been optimized in this way, there are no longer any jumps to
%% blocks \code{block57} through \code{block60}, so they can be removed.

%% \begin{figure}[tbp]
%% \begin{tabular}{lll}
%% \begin{minipage}{0.4\textwidth}
%% \begin{lstlisting}
%% block62:
%%     tmp54 = (read);
%%     if (eq? tmp54 2) then
%%        goto block59;
%%     else
%%        goto block60;
%% block61:
%%     tmp53 = (read);
%%     if (eq? tmp53 0) then
%%        goto block57;
%%     else
%%        goto block58;
%% block60:
%%     goto block56;
%% block59:
%%     goto block55;
%% block58:
%%     goto block56;
%% block57:
%%     goto block55;
%% block56:
%%     return (+ 700 77);
%% block55:
%%     return (+ 10 32);
%% start:
%%     tmp52 = (read);
%%     if (eq? tmp52 1) then
%%        goto block61;
%%     else
%%        goto block62;
%% \end{lstlisting}
%% \end{minipage}
%% &
%% $\Rightarrow$
%% &
%% \begin{minipage}{0.55\textwidth}
%% \begin{lstlisting}
%% block62:
%%     tmp54 = (read);
%%     if (eq? tmp54 2) then
%%        goto block55;
%%     else
%%        goto block56;
%% block61:
%%     tmp53 = (read);
%%     if (eq? tmp53 0) then
%%        goto block55;
%%     else
%%        goto block56;
%% block56:
%%     return (+ 700 77);
%% block55:
%%     return (+ 10 32);
%% start:
%%     tmp52 = (read);
%%     if (eq? tmp52 1) then
%%        goto block61;
%%     else
%%        goto block62;
%% \end{lstlisting}
%% \end{minipage}
%% \end{tabular}
%% \caption{Optimize jumps by removing trivial blocks.}
%% \label{fig:optimize-jumps}
%% \end{figure}

%% The name of this pass is \code{optimize-jumps}.  We recommend
%% implementing this pass in two phases. The first phrase builds a hash
%% table that maps labels to possibly improved labels. The second phase
%% changes the target of each \code{goto} to use the improved label.  If
%% the label is for a trivial block, then the hash table should map the
%% label to the first non-trivial block that can be reached from this
%% label by jumping through trivial blocks.  If the label is for a
%% non-trivial block, then the hash table should map the label to itself;
%% we do not want to change jumps to non-trivial blocks.

%% The first phase can be accomplished by constructing an empty hash
%% table, call it \code{short-cut}, and then iterating over the control
%% flow graph. Each time you encouter a block that is just a \code{goto},
%% then update the hash table, mapping the block's source to the target
%% of the \code{goto}. Also, the hash table may already have mapped some
%% labels to the block's source, to you must iterate through the hash
%% table and update all of those so that they instead map to the target
%% of the \code{goto}.

%% For the second phase, we recommend iterating through the $\Tail$ of
%% each block in the program, updating the target of every \code{goto}
%% according to the mapping in \code{short-cut}.

%% \begin{exercise}\normalfont
%%   Implement the \code{optimize-jumps} pass as a transformation from
%%   \LangCIf{} to \LangCIf{}, coming after the \code{explicate-control} pass.
%%   Check that \code{optimize-jumps} removes trivial blocks in a few
%%   example programs. Then check that your compiler still passes all of
%%   your tests.
%% \end{exercise}

有一个优化跳转的机会，这在图~\ref{fig:if-example-x86} 的例子中很明显。 \code{start} 块以跳转到 \code{block7953} 结束，在程序的其余部分中没有其他跳转到
\code{block7953} 。在这种情况下，可以通过合并 \code{block7953}
到前面的块来避免运行时开销，在这种情况下是 \code{start} 块。
图~\ref{fig:remove-jumps} 左边显示
\code{select-instructions} 的输出，右边显示优化的结果。

\begin{figure}[tbp]
\begin{tabular}{lll}
\begin{minipage}{0.5\textwidth}
% cond_test_20.rkt
\begin{lstlisting}
start:
    callq read_int
    movq %rax, tmp7951
    cmpq $1, tmp7951
    je block7952
    jmp block7953
block7953:
    movq $0, %rax
    jmp conclusion
block7952:
    movq $42, %rax
    jmp conclusion
\end{lstlisting}
\end{minipage}
&
$\Rightarrow\qquad$
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
start:
    callq read_int
    movq %rax, tmp7951
    cmpq $1, tmp7951
    je block7952
    movq $0, %rax
    jmp conclusion
block7952:
    movq $42, %rax
    jmp conclusion
\end{lstlisting}
\end{minipage}
\end{tabular}
\caption{通过删除不必要的跳转来合并基本块。}
\label{fig:remove-jumps}
\end{figure}

\begin{exercise}\normalfont
%
实现一个名为 \code{remove-jumps} 的通道，当只有一个前面的块时，它将基本块合并到其前面的基本块中。这个通道应该从 \LangXIfVar{} 转换到 \LangXIfVar{} 。
%  
在 \code{run-tests.rkt} 脚本中，将以下条目添加到 \code{allocate-registers}
和 \code{patch-instructions} 之间的 \code{passes} 列表中。
\begin{lstlisting}
(list "remove-jumps" remove-jumps interp-pseudo-x86-1)
\end{lstlisting}
运行此脚本来测试编译器。
%
检查 \code{remove-jumps} 是否完成在几个测试程序中合并基本块的目标。
\end{exercise}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{元组和垃圾收集}
\label{ch:Rvec}
\index{tuple}
\index{vector}

\margincomment{\scriptsize To do: Flesh out this chapter, e.g., make sure
  all the IR grammars are spelled out! \\ --Jeremy}
\margincomment{\scriptsize Be more explicit about how to deal with
  the root stack. \\ --Jeremy}

在本章中，研究可变元组(在 Racket 中称为向量)的实现。这个语言特性是第一个使用计算机 \emph{堆}\index{heap} 的特性，因为 Racket 元组的生存期是不确定的，也就是说，从程序员的角度来看，元组是永远存在的。当然，从实现者的角度来看，当不再需要与元组相关的空间时，回收空间是很重要的，这就是为什么在本章也要学习 \emph{垃圾回收} 技术。

~\ref{sec:r3} 节介绍 \LangVec{} 语言，包括它的解释器和类型检查器。 \LangVec{} 语言通过向量和 Racket 的 \code{void} 值扩展第~\ref{ch:Rif} 章的 \LangIf{} 语言。包含后者的原因是
\code{vector-set!} 操作返回一个类型为
\code{Void}\footnote{Racket 的 \code{Void} 类型对应于编程语言文献中所谓的 \code{Unit} 类型。 Racket 的 \code{Void} 类型由一个单独的值
  \code{void} 组成，在文献 ~\citep{Pierce:2002hj} 中对应于 \code{unit} 或 \code{()}。} 的值。

第~\ref{sec:GC} 节描述一种基于在堆的两个部分之间来回复制活动对象的垃圾收集算法。垃圾收集器需要与编译器协调，以便它可以看到所有的 \emph{root} 指针，即寄存器或过程调用堆栈上的指针。

第~\ref{sec:expose-allocation} 至 \ref{sec:print-x86-gc}
节讨论对编译器通道的所有必要修改和添加，包括名为 \code{expose-allocation} 新的编译器通道。

\section{ \LangVec{} 语言}
\label{sec:r3}

图~\ref{fig:Rvec-concrete-syntax} 定义
\LangVec{} 的具体语法，图~\ref{fig:Rvec-syntax} 定义抽象语法。
\LangVec{} 语言包括三种新形式： \code{vector} 用于创建元组， \code{vector-ref} 用于读取元组中的元素，
\code{vector-set!} 用于写入元组中的元素。图~\ref{fig:vector-eg} 中的程序显示元组在 Racket 中的使用。创建一个3元组 \code{t} 和一个1元组，它们存储在3元组的下标 $2$ 处，证明元组是一等值。 \code{t} 
的下标 $1$ 处的元素是 \code{\#t} ，因此取 \key{if} 的“then”分支。 \code{t} 下标 $0$ 处的元素是
\code{40} ，再加上 \code{2} ，即1元组下标 $0$ 处的元素。所以这个程序的结果是 \code{42} 。

\begin{figure}[tbp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{lcl}
  \Type &::=& \gray{\key{Integer} \mid \key{Boolean}}
  \mid \LP\key{Vector}\;\Type\ldots\RP \mid \key{Void}\\
  \Exp &::=& \gray{  \Int \mid \CREAD{} \mid \CNEG{\Exp} \mid \CADD{\Exp}{\Exp} \mid \CSUB{\Exp}{\Exp} }  \\
  &\mid&  \gray{  \Var \mid \CLET{\Var}{\Exp}{\Exp}  }\\
  &\mid& \gray{ \key{\#t} \mid \key{\#f} 
   \mid \LP\key{and}\;\Exp\;\Exp\RP 
   \mid \LP\key{or}\;\Exp\;\Exp\RP
   \mid \LP\key{not}\;\Exp\RP } \\
  &\mid& \gray{  \LP\itm{cmp}\;\Exp\;\Exp\RP 
   \mid \CIF{\Exp}{\Exp}{\Exp}  } \\
  &\mid& \LP\key{vector}\;\Exp\ldots\RP 
   \mid \LP\key{vector-length}\;\Exp\RP \\
  &\mid& \LP\key{vector-ref}\;\Exp\;\Int\RP
   \mid \LP\key{vector-set!}\;\Exp\;\Int\;\Exp\RP \\
  &\mid& \LP\key{void}\RP \mid \LP\key{has-type}~\Exp~\Type\RP\\
  \LangVec{} &::=& \Exp
\end{array}
\]
\end{minipage}
}
\caption{ \LangVec{} 的具体语法，扩展 \LangIf{}
  (图~\ref{fig:Rif-concrete-syntax})。}
\label{fig:Rvec-concrete-syntax}
\end{figure}

\begin{figure}[tbp]
\begin{lstlisting}
    (let ([t (vector 40 #t (vector 2))])
      (if (vector-ref t 1)
          (+ (vector-ref t 0)
             (vector-ref (vector-ref t 2) 0))
          44))
\end{lstlisting}
\caption{创建元组并从中读取的示例程序}
\label{fig:vector-eg}
\end{figure}

\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{lcl}
  \itm{op} &::=& \ldots \mid \code{vector} \mid \code{vector-length} \\
\Exp &::=& \gray{ \INT{\Int} \mid \VAR{\Var} \mid \LET{\Var}{\Exp}{\Exp} } \\
     &\mid& \gray{ \PRIM{\itm{op}}{\Exp\ldots}
      \mid \BOOL{\itm{bool}}
      \mid \IF{\Exp}{\Exp}{\Exp} } \\
    &\mid& \VECREF{\Exp}{\INT{\Int}}\\
    &\mid& \VECSET{\Exp}{\INT{\Int}}{\Exp} \\
     &\mid& \VOID{} \mid \LP\key{HasType}~\Exp~\Type \RP \\
  \LangVec{} &::=& \PROGRAM{\key{'()}}{\Exp}
\end{array}
\]
\end{minipage}
}
\caption{ \LangVec{} 的抽象语法。}
\label{fig:Rvec-syntax}
\end{figure}

\index{allocate}
\index{heap allocate}
元组是我们第一次遇到堆分配的数据，这引发几个有趣的问题。首先，变量绑定在处理元组时执行浅拷贝，这意味着不同的变量可以引用相同的元组，也就是说，不同的变量可以是相同实体的 \emph{别名} 。考虑下面的例子，其中 \code{t1} 和 \code{t2} 都引用同一个元组。
因此，在从 \code{t1} 引用元组时， \code{t2} 的变化是可见的，因此这个程序的结果是 \code{42} 。
\index{alias}\index{mutation}
\begin{center}
\begin{minipage}{0.96\textwidth}
\begin{lstlisting}
(let ([t1 (vector 3 7)])
  (let ([t2 t1])
    (let ([_ (vector-set! t2 0 42)])
      (vector-ref t1 0))))
\end{lstlisting}
\end{minipage}
\end{center}

下一个问题涉及元组的生命周期。当然，它们是由 \code{vector} 形式创造的，但是它们的生命周期何时结束呢？
注意， \LangVec{} 不包含删除元组的操作。此外，元组的生存期不与任何静态作用域的概念相关联。例如，下面的程序返回 \code{42} ，即使变量 \code{w} 在 \code{vector-ref} (从绑定到它的向量中读取)之前超出了作用域。
\begin{center}
\begin{minipage}{0.96\textwidth}
\begin{lstlisting}
(let ([v (vector (vector 44))])
  (let ([x (let ([w (vector 42)])
             (let ([_ (vector-set! v 0 w)])
               0))])
    (+ x (vector-ref (vector-ref v 0) 0))))
\end{lstlisting}
\end{minipage}
\end{center}

从程序员可观察行为的角度来看，元组永远存在。当然，如果它们真的永远存在，那么许多程序将耗尽内存。\footnote{ \LangVec{} 语言没有循环或递归函数，所以在 \LangVec{} 中编写一个耗尽内存的程序几乎是不可能的！} 因此， Racket 实现必须执行自动垃圾收集。

图~\ref{fig:interp-Rvec} 显示
\LangVec{} 语言的定义解释器。根据相应的Racket操作为r \LangVec{} 定义 \code{vector} 、 \code{vector-length} 、
\code{vector-ref} 和 \code{vector-set!} 操作。一个微妙的点是， \code{vector-set!}  操作返回 \code{\#<void>}
值。 \code{\#<void>} 值可以像 \LangVec{} 程序中的其他值一样传递， \code{\#<void>} 值可以与另一个 \code{\#<void>} 值进行相等比较。然而，在 \LangVec{} 中没有其他特定于 \code{\#<void>}
值的操作。相反， Racket 定义 \code{void?} 谓词，当应用于 \code{\#<void>} 时返回 \code{\#t} ，否则返回 \code{\#f} 。

\begin{figure}[tbp]
\begin{lstlisting}
(define interp-Rvec-class
  (class interp-Rif-class
    (super-new)

    (define/override (interp-op op)
      (match op
        ['eq? (lambda (v1 v2)
                (cond [(or (and (fixnum? v1) (fixnum? v2))
                           (and (boolean? v1) (boolean? v2))
                           (and (vector? v1) (vector? v2))
                           (and (void? v1) (void? v2)))
                       (eq? v1 v2)]))]
        ['vector vector]
        ['vector-length vector-length]
        ['vector-ref vector-ref]
        ['vector-set! vector-set!]
        [else (super interp-op op)]
        ))

    (define/override ((interp-exp env) e)
      (define recur (interp-exp env))
      (match e
        [(HasType e t)  (recur e)]
        [(Void)  (void)]
        [else ((super interp-exp env) e)]
        ))
    ))

(define (interp-Rvec p)
  (send (new interp-Rvec-class) interp-program p))
\end{lstlisting}
\caption{用于 \LangVec{} 语言的解释器。}
\label{fig:interp-Rvec}
\end{figure}

图~\ref{fig:type-check-Rvec} 显示 \LangVec{} 的类型检查器，它需要一些解释。分配向量时，我们需要知道向量的哪些元素是指针（即也是向量）。可以在类型检查中获得这些信息。
图~\ref{fig:type-check-Rvec} 的类型检查器不仅计算表达式的类型，还将每个创建的 \key{vector} 包装为 $(\key{HasType}~e~T)$ 形式，其中 $T$ 是向量的类型。
%
要为图 ~\ref{fig:type-check-Rvec} 中的 \code{Vector} 类型创建s表达式，使用
\href{https://docs.racket-lang.org/reference/quasiquote.html}{unquote-splicing
  operator} \code{,@} 插入列表 \code{t*} ，而不使用通常的开始和结束括号。 \index{unquote-slicing}


\begin{figure}[tp]
\begin{lstlisting}
(define type-check-Rvec-class
  (class type-check-Rif-class
    (super-new)
    (inherit check-type-equal?)

    (define/override (type-check-exp env)
      (lambda (e)
        (define recur (type-check-exp env))
        (match e
          [(Void) (values (Void) 'Void)]
          [(Prim 'vector es)
           (define-values (e* t*) (for/lists (e* t*) ([e es]) (recur e)))
           (define t `(Vector ,@t*))
           (values (HasType (Prim 'vector e*) t)  t)]
          [(Prim 'vector-ref (list e1 (Int i)))
           (define-values (e1^ t) (recur e1))
           (match t
             [`(Vector ,ts ...)
              (unless (and (0 . <= . i) (i . < . (length ts)))
                (error 'type-check "index ~a out of bounds\nin ~v" i e))
              (values (Prim 'vector-ref (list e1^ (Int i)))  (list-ref ts i))]
             [else (error 'type-check "expect Vector, not ~a\nin ~v" t e)])]
          [(Prim 'vector-set! (list e1 (Int i) arg) )
           (define-values (e-vec t-vec) (recur e1))
           (define-values (e-arg^ t-arg) (recur arg))
           (match t-vec
             [`(Vector ,ts ...)
              (unless (and (0 . <= . i) (i . < . (length ts)))
                (error 'type-check "index ~a out of bounds\nin ~v" i e))
              (check-type-equal? (list-ref ts i) t-arg e)
              (values (Prim 'vector-set! (list e-vec (Int i) e-arg^))  'Void)]
             [else (error 'type-check "expect Vector, not ~a\nin ~v" t-vec e)])]
\end{lstlisting}
\end{figure} 
\begin{figure}[tp]
\begin{lstlisting}               
          [(Prim 'vector-length (list e))
           (define-values (e^ t) (recur e))
           (match t
             [`(Vector ,ts ...)
              (values (Prim 'vector-length (list e^))  'Integer)]
             [else (error 'type-check "expect Vector, not ~a\nin ~v" t e)])]
          [(Prim 'eq? (list arg1 arg2))
           (define-values (e1 t1) (recur arg1))
           (define-values (e2 t2) (recur arg2))
           (match* (t1 t2)
             [(`(Vector ,ts1 ...)  `(Vector ,ts2 ...))  (void)]
             [(other wise)  (check-type-equal? t1 t2 e)])
           (values (Prim 'eq? (list e1 e2)) 'Boolean)]
          [(HasType (Prim 'vector es) t)
           ((type-check-exp env) (Prim 'vector es))]
          [(HasType e1 t)
           (define-values (e1^ t^) (recur e1))
           (check-type-equal? t t^ e)
           (values (HasType e1^ t) t)]
          [else ((super type-check-exp env) e)]
          )))
    ))

(define (type-check-Rvec p)
  (send (new type-check-Rvec-class) type-check-program p))
\end{lstlisting}
\caption{ \LangVec{} 语言的类型检查器。}
\label{fig:type-check-Rvec}
\end{figure}


\section{垃圾回收}
\label{sec:GC}

这里研究一个相对简单的垃圾收集算法，它是最先进的垃圾收集器的基础~\citep{Lieberman:1983aa,Ungar:1984aa,Jones:1996aa,Detlefs:2004aa,Dybvig:2006aa,Tene:2011kx} 。特别地，描述一个使用Cheney算法执行复制 ~\citep{Cheney:1970aa} 的两空间复制收集器~\citep{Wilson:1992fk} 。
\index{copying collector}
\index{two-space copying collector}
图~\ref{fig:copying-collector} 给出两空间收集器的粗粒度描述，显示两个时间步骤，在垃圾收集之前(在上面)和之后(在下面)。在一个两空间收集器中，堆分为两个部分，分别命名为 FromSpace 和 ToSpace 。最初，所有分配都转到FromSpace，直到没有足够的空间用于下一个分配请求。这时，垃圾收集器开始工作以腾出更多空间。
\index{ToSpace}
\index{FromSpace}

垃圾收集器必须小心，不要回收将来将被程序使用的元组。当然，通常不可能预测一个程序将做什么，但是我们可以通过保留所有在给定当前计算机状态下可以被 \emph{任何} 程序访问的元组来过度近似将要被使用的元组。程序可以访问地址在寄存器或过程调用堆栈上的任何元组。这些地址称为 \emph{根集}\index{root set}。此外，程序可以访问从根集传递可达的任何元组。因此，垃圾收集器可以安全地回收无法通过这种方式访问的元组。

所以垃圾收集器的目标有两个：
\begin{enumerate}
\item 保留所有可通过指针路径从根集到达的元组，即 \emph{活} 元组；
\item 回收其他所有东西的内存，也就是 \emph{垃圾} 。
\end{enumerate}
复制收集器通过将所有活动对象从FromSpace复制到ToSpace来实现这一点，然后执行一种巧妙的操作，将ToSpace当作新的FromSpace，将旧的FromSpace当作新的ToSpace。在图~\ref{fig:copying-collector} 的例子中，根集中有三个指针，一个在寄存器中，两个在堆栈中。所有活动对象都以保留指针关系的方式复制到ToSpace(图~\ref{fig:copying-collector} 的右侧)。例如，寄存器中的指针仍然指向一个二元组，它的第一个元素是一个三元组，第二个元素是一个二元组。有4个元组不能从根集到达，因此不能复制到ToSpace中。

在 \LangVec{} 中，一个类型良好的程序不能创建图~\ref{fig:copying-collector} 中的确切情况，因为它包含一个循环。然而，一旦我们到达 \LangAny{} ，创建循环将成为可能。
我们首先设计垃圾收集器来处理循环，因此不需要重新讨论这个问题。

\begin{figure}[tbp]
\centering
\includegraphics[width=\textwidth]{figs/copy-collect-1} \\[5ex]
\includegraphics[width=\textwidth]{figs/copy-collect-2}
\caption{操作中的复制收集器。}
\label{fig:copying-collector}
\end{figure}

当涉及到垃圾收集时，除了复制收集器(及其更大的兄弟，分代收集器)外，还有许多替代方法，例如标记-清除~\citep{McCarthy:1960dz} 和引用计数~\citep{Collins:1960aa} 。复制收集器的优点是分配速度快(只需要比较和指针增量)，没有碎片，回收循环垃圾，收集的时间复杂性只取决于实时数据量，而不是垃圾量~\citep{Wilson:1992fk} 。两空间复制收集器的主要缺点是它使用大量空间，并且执行复制需要很长时间，尽管这些问题在分代收集器中得到改善。Racket 和 Scheme 程序倾向于分配许多小对象并生成大量垃圾，因此复制和分代收集器是一个很好的选择。垃圾收集是一个活跃的研究课题，特别是并发垃圾收集~\citep{Tene:2011kx} 。研究人员正在不断开发新技术，并重新考虑旧的权衡~\citep{Blackburn:2004aa,Jones:2011aa,Shahriyar:2013aa,Cutler:2015aa,Shidal:2015aa,Osterlund:2016aa,Jacek:2019aa,Gamari:2020aa} 。每年研究人员都会在国际记忆管理研讨会上发表这些发现。


\subsection{通过切尼算法复制图形}
\label{sec:cheney}
\index{Cheney's algorithm}
让我们仔细看看活动对象的复制。分配的对象和指针可以被视为一个图，需要复制从根集可以到达的部分图。为了确保复制图中所有可到达的顶点，需要一个穷举图遍历算法，例如深度优先搜索或宽度优先搜索~\citep{Moore:1959aa,Cormen:2001uq} 。回想一下，这样的算法通过标记哪些顶点已经被访问来考虑循环的可能性，从而确保算法的终止。这些搜索算法还使用堆栈或队列等数据结构作为待办事项列表，以跟踪需要访问的顶点。使用宽度优先搜索和 \citet{Cheney:1970aa} 的一个技巧，用于同时表示队列和将元组复制到ToSpace中。

图~\ref{fig:cheney} 显示在复制过程中ToSpace的几个快照。队列由ToSpace开头的一块连续内存表示，使用两个指针跟踪队列的前端和后部。该算法首先将所有可以立即从根集到达的元组复制到ToSpace中，以形成初始队列。当复制一个元组时，将旧元组标记为已访问过它。在第~\ref{sec:data-rep-gc}节讨论如何完成这个标记。注意，队列中复制的元组内的任何指针仍然指向FromSpace。一旦创建初始队列，算法将进入一个循环，在此循环中它将重复处理队列前面的元组，并将其从队列中弹出。为了处理一个元组，该算法将从该元组中直接可达的所有元组复制到ToSpace，将它们放在队列的后面。然后算法更新弹出元组中的指针，使它们指向新复制的元组。

\begin{figure}[tbp]
\centering \includegraphics[width=0.9\textwidth]{figs/cheney}
\caption{复制活元组的Cheney算法的描述。}
\label{fig:cheney}
\end{figure}

回到图~\ref{fig:cheney} ，在第一步中，将第二个元素为 $42$ 的元组复制到队列的后面。另一个指针指向一个已经复制的元组，因此不需要再次复制它，但需要更新指向新位置的指针。这可以通过在旧元组中存储一个指向新位置的 \emph{转发指针} 来实现，这可以追溯到最初将元组复制到ToSpace中的时候。这完成算法的一个步骤。该算法以这种方式继续，直到队列的前端为空，也就是说，直到前端赶上后端。


\subsection{数据表示法}
\label{sec:data-rep-gc}

垃圾收集器对编译器使用的数据表示提出一些要求。首先，垃圾收集器需要区分指针和其他类型的数据。有几种方法可以实现这一点。
\begin{enumerate}
\item 在每个对象上附加一个标签来识别它是什么类型的对象~\citep{McCarthy:1960dz} 。
\item 在不同的区域存储不同类型的对象~\citep{Steele:1977ab} 。
\item 使用来自程序的类型信息来生成用于收集的特定类型代码，或者生成可以指导收集器的表~\citep{Appel:1989aa,Goldberg:1991aa,Diwan:1992aa} 。
\end{enumerate}

动态类型语言，如Lisp，需要标记对象，因此选项1是这些语言的自然选择。
然而， \LangVec{} 是一种静态类型语言，因此在每个对象上都需要标记是很不幸的，特别是像整数和布尔值这样的小而普遍的对象。选项3是静态类型语言的最佳性能选择，但是其实现复杂性相对较高。为了保证本章在2周内完成，我们建议将选项1和选项2结合起来，对堆栈和堆使用不同的策略。

关于堆栈，建议为指针使用一个单独的堆栈，我们称之为 \emph{根堆栈}\index{root stack} (也称为“影子堆栈”)~\citep{Siebert:2001aa,Henderson:2002aa,Baker:2009aa} 。也就是说，当一个局部变量需要被溢出并且类型为
\code{(Vector $\Type_1 \ldots \Type_n$)} 时，将其放在根堆栈上，而不是普通的过程调用堆栈上。此外，如果向量类型的变量在调用收集器期间是活的，总是溢出它们，从而确保在集合期间没有指针在寄存器中。图~\ref{fig:shadow-stack} 再现图~\ref{fig:copying-collector} 中的示例，并使用根堆栈将其与数据布局进行对比。根堆栈包含两个来自常规堆栈的指针，以及第二个寄存器中的指针。

\begin{figure}[tbp]
\centering \includegraphics[width=0.60\textwidth]{figs/root-stack}
\caption{维护根堆栈以方便垃圾收集。}
\label{fig:shadow-stack}
\end{figure}

指针和其他类型的数据之间的区别问题也出现在堆上的每个元组中。通过给每个元组附加一个额外的64位标签来解决这个问题。图~\ref{fig:tuple-rep} 放大了图~\ref{fig:copying-collector} 中示例中的两个元组的标记。请注意，我们以大端方式绘制了位，从右到左，位位置0(最低有效位)在最右边，它对应着x86移动指令
\key{salq} (左移)和 \key{sarq} (右移)的方向。每个标记的一部分用于指定元组中哪些元素是指针，标记为“指针掩码”的部分。在指针掩码中，1位表示有一个指针，0位表示其他类型的数据。指针掩码从位7开始。将元组的最大大小限制为50个元素，因此指针掩码只需要50位。标签还包含另外两部分信息。元组的长度(元素的数量)存储在位1到6的位置。最后，位置0的位表示元组是否还没有被复制到ToSpace。如果位值为1，则该元组还没有被复制。如果位值为0，则整个标签是一个转发指针。 (指针的低3位总是0，因为我们的元组是8字节对齐的。)

\begin{figure}[tbp]
\centering \includegraphics[width=0.8\textwidth]{figs/tuple-rep}
\caption{堆中元组的表示。}
\label{fig:tuple-rep}
\end{figure}

\subsection{垃圾收集器的实现}
\label{sec:organize-gz}
\index{prelude}

\code{runtime.c} 文件中提供复制收集器的实现。图~\ref{fig:gc-header} 定义编译器使用的垃圾收集器的接口。
\code{initialize} 函数创建FromSpace、ToSpace和根堆栈，应该在 \code{main}
函数的前奏中调用。 \code{initialize} 的参数是根堆栈大小和堆大小。两者都需要是 $64$ 的倍数， $16384$ 对两者来说都是不错的选择。 \code{initialize} 函数将FromSpace开头的地址放入全局变量
\code{free\_ptr} 中。全局变量 \code{fromspace\_end} 指向的地址是FromSpace的最后一个元素的1位。 (我们使用半开的间隔来表示内存块~\citep{Dijkstra:1982aa} 。)   \code{rootstack\_begin} 变量指向根堆栈的第一个元素。

只要FromSpace中还有剩余空间，生成的代码就可以通过向前移动 \code{free\_ptr} 来分配元组。
%
FromSpace中剩余的空间是
\code{fromspace\_end} 和 \code{free\_ptr} 之间的差值。当FromSpace中没有足够的空间留给下一次分配时，应该调用 \code{collect}
函数。 \code{collect} 函数接受一个指向根堆栈当前顶部的指针(位于被推入的最后一项的后面)和需要分配的字节数。 \code{collect} 函数执行复制收集，并使堆处于下一次分配将成功的状态。

\begin{figure}[tbp]
\begin{lstlisting}
   void initialize(uint64_t rootstack_size, uint64_t heap_size);
   void collect(int64_t** rootstack_ptr, uint64_t bytes_requested);
   int64_t* free_ptr;
   int64_t* fromspace_begin;
   int64_t* fromspace_end;
   int64_t** rootstack_begin;
\end{lstlisting}
\caption{编译器到垃圾收集器的接口。}
\label{fig:gc-header}
\end{figure}

%% \begin{exercise}
%%   In the file \code{runtime.c} you will find the implementation of
%%   \code{initialize} and a partial implementation of \code{collect}.
%%   The \code{collect} function calls another function, \code{cheney},
%%   to perform the actual copy, and that function is left to the reader
%%   to implement. The following is the prototype for \code{cheney}.
%% \begin{lstlisting}
%%    static void cheney(int64_t** rootstack_ptr);
%% \end{lstlisting}
%%   The parameter \code{rootstack\_ptr} is a pointer to the top of the
%%   rootstack (which is an array of pointers).  The \code{cheney} function
%%   also communicates with \code{collect} through the global
%%   variables \code{fromspace\_begin} and \code{fromspace\_end}
%%   mentioned in Figure~\ref{fig:gc-header} as well as the pointers for
%%   the ToSpace:
%% \begin{lstlisting}
%%    static int64_t* tospace_begin;
%%    static int64_t* tospace_end;
%% \end{lstlisting}
%%   The job of the \code{cheney} function is to copy all the live
%%   objects (reachable from the root stack) into the ToSpace, update
%%   \code{free\_ptr} to point to the next unused spot in the ToSpace,
%%   update the root stack so that it points to the objects in the
%%   ToSpace, and finally to swap the global pointers for the FromSpace
%%   and ToSpace.
%% \end{exercise}


%% \section{Compiler Passes}
%% \label{sec:code-generation-gc}

垃圾收集的引入对我们的编译器通道有重要的影响。我们引入一个新的编译器通道，名为
\code{expose-allocation} 。对 \code{select-instructions}
、\code{build-interference} 、\code{allocate-registers} 和
\code{print-x86} 做了显著的改变，并在更多的通道中做微小的改变。下面的程序将作为运行示例。它创建两个元组，一个嵌套在另一个中。两个元组的长度都是1。程序通过两个向量引用来访问内部元组中的元素。
% tests/s2_17.rkt
\begin{lstlisting}
(vector-ref (vector-ref (vector (vector 42)) 0) 0)
\end{lstlisting}

\section{收缩}
\label{sec:shrink-Rvec}

回想一下， \code{shrink} 通道将原语操作符转换为更小的原语集合。因为这个通道是在类型检查之后，但是在需要 \code{HasType} AST 节点中的类型信息的通道之前， \code{shrink} 通道必须被修改以将 \code{HasType} 包裹在它生成的每个 AST 节点上。


\section{公开分配}
\label{sec:expose-allocation}

 \code{expose-allocation} 通道将 \code{vector} 创建形式降低为对收集器的条件调用，然后是分配。选择将 \code{expose-allocation} 通道置于 \code{remove-complex-opera*} 之前，因为
\code{expose-allocation} 生成的代码包含复杂操作数。还把
\code{expose-allocation} 放在 \code{explicate-control} 之前，因为
\code{expose-allocation} 使用 \code{let} 引入新的变量，但 \code{let} 在 \code{explicate-control} 之后。

 \code{expose-allocation} 的输出是一种语言 \LangAlloc{} ，它扩展 \LangVec{} ，并使用在 \code{vector} 形式的翻译中使用的三种新形式。
\[
\begin{array}{lcl}
  \Exp &::=& \cdots
      \mid (\key{collect} \,\itm{int})
      \mid (\key{allocate} \,\itm{int}\,\itm{type})
      \mid (\key{global-value} \,\itm{name})
\end{array}
\]
 $(\key{collect}\,n)$ 表单运行垃圾收集器，请求
$n$ 个字节。它将成为 \code{select-instructions} 中的 \code{runtime.c} 中的 \code{collect} 函数的调用。
$(\key{allocate}\,n\,T)$ 形式创建一个包含 $n$ 个元素的元组。
\index{allocate}
 $T$ 形参是元组的类型： \code{(Vector $\Type_1 \ldots
  \Type_n$)} ，其中 $\Type_i$ 是元组中第 $i$ 个元素的类型。 $(\key{global-value}\,\itm{name})$ 形式读取全局变量的值，比如 \code{free\_ptr} 。

下面，将 \code{vector}
形式转化为： 1) 初始化表达式的let绑定序列； 2) 对 \code{collect} 的有条件调用； 3) 调用
\code{allocate} ；  4) 向量的初始化。在下面， \itm{len} 指的是向量的长度，而
\itm{bytes} 是需要为向量分配的总字节数，即8(标签)加上 \itm{len} 乘以8。
\begin{lstlisting}
  (has-type (vector |$e_0 \ldots e_{n-1}$|) |\itm{type}|)
|$\Longrightarrow$|
  (let ([|$x_0$| |$e_0$|]) ... (let ([|$x_{n-1}$| |$e_{n-1}$|])
  (let ([_ (if (< (+ (global-value free_ptr) |\itm{bytes}|)
                  (global-value fromspace_end))
               (void)
               (collect |\itm{bytes}|))])
  (let ([|$v$| (allocate |\itm{len}| |\itm{type}|)])
  (let ([_ (vector-set! |$v$| |$0$| |$x_0$|)]) ...
  (let ([_ (vector-set! |$v$| |$n-1$| |$x_{n-1}$|)])
     |$v$|) ... )))) ...)
\end{lstlisting}
在上面，为了可读性，在输出中禁止所有的 \code{has-type} 形式。初始化表达式 $e_0,\ldots,e_{n-1}$ 在 \code{allocate} 在 \code{vector-set!} 序列之前的位置很重要，因为这些表达式可能会触发垃圾收集，并且在收集期间,堆上不能有一个已分配但未初始化的元组。

图~\ref{fig:expose-alloc-output} 显示运行的示例 \code{expose-allocation} 通道的输出。

\begin{figure}[tbp]
% tests/s2_17.rkt
\begin{lstlisting}
(vector-ref
 (vector-ref
  (let ([vecinit7976
         (let ([vecinit7972 42])
           (let ([collectret7974
                  (if (< (+ (global-value free_ptr) 16) 
                         (global-value fromspace_end))
                      (void)
                      (collect 16)
                      )])
             (let ([alloc7971 (allocate 1 (Vector Integer))])
               (let ([initret7973 (vector-set! alloc7971 0 vecinit7972)])
                 alloc7971)
               )
             )
           )
         ])
    (let ([collectret7978
           (if (< (+ (global-value free_ptr) 16)
                  (global-value fromspace_end))
               (void)
               (collect 16)
               )])
      (let ([alloc7975 (allocate 1 (Vector (Vector Integer)))])
        (let ([initret7977 (vector-set! alloc7975 0 vecinit7976)])
          alloc7975)
        )
      )
    )
  0)
 0)
\end{lstlisting}
\caption{ \code{expose-allocation} 的输出，减去所有的 \code{has-type} 形式。}
\label{fig:expose-alloc-output}
\end{figure}


\section{去除复杂的操作数}
\label{sec:remove-complex-opera-Rvec}

新的表单 \code{collect} 、 \code{allocate} 和 \code{global-value}
都应该被视为复杂操作数。
%% A new case for
%% \code{HasType} is needed and the case for \code{Prim} needs to be
%% handled carefully to prevent the \code{Prim} node from being separated
%% from its enclosing \code{HasType}.
图~\ref{fig:Rvec-anf-syntax}
显示该通道的输出语言 \LangVecANF{} 的语法，即管理规范形式的 \LangVec{} 。

\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\small
\[
\begin{array}{rcl}
  \Atm &::=& \gray{ \INT{\Int} \mid \VAR{\Var} \mid \BOOL{\itm{bool}} }
       \mid \VOID{} \\
\Exp &::=& \gray{ \Atm \mid \READ{} } \\
   &\mid& \gray{ \NEG{\Atm} \mid \ADD{\Atm}{\Atm} } \\
   &\mid& \gray{ \LET{\Var}{\Exp}{\Exp} } \\
   &\mid& \gray{ \UNIOP{\key{'not}}{\Atm} } \\
   &\mid& \gray{ \BINOP{\itm{cmp}}{\Atm}{\Atm} \mid \IF{\Exp}{\Exp}{\Exp} }\\
   &\mid& \LP\key{Collect}~\Int\RP \mid \LP\key{Allocate}~\Int~\Type\RP
   \mid \LP\key{GlobalValue}~\Var\RP\\
%  &\mid& \LP\key{HasType}~\Exp~\Type\RP \\
R^{\dagger}_3  &::=& \gray{ \PROGRAM{\code{'()}}{\Exp} }
\end{array}
\]
\end{minipage}
}
\caption{\LangVecANF{} 是管理范式(ANF)中的 \LangVec{} 。}
\label{fig:Rvec-anf-syntax}
\end{figure}


\section{解释控制和 \LangCVec{} 语言}
\label{sec:explicate-control-r3}


\begin{figure}[tp]
\fbox{
  \begin{minipage}{0.96\textwidth}
    \small
\[
\begin{array}{lcl}
\Atm &::=& \gray{ \INT{\Int} \mid \VAR{\Var} \mid \BOOL{\itm{bool}} }\\
\itm{cmp} &::= & \gray{  \key{eq?} \mid \key{<} } \\
\Exp &::= & \gray{ \Atm \mid \READ{} } \\
   &\mid& \gray{ \NEG{\Atm} \mid \ADD{\Atm}{\Atm} }\\
   &\mid& \gray{ \UNIOP{\key{not}}{\Atm} \mid \BINOP{\itm{cmp}}{\Atm}{\Atm}  } \\
   &\mid& \LP\key{Allocate} \,\itm{int}\,\itm{type}\RP \\
   &\mid& \BINOP{\key{'vector-ref}}{\Atm}{\INT{\Int}}  \\
   &\mid& \LP\key{Prim}~\key{'vector-set!}\,\LP\Atm\,\INT{\Int}\,\Atm\RP\RP\\
   &\mid& \LP\key{GlobalValue} \,\Var\RP \mid \LP\key{Void}\RP\\
\Stmt &::=& \gray{ \ASSIGN{\VAR{\Var}}{\Exp} } 
       \mid \LP\key{Collect} \,\itm{int}\RP \\
\Tail &::= & \gray{ \RETURN{\Exp} \mid \SEQ{\Stmt}{\Tail} 
       \mid \GOTO{\itm{label}} } \\
      &\mid& \gray{ \IFSTMT{\BINOP{\itm{cmp}}{\Atm}{\Atm}}{\GOTO{\itm{label}}}{\GOTO{\itm{label}}}  }\\
\LangCVec{} & ::= & \gray{ \CPROGRAM{\itm{info}}{\LP\LP\itm{label}\,\key{.}\,\Tail\RP\ldots\RP} }
\end{array}
\]
\end{minipage}
}
\caption{ \LangCVec{} 的抽象语法，扩展 \LangCIf{} (图~\ref{fig:c1-syntax})。}
\label{fig:c2-syntax}
\end{figure}

 \code{explicate-control} 的输出是一个中间语言 \LangCVec{} 的程序，其抽象语法定义在图~\ref{fig:c2-syntax} 中。 (具体语法在附录的图~\ref{fig:c2-concrete-syntax} 中定义。)   \LangCVec{} 的新形式包括 \key{allocate} 、 \key{vector-ref} 、
\key{vector-set!} 、 \key{global-value} 表达式和
\code{collect} 语句。 \code{explicate-control} 通道可以像对待我们已经遇到的其他表达式形式一样对待这些新形式。


\section{选择指令和 \LangXGlobal{} 语言}
\label{sec:select-instructions-gc}
\index{instruction selection}

%% void (rep as zero)
%% allocate
%% collect (callq collect)
%% vector-ref
%% vector-set!
%% global (postpone)

在本文中，为编译元组所需的大多数新操作生成x86代码，包括 \code{Allocate} 、
\code{Collect} 、 \code{vector-ref} 、 \code{vector-set!} 和
\code{void} 。将 \code{GlobalValue} 编译为 \code{Global} ，是因为后者有不同的具体语法(参见图~\ref{fig:x86-2-concrete} 和 \ref{fig:x86-2})。
\index{x86}

 \code{vector-ref} 和 \code{vector-set!} 形式可转换为
\code{movq} 指令。 (偏移量中的+ 1是通过元组表示开头的标记。)
\begin{lstlisting}
|$\itm{lhs}$| = (vector-ref |$\itm{vec}$| |$n$|);
|$\Longrightarrow$|
movq |$\itm{vec}'$|, %r11
movq |$8(n+1)$|(%r11), |$\itm{lhs'}$|

|$\itm{lhs}$| = (vector-set! |$\itm{vec}$| |$n$| |$\itm{arg}$|);
|$\Longrightarrow$|
movq |$\itm{vec}'$|, %r11
movq |$\itm{arg}'$|, |$8(n+1)$|(%r11)
movq $0, |$\itm{lhs'}$|
\end{lstlisting}
 $\itm{lhs}'$ 、 $\itm{vec}'$ 和 $\itm{arg}'$ 是通过将 $\itm{vec}$ 和 $\itm{arg}$ 转换到x86来获得的。将 $\itm{vec}'$ 移动到寄存器 \code{r11} 确保偏移表达式 \code{$-8(n+1)$(\%r11)} 包含一个寄存器操作数。这需要通过寄存器分配将 \code{r11} 从考虑中删除。

为什么不用 \code{rax} 代替 \code{r11} ？假设用\code{rax} 代替。那么生成的 \code{vector-set!} 的代码将是
\begin{lstlisting}
movq |$\itm{vec}'$|, %rax
movq |$\itm{arg}'$|, |$8(n+1)$|(%rax)
movq $0, |$\itm{lhs}'$|
\end{lstlisting}
接下来，假设 $\itm{arg}'$ 最终是一个堆栈位置，所以
\code{patch-instructions} 会像下面这样通过 \code{rax}
插入一次移动。
\begin{lstlisting}
movq |$\itm{vec}'$|, %rax
movq |$\itm{arg}'$|, %rax
movq %rax, |$8(n+1)$|(%rax)
movq $0, |$\itm{lhs}'$|
\end{lstlisting}
但是上面的指令序列不起作用，因为我们试图同时为两个不同的值 ($\itm{vec}'$ 和
$\itm{arg}'$) 使用 \code{rax} ！

将 \code{allocate} 表单编译为
\code{free\_ptr} 上的操作，如下所示。 \code{free\_ptr}
中的地址是FromSpace中的下一个空闲地址，因此将其复制到
\code{r11} 中，然后将其向前移动足够的空间以分配元组，即 $8(\itm{len}+1)$ 个字节，因为 每个元素为8个字节（64位），使用8个字节作为标记。然后初始化 \itm{tag} ，最后将 \code{r11} 中的地址复制到左边。参见图~\ref{fig:tuple-rep} 来查看标签是如何组织的。建议在编译期间使用 Racket 操作
\code{bitwise-ior} 和 \code{arithmetic-shift} 来计算标记。 \code{vector} 形式的类型注释用于确定标记的指针掩码区域。
\begin{lstlisting}
   |$\itm{lhs}$| = (allocate |$\itm{len}$| (Vector |$\itm{type} \ldots$|));
   |$\Longrightarrow$|
   movq free_ptr(%rip), %r11
   addq |$8(\itm{len}+1)$|, free_ptr(%rip)
   movq $|$\itm{tag}$|, 0(%r11)
   movq %r11, |$\itm{lhs}'$|
\end{lstlisting}

 \code{collect} 表单被编译为运行时对 \code{collect}
函数的调用。 \code{collect} 的参数是： 1) 根堆栈的顶部； 2) 需要分配的字节数。使用另一个专用寄存器 \code{r15} 来存储指向根堆栈顶部的指针。因此， \code{r15} 不能被寄存器分配器使用。
\begin{lstlisting}
   (collect |$\itm{bytes}$|)
   |$\Longrightarrow$|
   movq %r15, %rdi
   movq $|\itm{bytes}|, %rsi
   callq collect
\end{lstlisting}



\begin{figure}[tp]
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{lcl}
  \Arg &::=& \gray{ \key{\$}\Int \mid \key{\%}\Reg \mid \Int\key{(}\key{\%}\Reg\key{)} \mid \key{\%}\itm{bytereg} } \mid \Var \key{(\%rip)} \\
\LangXGlobal{} &::= & \gray{ \key{.globl main} }\\
      &    & \gray{ \key{main:} \; \Instr\ldots }
\end{array}
\]
\end{minipage}
}
\caption{ \LangXGlobal{} 的具体语法 (扩展图 ~\ref{fig:x86-1-concrete} 中的 \LangXIf{} )。}
\label{fig:x86-2-concrete}
\end{figure}

\begin{figure}[tp]
\fbox{
  \begin{minipage}{0.96\textwidth}
    \small
\[
\begin{array}{lcl}
  \Arg &::=&  \gray{  \INT{\Int} \mid \REG{\Reg} \mid \DEREF{\Reg}{\Int}
   \mid \BYTEREG{\Reg}} \\
   &\mid& (\key{Global}~\Var) \\
\LangXGlobal{} &::= & \gray{ \XPROGRAM{\itm{info}}{\LP\LP\itm{label} \,\key{.}\, \Block \RP\ldots\RP} }
\end{array}
\]
\end{minipage}
}
\caption{ \LangXGlobal{} 的抽象语法(扩展图~\ref{fig:x86-1} 中的 \LangXIf{} )。}
\label{fig:x86-2}
\end{figure}

图 ~\ref{fig:x86-2-concrete} 和图 \ref{fig:x86-2} 定义 \LangXGlobal{} 语言的具体和抽象语法。
它与 \LangXIf{} 的不同之处只是增加全局变量的形式。
%
图~\ref{fig:select-instr-output-gc} 显示运行示例\code{select-instructions} 通道的输出。

\begin{figure}[tbp]
\centering
% tests/s2_17.rkt
\begin{minipage}[t]{0.5\textwidth}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
block35:
    movq free_ptr(%rip), alloc9024
    addq $16, free_ptr(%rip)
    movq alloc9024, %r11
    movq $131, 0(%r11)
    movq alloc9024, %r11
    movq vecinit9025, 8(%r11)
    movq $0, initret9026
    movq alloc9024, %r11
    movq 8(%r11), tmp9034
    movq tmp9034, %r11
    movq 8(%r11), %rax
    jmp conclusion
block36:
    movq $0, collectret9027
    jmp block35
block38:
    movq free_ptr(%rip), alloc9020
    addq $16, free_ptr(%rip)
    movq alloc9020, %r11
    movq $3, 0(%r11)
    movq alloc9020, %r11
    movq vecinit9021, 8(%r11)
    movq $0, initret9022
    movq alloc9020, vecinit9025
    movq free_ptr(%rip), tmp9031
    movq tmp9031, tmp9032
    addq $16, tmp9032
    movq fromspace_end(%rip), tmp9033
    cmpq tmp9033, tmp9032
    jl block36
    jmp block37
block37:
    movq %r15, %rdi
    movq $16, %rsi
    callq 'collect
    jmp block35
block39:
    movq $0, collectret9023
    jmp block38
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
start:
    movq $42, vecinit9021
    movq free_ptr(%rip), tmp9028
    movq tmp9028, tmp9029
    addq $16, tmp9029
    movq fromspace_end(%rip), tmp9030
    cmpq tmp9030, tmp9029
    jl block39
    jmp block40
block40:
    movq %r15, %rdi
    movq $16, %rsi
    callq 'collect
    jmp block38
\end{lstlisting}
\end{minipage}
\caption{ \code{select-instructions} 通道的输出。}
\label{fig:select-instr-output-gc}
\end{figure}

\clearpage

\section{寄存器分配}
\label{sec:reg-alloc-gc}
\index{register allocation}

正如本章前面所讨论的，垃圾收集器需要访问根集中的所有指针，也就是说，所有的向量变量。寄存器分配器有责任确保：
\begin{enumerate}
\item 根堆栈用于溢出向量类型的变量；
\item 如果vector类型变量在调用收集器期间处于活动状态，则必须对其进行溢出，以确保收集器可以看到它。
\end{enumerate}

后面的责任可以在干涉图的构造过程中处理，通过在调用实时矢量类型变量和所有被调用保存的寄存器之间添加干涉边。 (它们已经干扰调用者保存的寄存器。)  变量的类型信息是 \code{Program} 形式的，所以建议向 \code{build-interference}
函数添加另一个参数来传达这个列表。

当选择如何将颜色(整数)分配给寄存器和堆栈位置时，可以在图着色之后处理向根堆栈溢出的向量类型变量。 这个通道的 \code{Program} 输出也会改变，以记录到根堆栈的溢出次数。

% build-interference
%
% callq
%   extra parameter for var->type assoc. list
% update 'program' and 'if'

% allocate-registers
%    allocate spilled vectors to the rootstack

% don't change color-graph



\section{打印 x86}
\label{sec:print-x86-gc}
\index{prelude}\index{conclusion}

图~\ref{fig:print-x86-output-gc} 显示运行示例上
\code{print-x86} 通道的输出。在 \code{main} 函数的前奏和结尾部分，将根栈和普通栈处理得非常相似，移动根栈指针
(\code{r15}) ，为根栈的溢出腾出空间，但根栈是向上而不是向下增长的。对于正在运行的示例，只有一个溢出，因此将 \code{r15} 增加8个字节。在结论部分， \code{r15} 减了8个字节。

需要特别注意的一个问题是，在对根堆栈中的所有变量进行初始化赋值之前，可能会调用
\code{collect} 。不希望垃圾收集器意外地认为某个未初始化的变量是一个需要跟随的指针。因此，在 \code{main} 的前奏中，将根堆栈上的所有位置归零。在图~\ref{fig:print-x86-output-gc} 中，指令
%
\lstinline{movq $0, (%r15)}
%
完成了这个任务。垃圾收集器会在对每个根进行解引用之前测试它是否为空。

\begin{figure}[htbp]
\begin{minipage}[t]{0.5\textwidth}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
block35:
	movq	free_ptr(%rip), %rcx
	addq	$16, free_ptr(%rip)
	movq	%rcx, %r11
	movq	$131, 0(%r11)
	movq	%rcx, %r11
	movq	-8(%r15), %rax
	movq	%rax, 8(%r11)
	movq	$0, %rdx
	movq	%rcx, %r11
	movq	8(%r11), %rcx
	movq	%rcx, %r11
	movq	8(%r11), %rax
	jmp conclusion
block36:
	movq	$0, %rcx
	jmp block35
block38:
	movq	free_ptr(%rip), %rcx
	addq	$16, free_ptr(%rip)
	movq	%rcx, %r11
	movq	$3, 0(%r11)
	movq	%rcx, %r11
	movq	%rbx, 8(%r11)
	movq	$0, %rdx
	movq	%rcx, -8(%r15)
	movq	free_ptr(%rip), %rcx
	addq	$16, %rcx
	movq	fromspace_end(%rip), %rdx
	cmpq	%rdx, %rcx
	jl block36
	movq	%r15, %rdi
	movq	$16, %rsi
	callq	collect
	jmp block35
block39:
	movq	$0, %rcx
	jmp block38
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
start:
	movq	$42, %rbx
	movq	free_ptr(%rip), %rdx
	addq	$16, %rdx
	movq	fromspace_end(%rip), %rcx
	cmpq	%rcx, %rdx
	jl block39
	movq	%r15, %rdi
	movq	$16, %rsi
	callq	collect
	jmp block38
        
	.globl main
main:
	pushq	%rbp
	movq	%rsp, %rbp
	pushq	%r13
	pushq	%r12
	pushq	%rbx
	pushq	%r14
	subq	$0, %rsp
	movq $16384, %rdi
	movq $16384, %rsi
	callq initialize
	movq rootstack_begin(%rip), %r15
	movq $0, (%r15)
	addq $8, %r15
	jmp start
conclusion:
	subq $8, %r15
	addq	$0, %rsp
	popq	%r14
	popq	%rbx
	popq	%r12
	popq	%r13
	popq	%rbp
	retq
\end{lstlisting}
\end{minipage}
\caption{ \code{print-x86} 通道的输出。}
\label{fig:print-x86-output-gc}
\end{figure}


\begin{figure}[p]
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (Rvec) at (0,2)  {\large \LangVec{}};
\node (Rvec-2) at (3,2)  {\large \LangVec{}};
\node (Rvec-3) at (6,2)  {\large \LangVec{}};
\node (Rvec-4) at (9,2)  {\large \LangVec{}};
\node (Rvec-5) at (12,2)  {\large \LangAlloc{}};
\node (C2-4) at (3,0)  {\large \LangCVec{}};

\node (x86-2) at (3,-2)  {\large \LangXGlobalVar{}};
\node (x86-2-1) at (3,-4)  {\large \LangXGlobalVar{}};
\node (x86-2-2) at (6,-4)  {\large \LangXGlobalVar{}};
\node (x86-3) at (6,-2)  {\large \LangXGlobalVar{}};
\node (x86-4) at (9,-2) {\large \LangXGlobal{}};
\node (x86-5) at (9,-4) {\large \LangXGlobal{}};


%\path[->,bend left=15] (Rvec) edge [above] node {\ttfamily\footnotesize type-check} (Rvec-2);
\path[->,bend left=15] (Rvec) edge [above] node {\ttfamily\footnotesize shrink} (Rvec-2);
\path[->,bend left=15] (Rvec-2) edge [above] node {\ttfamily\footnotesize uniquify} (Rvec-3);
\path[->,bend left=15] (Rvec-3) edge [above] node {\ttfamily\footnotesize expose-alloc.} (Rvec-4);
\path[->,bend left=15] (Rvec-4) edge [above] node {\ttfamily\footnotesize remove-complex.} (Rvec-5);
\path[->,bend left=20] (Rvec-5) edge [left] node {\ttfamily\footnotesize explicate-control} (C2-4);
\path[->,bend left=15] (C2-4) edge [right] node {\ttfamily\footnotesize select-instr.} (x86-2);
\path[->,bend right=15] (x86-2) edge [left] node {\ttfamily\footnotesize uncover-live} (x86-2-1);
\path[->,bend right=15] (x86-2-1) edge [below] node {\ttfamily\footnotesize build-inter.} (x86-2-2);
\path[->,bend right=15] (x86-2-2) edge [right] node {\ttfamily\footnotesize allocate-reg.} (x86-3);
\path[->,bend left=15] (x86-3) edge [above] node {\ttfamily\footnotesize patch-instr.} (x86-4);
\path[->,bend left=15] (x86-4) edge [right] node {\ttfamily\footnotesize print-x86} (x86-5);
\end{tikzpicture}
\caption{带有元组的语言 \LangVec{} 的通道图}
\label{fig:Rvec-passes}
\end{figure}

图~\ref{fig:Rvec-passes} 给出编译 \LangVec{} 所需的所有通道的概览。

\section{挑战：简单的结构}
\label{sec:simple-structures}
\index{struct}
\index{structure}

图~\ref{fig:r3s-concrete-syntax} 定义
\LangStruct{} 的具体语法，它扩展 \LangVec{} ，支持简单的结构。
回想一下，类型化 Racket 中的 \code{struct} 是用户定义的数据类型，它包含命名字段，是堆分配的，类似于向量。下面是一个结构定义的示例，在本例中是 \code{point} 类型的定义。
\begin{lstlisting}
(struct point ([x : Integer] [y : Integer]) #:mutable)
\end{lstlisting}

\begin{figure}[tbp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{lcl}
  \Type &::=& \gray{\key{Integer} \mid \key{Boolean}
  \mid (\key{Vector}\;\Type \ldots) \mid \key{Void} } \mid \Var \\
  \itm{cmp} &::= & \gray{ \key{eq?} \mid \key{<} \mid \key{<=} \mid \key{>} \mid \key{>=} } \\
  \Exp &::=& \gray{  \Int \mid (\key{read}) \mid (\key{-}\;\Exp) \mid (\key{+} \; \Exp\;\Exp) \mid (\key{-}\;\Exp\;\Exp) }  \\
  &\mid&  \gray{  \Var \mid (\key{let}~([\Var~\Exp])~\Exp)  }\\
  &\mid& \gray{ \key{\#t} \mid \key{\#f} 
   \mid (\key{and}\;\Exp\;\Exp) 
   \mid (\key{or}\;\Exp\;\Exp)
   \mid (\key{not}\;\Exp) } \\
  &\mid& \gray{  (\itm{cmp}\;\Exp\;\Exp) 
   \mid (\key{if}~\Exp~\Exp~\Exp)  } \\
  &\mid& \gray{ (\key{vector}\;\Exp \ldots) 
   \mid (\key{vector-ref}\;\Exp\;\Int) } \\
  &\mid& \gray{ (\key{vector-set!}\;\Exp\;\Int\;\Exp) }\\
  &\mid& \gray{ (\key{void}) } \mid (\Var\;\Exp \ldots)\\
  \Def &::=& (\key{struct}\; \Var \; ([\Var \,\key{:}\, \Type] \ldots)\; \code{\#:mutable})\\
  \LangStruct{} &::=& \Def \ldots \; \Exp
\end{array}
\]
\end{minipage}
}
\caption{ \LangStruct{} 的具体语法，扩展 \LangVec{} (图~\ref{fig:Rvec-concrete-syntax})。}
\label{fig:r3s-concrete-syntax}
\end{figure}

结构的实例是使用函数调用语法创建的，结构的名称位于函数位置
\begin{lstlisting}
(point 7 12)
\end{lstlisting}
函数调用语法也用于读取结构字段中的值。函数名由结构名、破折号和字段名组成。下面的示例使用 \code{point-x} 和
\code{point-y} 访问两个点实例的 \code{x} 和 \code{y} 字段。
\begin{center}
\begin{lstlisting}
(let ([pt1 (point 7 12)])
  (let ([pt2 (point 4 3)])
    (+ (- (point-x pt1) (point-x pt2))
       (- (point-y pt1) (point-y pt2)))))
\end{lstlisting}
\end{center}
类似地，要写入结构的字段，请使用它的set函数，该函数的名称以 \code{set-} 开头，接着是结构名，然后是破折号，然后是字段名，最后是感叹号。下面的示例使用 \code{set-point-x!} 将
\code{x} 字段从 \code{7} 更改为 \code{42} 。
\begin{center}
  \begin{lstlisting}
(let ([pt (point 7 12)])
  (let ([_ (set-point-x! pt 42)])
    (point-x pt)))
\end{lstlisting}
\end{center}

\begin{exercise}\normalfont
  扩展编译器，支持简单的结构，将 \LangStruct{} 编译为x86汇编代码。创建五个使用结构并测试编译器的新测试用例。
\end{exercise}


\section{挑战：分代收集}

第~\ref{sec:GC} 节中描述的复制收集器会产生大量的运行时开销，因为 \code{collect} 调用所花费的时间与所有实时数据成比例。减少这种开销的一种方法是减少每次
\code{collect} 调用中被检查的数据量。特别是，研究人员观察到，最近分配的数据比之前经过一次或多次 \code{collect} 的数据更有可能成为垃圾。这种洞察力激发 \emph{分代垃圾收集器}
\index{generational garbage collector} 的诞生：
1) 根据年龄将数据隔离为两个或更多代；
2) 为年轻的代分配更少的空间，因此收集它们的速度更快，为年老的代分配更多的空间； 3) 对年轻代的收集比对老代的更频繁~\citep{Wilson:1992fk} 。

对于这个挑战分配，目标是使 \code{runtime.c} 中实现的复制收集器使用两代，一代用于年轻数据，一代用于旧数据。每一代都由FromSpace和ToSpace组成。下面是如何调整
\code{collect} 功能来使用这两代人的草图。

\begin{enumerate}
\item 复制年轻一代的FromSpace到它的ToSpace，然后切换ToSpace和FromSpace的角色
\item 如果年轻的FromSpace中有足够的空间容纳请求的字节数，那么从 \code{collect} 返回。
\item 如果年轻的FromSpace中没有足够的空间来存放请求的字节，则按照以下步骤将数据从年轻代移动到老代：
  \begin{enumerate}
  \item 如果旧的FromSpace中有足够的空间，将年轻的FromSpace复制到旧的FromSpace中，然后返回。
  \item 如果旧的FromSpace中没有足够的空间，那么通过将旧的FromSpace复制到旧的ToSpace来收集旧的代，并交换旧的FromSpace和ToSpace的角色。
  \item 如果现在有足够的空间，将年轻的FromSpace复制到旧的FromSpace并返回。否则，为旧代分配更大的FromSpace和ToSpace。将年轻的FromSpace和旧的FromSpace复制到年老代的较大的FromSpace中，然后返回。
  \end{enumerate}
\end{enumerate}

建议你一般化 \code{cheney} 函数，这样它就可以用于上面提到的所有副本：年轻的FromSpace和老的FromSpace之间，年轻的FromSpace和老的FromSpace之间。这可以通过向 \code{cheney} 添加参数来完成，以替换全局变量 \code{fromspace\_begin} 、
\code{fromspace\_end} 、 \code{tospace\_begin} 和 \code{tospace\_end} 。

请注意，年轻代的集合不会遍历老代。这就带来一个潜在的问题：可能有一些年轻的数据只能通过老一代的指针访问。如果不考虑这些指针，收集器可能会丢弃实时的年轻数据！一种称为 \emph{指针记录} 的解决方案是维护从老代到新代的所有指针的集合，并将该集合视为根集的一部分。为了维护这个向量集，编译器必须在每个 \code{vector-set!} 周围插入额外的指令。如果被修改的向量属于旧的一代，并且被写入的值是指向新一代的指针，则必须将该指针添加到集合中。此外，如果被覆盖的值是指向新一代的指针，则应该从集合中删除该指针。

\begin{exercise}\normalfont
  调整 \code{runtime.c} 中的 \code{collect} 函数来实现分代垃圾收集，如本节所述。
  更新 \code{vector-set!} 的代码生成，以实现指针记录。确保新编译器和运行时通过测试套件。
\end{exercise}

% Further Reading

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{函数}
\label{ch:Rfun}
\index{function}

本章研究类似于C语言的函数的编译。这对应于一个只允许顶级函数定义的类型化 Racket 子集。 
这类函数是实现词汇作用域函数的重要基石，即 \key{lambda} 抽象，这是第~\ref{ch:Rlam} 章的主题。

\section{ \LangFun{} 语言}

函数定义和函数应用程序的具体和抽象语法如图~\ref{fig:Rfun-concrete-syntax} 和
\ref{fig:Rfun-syntax} 所示，其中我们定义 \LangFun{} 语言。
\LangFun{} 中的程序以零个或多个函数定义开始。这些定义中的函数名在整个程序的作用域内，包括所有其他函数定义(因此函数定义的顺序无关紧要)。函数应用\index{function application} 的具体语法是 $(\Exp \; \Exp \ldots)$
，其中第一个表达式必须计算为一个函数，其余的是参数。
函数应用程序的抽象语法是
$\APPLY{\Exp}{\Exp\ldots}$ 。

%% The syntax for function application does not include an explicit
%% keyword, which is error prone when using \code{match}. To alleviate
%% this problem, we translate the syntax from $(\Exp \; \Exp \ldots)$ to
%% $(\key{app}\; \Exp \; \Exp \ldots)$ during type checking.

函数是一等函数，因为函数指针
\index{function pointer}是数据，可以存储在内存中，也可以作为参数传递给另一个函数。因此，介绍一个函数类型
\begin{lstlisting}
   (|$\Type_1$| |$\cdots$| |$\Type_n$| -> |$\Type_r$|)
\end{lstlisting}
对于 $n$ 个形参类型为 $\Type_1$ 到
$\Type_n$ 且返回类型为 $\Type_r$ 的函数。这些函数(相对于 Racket 函数而言)的主要限制是它们没有词法范围。也就是说，唯一可以从函数体内部引用的外部实体是其他全局定义的函数。 \LangFun{} 的语法阻止函数之间的嵌套。

\begin{figure}[tp]
\centering
\fbox{
  \begin{minipage}{0.96\textwidth}
    \small
\[
\begin{array}{lcl}
  \Type &::=& \gray{ \key{Integer} \mid \key{Boolean}
         \mid (\key{Vector}\;\Type\ldots) \mid \key{Void}  } \mid (\Type \ldots \; \key{->}\; \Type) \\
\itm{cmp} &::= & \gray{  \key{eq?} \mid \key{<} \mid \key{<=} \mid \key{>} \mid \key{>=}  } \\
  \Exp &::=& \gray{ \Int \mid \CREAD{} \mid \CNEG{\Exp} \mid \CADD{\Exp}{\Exp} \mid \CSUB{\Exp}{\Exp} } \\
    &\mid&  \gray{ \Var \mid \CLET{\Var}{\Exp}{\Exp} }\\
    &\mid& \gray{ \key{\#t} \mid \key{\#f} 
    \mid (\key{and}\;\Exp\;\Exp)
    \mid (\key{or}\;\Exp\;\Exp)
    \mid (\key{not}\;\Exp)} \\
   &\mid& \gray{(\itm{cmp}\;\Exp\;\Exp) \mid \CIF{\Exp}{\Exp}{\Exp} } \\
  &\mid& \gray{(\key{vector}\;\Exp\ldots) \mid
    (\key{vector-ref}\;\Exp\;\Int)} \\
  &\mid& \gray{(\key{vector-set!}\;\Exp\;\Int\;\Exp)\mid (\key{void})
      \mid \LP\key{has-type}~\Exp~\Type\RP } \\
  &\mid& \LP\Exp \; \Exp \ldots\RP \\
  \Def &::=& \CDEF{\Var}{\LS\Var \key{:} \Type\RS \ldots}{\Type}{\Exp} \\
  \LangFun{} &::=& \Def \ldots \; \Exp
\end{array}
\]
\end{minipage}
}
\caption{ \LangFun{} 扩展 \LangVec{} 的具体语法 (图~\ref{fig:Rvec-concrete-syntax}) 。}
\label{fig:Rfun-concrete-syntax}
\end{figure}

\begin{figure}[tp]
\centering
\fbox{
  \begin{minipage}{0.96\textwidth}
    \small
\[
\begin{array}{lcl}
\Exp &::=& \gray{ \INT{\Int} \VAR{\Var} \mid \LET{\Var}{\Exp}{\Exp} } \\
     &\mid& \gray{ \PRIM{\itm{op}}{\Exp\ldots} }\\
     &\mid& \gray{ \BOOL{\itm{bool}} 
      \mid \IF{\Exp}{\Exp}{\Exp} } \\
     &\mid& \gray{ \VOID{} \mid \LP\key{HasType}~\Exp~\Type \RP } 
     \mid \APPLY{\Exp}{\Exp\ldots}\\
 \Def &::=& \FUNDEF{\Var}{\LP[\Var \code{:} \Type]\ldots\RP}{\Type}{\code{'()}}{\Exp}\\
  \LangFun{} &::=& \PROGRAMDEFSEXP{\code{'()}}{\LP\Def\ldots\RP)}{\Exp}
\end{array}
\]
\end{minipage}
}
\caption{ \LangFun{} 的抽象语法扩展 \LangVec{} (图~\ref{fig:Rvec-syntax}) 。}
\label{fig:Rfun-syntax}
\end{figure}


图~\ref{fig:Rfun-function-example} 中的程序是在 \LangFun{} 中定义和使用函数的一个典型例子。定义一个函数 \code{map-vec} ，它将其他函数
\code{f} 应用于向量的两个元素，并返回一个包含结果的新向量。还定义一个函数 \code{add1}。
程序应用
\code{map-vec} 到 \code{add1} 和 \code{(vector 0 41)} 。结果是
\code{(vector 1 42)} ，返回 \code{42} 。

\begin{figure}[tbp]
\begin{lstlisting}
(define (map-vec [f : (Integer -> Integer)]
                   [v : (Vector Integer Integer)])
        : (Vector Integer Integer)
  (vector (f (vector-ref v 0)) (f (vector-ref v 1))))

(define (add1 [x : Integer]) : Integer
  (+ x 1))

(vector-ref (map-vec add1 (vector 0 41)) 1)
\end{lstlisting}
\caption{在 \LangFun{} 中使用函数的例子。}
\label{fig:Rfun-function-example}
\end{figure}

 \LangFun{} 的定义解释器如图~\ref{fig:interp-Rfun} 所示。 \code{ProgramDefsExp} 表单的案例负责设置顶级函数定义之间的相互递归。使用经典的回补\index{back-patching}
方法~\citep{Kelsey:1998di} ，即使用可变变量，并对函数定义进行两个通道。在第一个通道中，为每个函数定义使用可变cons单元格来设置顶层环境。注意，每个函数的 \code{lambda} 值是不完整的；它还不包括环境因素。一旦构建顶层环境，我们就对其进行迭代，并更新 \code{lambda} 值以使用顶层环境。

\begin{figure}[tp]
\begin{lstlisting}
(define interp-Rfun-class
  (class interp-Rvec-class
    (super-new)

    (define/override ((interp-exp env) e)
      (define recur (interp-exp env))
      (match e
        [(Var x) (unbox (dict-ref env x))]
        [(Let x e body)
         (define new-env (dict-set env x (box (recur e))))
         ((interp-exp new-env) body)]
        [(Apply fun args)
         (define fun-val (recur fun))
         (define arg-vals (for/list ([e args]) (recur e)))
         (match fun-val
           [`(function (,xs ...) ,body ,fun-env)
            (define params-args (for/list ([x xs] [arg arg-vals])
                                  (cons x (box arg))))
            (define new-env (append params-args fun-env))
            ((interp-exp new-env) body)]
           [else (error 'interp-exp "expected function, not ~a" fun-val)])]
        [else ((super interp-exp env) e)]
        ))

    (define/public (interp-def d)
      (match d
        [(Def f (list `[,xs : ,ps] ...) rt _ body)
         (cons f (box `(function ,xs ,body ())))]))
\end{lstlisting}
\end{figure}
\begin{figure}[tp]
\begin{lstlisting}
    (define/override (interp-program p)
      (match p
        [(ProgramDefsExp info ds body)
         (let ([top-level (for/list ([d ds]) (interp-def d))])
           (for/list ([f (in-dict-values top-level)])
             (set-box! f (match (unbox f)
                           [`(function ,xs ,body ())
                            `(function ,xs ,body ,top-level)])))
           ((interp-exp top-level) body))]))
    ))

(define (interp-Rfun p)
  (send (new interp-Rfun-class) interp-program p))
\end{lstlisting}
\caption{ \LangFun{} 语言的解释器。}
\label{fig:interp-Rfun}
\end{figure}


\margincomment{TODO: explain type checker}

 \LangFun{} 的类型检查器如图~\ref{fig:type-check-Rfun} 所示。

\begin{figure}[tp]
\begin{lstlisting}
(define type-check-Rfun-class
  (class type-check-Rvec-class
    (super-new)
    (inherit check-type-equal?)

    (define/public (type-check-apply env e es)
      (define-values (e^ ty) ((type-check-exp env) e))
      (define-values (e* ty*) (for/lists (e* ty*) ([e (in-list es)])
                                ((type-check-exp env) e)))
      (match ty
        [`(,ty^* ... -> ,rt)
         (for ([arg-ty ty*] [param-ty ty^*])
           (check-type-equal? arg-ty param-ty (Apply e es)))
         (values e^ e* rt)]))

    (define/override (type-check-exp env)
      (lambda (e)
        (match e
          [(FunRef f)
           (values (FunRef f)  (dict-ref env f))]
          [(Apply e es)
           (define-values (e^ es^ rt) (type-check-apply env e es))
           (values (Apply e^ es^) rt)]
          [(Call e es)
           (define-values (e^ es^ rt) (type-check-apply env e es))
           (values (Call e^ es^) rt)]
          [else ((super type-check-exp env) e)])))
\end{lstlisting}
\end{figure}
\begin{figure}[tp]
\begin{lstlisting}
    (define/public (type-check-def env)
      (lambda (e)
        (match e
          [(Def f (and p:t* (list `[,xs : ,ps] ...)) rt info body)
           (define new-env (append (map cons xs ps) env))
           (define-values (body^ ty^) ((type-check-exp new-env) body))
           (check-type-equal? ty^ rt body)
           (Def f p:t* rt info body^)])))	 

    (define/public (fun-def-type d)
      (match d
        [(Def f (list `[,xs : ,ps] ...) rt info body)  `(,@ps -> ,rt)]))

    (define/override (type-check-program e)
      (match e
        [(ProgramDefsExp info ds body)
         (define new-env (for/list ([d ds])
                           (cons (Def-name d) (fun-def-type d))))
         (define ds^ (for/list ([d ds]) ((type-check-def new-env) d)))
         (define-values (body^ ty) ((type-check-exp new-env) body))
         (check-type-equal? ty 'Integer body)
         (ProgramDefsExp info ds^ body^)]))))

(define (type-check-Rfun p)
  (send (new type-check-Rfun-class) type-check-program p))
\end{lstlisting}
\caption{ \LangFun{} 语言的类型检查器。}
\label{fig:type-check-Rfun}
\end{figure}




\section{ x86 中的函数}
\label{sec:fun-x86}

\margincomment{\tiny Make sure callee-saved registers are discussed
   in enough depth, especially updating Fig 6.4 \\ --Jeremy }

\margincomment{\tiny Talk about the return address on the
   stack and what callq  and retq does.\\ --Jeremy }
已经看到，x86提供标签，以便可以引用指令的位置，这是跳转指令所需要的。标签也可以用来标记函数指令的开头。更进一步，可以通过使用 \key{leaq} 指令和PC相对寻址来获得一个标签的地址。例如，下面将 \code{add1} 标签的地址放入 \code{rbx} 寄存器中。
\begin{lstlisting}
   leaq add1(%rip), %rbx
\end{lstlisting}
指令指针寄存器 \key{rip} (也称为程序计数器
\index{program counter}) 始终指向要执行的下一条指令。当与一个标签结合时，如 \code{add1(\%rip)}，链接器计算 \code{add1} 的地址与 \code{rip} 此刻的位置之间的距离 $d$ ，然后将
\code{add1(\%rip)} 更改为 \code{$d$(\%rip)}，运行时将计算 \code{add1} 的地址。

在第~\ref{sec:x86} 节中，使用 \code{callq} 指令跳转到一个函数，该函数的位置由标签给出。在本章中，为了支持函数调用，将跳转到一个由寄存器中的地址给出的函数，也就是说，需要进行一个 \emph{间接函数调用} 。x86的语法是 \code{callq} 指令，但是在寄存器名之前有一个星号。\index{indirect function call}
\begin{lstlisting}
   callq *%rbx
\end{lstlisting}


\subsection{调用约定}

\index{calling conventions}

 \code{callq} 指令为实现函数提供了部分支持：它将返回地址压入堆栈，然后跳转到目标函数。但是， \code{callq} 不处理
\begin{enumerate}
\item 参数传递；
\item 将帧压入过程调用堆栈并取出它们；
\item 确定不同函数如何共享寄存器。
\end{enumerate}

关于(1)参数传递，请记住以下6个寄存器用于按此顺序将参数传递给函数。
\begin{lstlisting}
rdi rsi rdx rcx r8 r9
\end{lstlisting}
如果有6个以上的参数，那么约定是在调用者的框架上为其余的参数预留空间。但是，为了简化有效的尾部调用的实现(第~\ref{sec:tail-call}节)，将参数设置为不超过6个。
%
还记得寄存器 \code{rax} 是用于函数的返回值的。

\index{prelude}\index{conclusion}

关于(2)帧\index{frame}和过程调用堆栈，
\index{procedure call stack} 回顾第~\ref{sec:x86} 节，堆栈向下增长，每个函数调用使用一块称为帧的空间。调用者将堆栈指针寄存器
\code{rsp} 设置为帧中的最后一个数据项。被调用方不能改变调用方框架内的任何内容，即在堆栈指针上或上面的任何内容。被调用方可以自由使用堆栈指针下面的位置。

回想一下，我们是在根堆栈上存储向量类型的变量。
所以前奏需要将根堆栈指针 \code{r15} 向上移动，而结论需要将根堆栈指针向下移动。同样，前奏必须将这帧在根栈中的插槽初始化为 \code{0} ，以向垃圾收集器发出这些插槽还不包含指向向量的指针的信号。否则，垃圾收集器将把这些槽中的垃圾位解释为内存地址，并试图遍历它们，从而造成严重的破坏!

关于(3)不同函数之间的寄存器共享，回顾一下第~\ref{sec:calling-conventions} 节，寄存器被分为两组，调用者保存的寄存器和被调用者保存的寄存器。调用方应该假设所有调用方保存的寄存器被调用方用任意值覆盖。这就是为什么在第~\ref{sec:calling-conventions} 节中建议，在函数调用期间活动的变量，不应该被分配给调用方保存的寄存器。

另一方面，如果被调用方想要使用被调用方保存的寄存器，则被调用方必须将这些寄存器的内容保存在它们的堆栈帧上，然后在返回给调用方之前将它们放回去。这就是为什么在第~\ref{sec:calling-conventions}节中建议，如果寄存器分配器将一个变量赋给被调用者保存的寄存器，那么 \code{main} 函数的前奏必须将该寄存器保存到堆栈中，而 \code{main} 函数的结论必须恢复它。这个建议现在适用于所有函数。

还记得基指针 \code{rbp}寄存器被用作帧内的一个引用点，这样每个局部变量都可以在基指针的固定偏移量处被访问(第~\ref{sec:x86}节)。
%
图~\ref{fig:call-frames} 显示调用者和被调用者框架的总体布局。


\begin{figure}[tbp]
\centering
\begin{tabular}{r|r|l|l} \hline
调用者视角 & 调用者视角 & 内容       & 框架 \\ \hline
8(\key{\%rbp})  & & return address & \multirow{5}{*}{Caller}\\
0(\key{\%rbp})  &  & old \key{rbp} \\
-8(\key{\%rbp}) &  & callee-saved $1$ \\
\ldots & & \ldots \\
$-8j$(\key{\%rbp}) &  & callee-saved $j$ \\
$-8(j+1)$(\key{\%rbp}) &  & local variable $1$ \\
\ldots & & \ldots \\
$-8(j+k)$(\key{\%rbp}) &  & local variable $k$ \\
 %% & &  \\
%% $8n-8$\key{(\%rsp)} & $8n+8$(\key{\%rbp})& argument $n$ \\
%% & \ldots           & \ldots \\
%% 0\key{(\%rsp)} & 16(\key{\%rbp})  & argument $1$   & \\
\hline
& 8(\key{\%rbp})   & return address & \multirow{5}{*}{Callee}\\
& 0(\key{\%rbp})   & old \key{rbp} \\
& -8(\key{\%rbp}) & callee-saved $1$ \\
& \ldots & \ldots \\
& $-8n$(\key{\%rbp})  & callee-saved $n$ \\
& $-8(n+1)$(\key{\%rbp})  & local variable $1$ \\
&  \ldots          & \ldots \\
& $-8(n+m)$(\key{\%rsp})   & local variable $m$\\ \hline
\end{tabular}
\caption{调用者和被调用者帧的内存布局。}
\label{fig:call-frames}
\end{figure}

%% Recall from Section~\ref{sec:x86} that the stack is also used for
%% local variables and for storing the values of callee-saved registers
%% (we shall refer to all of these collectively as ``locals''), and that
%% at the beginning of a function we move the stack pointer \code{rsp}
%% down to make room for them.
%% We recommend storing the local variables
%% first and then the callee-saved registers, so that the local variables
%% can be accessed using \code{rbp} the same as before the addition of
%% functions.
%% To make additional room for passing arguments, we shall
%% move the stack pointer even further down. We count how many stack
%% arguments are needed for each function call that occurs inside the
%% body of the function and find their maximum. Adding this number to the
%% number of locals gives us how much the \code{rsp} should be moved at
%% the beginning of the function. In preparation for a function call, we
%% offset from \code{rsp} to set up the stack arguments. We put the first
%% stack argument in \code{0(\%rsp)}, the second in \code{8(\%rsp)}, and
%% so on.

%% Upon calling the function, the stack arguments are retrieved by the
%% callee using the base pointer \code{rbp}. The address \code{16(\%rbp)}
%% is the location of the first stack argument, \code{24(\%rbp)} is the
%% address of the second, and so on. Figure~\ref{fig:call-frames} shows
%% the layout of the caller and callee frames. Notice how important it is
%% that we correctly compute the maximum number of arguments needed for
%% function calls; if that number is too small then the arguments and
%% local variables will smash into each other!

\subsection{高效的尾部调用}
\label{sec:tail-call}

通常，程序所使用的堆栈空间的大小是由最长的嵌套函数调用链决定的。也就是说，如果函数
$f_1$ 调用 $f_2$ ， $f_2$ 调用 $f_3$, $\ldots$ ， $f_{n-1}$ 调用
$f_n$ ，那么堆栈空间的大小是 $O(n)$ 。在递归或相互递归函数的情况下，深度
$n$ 可以增长相当大。然而，在某些情况下，可以安排只使用常数空间，即 $O(1)$ ，而不是 $O(n)$ 。

如果函数调用是函数体中的最后一个操作，则该调用称为 \emph{尾部调用}\index{tail call}。
例如，在下面的程序中，对 \code{tail-sum} 的递归调用就是尾部调用。
\begin{center}
\begin{lstlisting}
(define (tail-sum [n : Integer] [r : Integer]) : Integer
  (if (eq? n 0) 
      r
      (tail-sum (- n 1) (+ n r))))

(+ (tail-sum 5 0) 27)
\end{lstlisting}
\end{center}
在尾部调用时，不再需要调用方的帧，因此可以在进行尾部调用之前弹出调用方的帧。使用这种方法，只进行尾部调用的递归函数将只使用 $O(1)$ 堆栈空间。 像 Racket 这样的函数式语言通常严重依赖递归函数，所以通常保证所有尾部调用都以这种方式优化。
\index{frame}

但是，在尾部调用中传递参数时需要注意。如上所述，对于第6个以上的参数，约定是在调用者的框架中使用空间传递参数。但是对于一个尾部调用，弹出调用者的帧，不能再使用它。另一种选择是在被调用方的框架中使用空间传递参数然而，这个选项也有问题，因为调用者和被调用者的帧在内存中重叠。当我们开始从它们在调用者的帧中的源中复制参数时，被调用者帧中的目标位置可能会与后面的参数的源重叠！解决这个问题的方法是不使用堆栈传递超过6个参数，而是使用堆，如第~\ref{sec:limit-functions-r4} 节所述。

如上所述，对于尾部调用，在进行尾部调用之前弹出调用方的帧。弹出帧的指令是我们通常放在函数结尾的指令。因此，还需要在每个尾部调用之前立即放置这样的代码。这些指令包括恢复被调用者保存的寄存器，因此传递参数的寄存器都是调用者保存的寄存器是很好的。

关于使用哪个指令进行尾部调用的最后一个注意事项。当被调用方完成时，它不应该返回当前函数，但应该返回调用当前函数的函数。因此，堆栈上已经存在的返回地址就是正确的，不应该使用 \key{callq} 来进行尾部调用，因为那样会不必要地覆盖返回地址。相反，可以简单地使用 \key{jmp} 指令。与间接函数调用类似，使用带有星号前缀的寄存器编写 \emph{间接跳转}\index{indirect jump} 。建议使用 \code{rax} 来保存跳转目标，因为前面的结论几乎覆盖所有其他内容。
\begin{lstlisting}
   jmp *%rax
\end{lstlisting}

\section{缩小 \LangFun{}}
\label{sec:shrink-r4}

 \code{shrink} 通道执行一个小的修改，以减轻后面的通道。这个函数引入一个显式的 \code{main} 函数，并将顶部的 \code{ProgramDefsExp} 形式更改为
\code{ProgramDefs} ，如下所示。
\begin{lstlisting}
   (ProgramDefsExp |$\itm{info}$| (|$\Def\ldots$|) |$\Exp$|)
|$\Rightarrow$| (ProgramDefs |$\itm{info}$| (|$\Def\ldots$| |$\itm{mainDef}$|))
\end{lstlisting}
其中， $\itm{mainDef}$ 是
\begin{lstlisting}
(Def 'main '() 'Integer '() |$\Exp'$|)
\end{lstlisting}


\section{揭示函数和 \LangFunRef{} 语言}
\label{sec:reveal-functions-r4}

 \LangFun{} 的语法在编译时很不方便:它合并函数名和局部变量的使用。这是一个问题，因为需要将函数名的使用与局部变量的使用进行不同的编译；需要使用 \code{leaq} 将函数名(x86中的标签)转换为寄存器中的地址。因此，创建一个新的通道将函数引用从符号 $f$ 更改为
$\FUNREF{f}$ 是一个好主意。这个通道被命名为 \code{reveal-functions} ，输出语言 \LangFunRef{} 在图~\ref{fig:f1-syntax} 中定义。
函数引用的具体语法是 $\CFUNREF{f}$ 。

\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{lcl}
\Exp &::=& \ldots \mid \FUNREF{\Var}\\
 \Def &::=& \gray{ \FUNDEF{\Var}{([\Var \code{:} \Type]\ldots)}{\Type}{\code{'()}}{\Exp} }\\
  \LangFunRef{} &::=& \PROGRAMDEFS{\code{'()}}{\LP \Def\ldots \RP}
\end{array}
\]
\end{minipage}
}
\caption{抽象语法 \LangFunRef{} ， \LangFun{} 的扩展
  (图~\ref{fig:Rfun-syntax})。}
\label{fig:f1-syntax}
\end{figure}

%% Distinguishing between calls in tail position and non-tail position
%% requires the pass to have some notion of context. We recommend using
%% two mutually recursive functions, one for processing expressions in
%% tail position and another for the rest. 

将这个通道放在 \code{uniquify} 之后将确保没有共享相同名称的局部变量和函数。另一方面， \code{reveal-functions} 需要在
\code{explicate-control} 通道之前，因为该通道帮助我们将
\code{FunRef} 表单编译成赋值语句。

\section{极限函数}
\label{sec:limit-functions-r4}

回想一下，我们希望将函数参数的数量限制为6个，这样就不需要使用堆栈来传递参数，这使得实现有效的尾部调用更容易。但是，由于输入语言 \LangFun{} 支持任意数量的函数参数，我们需要做一些工作！

此过程将涉及六个以上参数的函数和函数调用转换为照常传递前五个参数，但它将其余参数打包到向量中，并将其作为第六个参数传递。

对于包含太多参数的每个函数定义进行如下转换。
\begin{lstlisting}
  (Def |$f$| ([|$x_1$|:|$T_1$|] |$\ldots$| [|$x_n$|:|$T_n$|]) |$T_r$| |$\itm{info}$| |$\itm{body}$|) 
|$\Rightarrow$|
  (Def |$f$| ([|$x_1$|:|$T_1$|] |$\ldots$| [|$x_5$|:|$T_5$|] [vec : (Vector |$T_6 \ldots T_n$|)]) |$T_r$| |$\itm{info}$| |$\itm{body}'$|) 
\end{lstlisting}
通过将后面出现的参数替换为向量引用，将 $\itm{body}$ 转换为 $\itm{body}'$ 。
\begin{lstlisting}
  (Var |$x_i$|) |$\Rightarrow$| (Prim 'vector-ref (list vec (Int |$(i - 6)$|)))
\end{lstlisting}

对于带有太多参数的函数调用， \code{limit-functions} 通道按以下方式转换它们。

\begin{tabular}{lll}
\begin{minipage}{0.2\textwidth}
\begin{lstlisting}
  (|$e_0$| |$e_1$| |$\ldots$| |$e_n$|) 
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.4\textwidth}
\begin{lstlisting}
(|$e_0$| |$e_1 \ldots e_5$| (vector |$e_6 \ldots e_n$|))
\end{lstlisting}
\end{minipage}
\end{tabular}


\section{去除复杂的操作数}
\label{sec:rco-r4}

要做的主要决定是将
\code{FunRef} 和 \code{Apply} 分类为原子表达式还是复杂表达式。回想一下，一个简单的表达式最终只是x86指令的一个直接参数。函数应用将被翻译成一个指令序列，因此
\code{Apply} 必须归类为复杂表达式。
另一方面， \code{Apply} 的参数应该是原子表达式。
%
如上所述，对于 \code{FunRef} ，需要使用 \code{leaq} 指令将函数标签转换为地址。因此，尽管 \code{FunRef} 看起来相当简单，但需要将它归类为一个复杂表达式，以便生成一个左侧可作为
\code{leaq} 目标的赋值语句。图~\ref{fig:Rfun-anf-syntax} 定义这个通道的输出语言 \LangFunANF{} 。

\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\small
\[
\begin{array}{rcl}
  \Atm &::=& \gray{ \INT{\Int} \mid \VAR{\Var} \mid \BOOL{\itm{bool}} 
       \mid \VOID{} } \\
\Exp &::=& \gray{ \Atm \mid \READ{} } \\
   &\mid& \gray{ \NEG{\Atm} \mid \ADD{\Atm}{\Atm} } \\
   &\mid& \gray{ \LET{\Var}{\Exp}{\Exp} } \\
   &\mid& \gray{ \UNIOP{\key{'not}}{\Atm} } \\
   &\mid& \gray{ \BINOP{\itm{cmp}}{\Atm}{\Atm} \mid \IF{\Exp}{\Exp}{\Exp} }\\
   &\mid& \gray{ \LP\key{Collect}~\Int\RP \mid \LP\key{Allocate}~\Int~\Type\RP
  \mid \LP\key{GlobalValue}~\Var\RP }\\
   &\mid& \FUNREF{\Var} \mid \APPLY{\Atm}{\Atm\ldots}\\
 \Def &::=& \gray{ \FUNDEF{\Var}{([\Var \code{:} \Type]\ldots)}{\Type}{\code{'()}}{\Exp} }\\
R^{\dagger}_4  &::=& \gray{ \PROGRAMDEFS{\code{'()}}{\Def} }
\end{array}
\]
\end{minipage}
}
\caption{\LangFunANF{} 是行政范式(ANF)中的 \LangFun{} 。}
\label{fig:Rfun-anf-syntax}
\end{figure}


\section{解释控制和 \LangCFun{} 语言}
\label{sec:explicate-control-r4}

图~\ref{fig:c3-syntax} 定义 \LangCFun{} 的抽象语法，即 \key{explicate-control} 的输出。 (附录的图~\ref{fig:c3-concrete-syntax} 给出具体的语法。) 赋值和尾部上下文的辅助功能应使用 \code{Apply} 和 \code{FunRef} 的用例进行更新，谓词上下文的功能应针对 \code{Apply} 而不是
\code{FunRef} 进行更新。( \code{FunRef} 不能是布尔值。) 在赋值和谓词上下文中， \code{Apply} 变成 \code{Call} ，而在尾部位置 \code{Apply} 变成 \code{TailCall} 。建议定义一个新的辅助函数来处理函数定义。
这段代码类似于 \LangVec{} 中的 \code{Program} 。然后，处理 \LangFun{} \code{ProgramDefs} 形式的顶级 \code{explicate-control} 功能，可以将此新功能应用于所有功能定义。


\begin{figure}[tp]
\fbox{
\begin{minipage}{0.96\textwidth}
\small
\[
\begin{array}{lcl}
\Atm &::=& \gray{ \INT{\Int} \mid \VAR{\Var} \mid \BOOL{\itm{bool}} }\\
\itm{cmp} &::= & \gray{  \key{eq?} \mid \key{<} } \\
\Exp &::= & \gray{ \Atm \mid \READ{} } \\
   &\mid& \gray{ \NEG{\Atm} \mid \ADD{\Atm}{\Atm} }\\
   &\mid& \gray{ \UNIOP{\key{not}}{\Atm} \mid \BINOP{\itm{cmp}}{\Atm}{\Atm}  } \\
   &\mid& \gray{ \LP\key{Allocate} \,\itm{int}\,\itm{type}\RP } \\
   &\mid& \gray{ \BINOP{\key{'vector-ref}}{\Atm}{\INT{\Int}}  }\\
   &\mid& \gray{ \LP\key{Prim}~\key{'vector-set!}\,\LP\key{list}\,\Atm\,\INT{\Int}\,\Atm\RP\RP }\\
   &\mid& \gray{ \LP\key{GlobalValue} \,\Var\RP \mid \LP\key{Void}\RP }\\
   &\mid& \FUNREF{\itm{label}} \mid \CALL{\Atm}{\LP\Atm\ldots\RP} \\
\Stmt &::=& \gray{ \ASSIGN{\VAR{\Var}}{\Exp} 
       \mid \LP\key{Collect} \,\itm{int}\RP } \\
\Tail &::= & \gray{ \RETURN{\Exp} \mid \SEQ{\Stmt}{\Tail} 
       \mid \GOTO{\itm{label}} } \\
    &\mid& \gray{ \IFSTMT{\BINOP{\itm{cmp}}{\Atm}{\Atm}}{\GOTO{\itm{label}}}{\GOTO{\itm{label}}}  }\\
    &\mid& \TAILCALL{\Atm}{\Atm\ldots} \\
\Def &::=& \DEF{\itm{label}}{\LP[\Var\key{:}\Type]\ldots\RP}{\Type}{\itm{info}}{\LP\LP\itm{label}\,\key{.}\,\Tail\RP\ldots\RP}\\
\LangCFun{} & ::= & \PROGRAMDEFS{\itm{info}}{\LP\Def\ldots\RP} 
\end{array}
\]
\end{minipage}
}
\caption{ \LangCFun{}  的抽象语法扩展 \LangCVec{} (图~\ref{fig:c2-syntax})。}
\label{fig:c3-syntax}
\end{figure}


\section{选择指令和 \LangXIndCall{} 语言}
\label{sec:select-r4}
\index{instruction selection}

选择指令的输出是一个使用 \LangXIndCall{} 语言的程序，其语法在图~\ref{fig:x86-3} 中定义。
\index{x86}

\begin{figure}[tp]
\fbox{
\begin{minipage}{0.96\textwidth}
\small
\[
\begin{array}{lcl}
  \Arg &::=& \gray{ \key{\$}\Int \mid \key{\%}\Reg \mid \Int\key{(}\key{\%}\Reg\key{)} \mid \key{\%}\itm{bytereg} } \mid \Var \key{(\%rip)} 
   \mid \LP\key{fun-ref}\; \itm{label}\RP\\
\itm{cc} & ::= & \gray{  \key{e} \mid \key{l} \mid \key{le} \mid \key{g} \mid \key{ge}  } \\
\Instr &::=& \ldots
     \mid \key{callq}\;\key{*}\Arg \mid \key{tailjmp}\;\Arg 
     \mid \key{leaq}\;\Arg\key{,}\;\key{\%}\Reg \\
\Block &::= & \Instr\ldots \\
\Def &::= & \LP\key{define} \; \LP\itm{label}\RP \;\LP\LP\itm{label} \,\key{.}\, \Block\RP\ldots\RP\RP\\
\LangXIndCall{} &::= & \Def\ldots
\end{array}
\]
\end{minipage}
}
\caption{ \LangXIndCall{} 的具体语法(扩展图~\ref{fig:x86-2-concrete} 中的 \LangXGlobal{})。}
\label{fig:x86-3-concrete}
\end{figure}

\begin{figure}[tp]
\fbox{
  \begin{minipage}{0.96\textwidth}
    \small
\[
\begin{array}{lcl}
  \Arg &::=&  \gray{  \INT{\Int} \mid \REG{\Reg} \mid \DEREF{\Reg}{\Int}
     \mid \BYTEREG{\Reg} } \\
     &\mid& \gray{ (\key{Global}~\Var) } \mid \FUNREF{\itm{label}} \\
  \Instr &::=& \ldots \mid \INDCALLQ{\Arg}{\itm{int}}
    \mid \TAILJMP{\Arg}{\itm{int}}\\
    &\mid& \BININSTR{\code{'leaq}}{\Arg}{\REG{\Reg}}\\
  \Block &::= & \BLOCK{\itm{info}}{\LP\Instr\ldots\RP}\\
  \Def &::= & \DEF{\itm{label}}{\code{'()}}{\Type}{\itm{info}}{\LP\LP\itm{label}\,\key{.}\,\Block\RP\ldots\RP} \\
\LangXIndCall{} &::= & \PROGRAMDEFS{\itm{info}}{\LP\Def\ldots\RP}
\end{array}
\]
\end{minipage}
}
\caption{ \LangXIndCall{} 的抽象语法(扩展图~\ref{fig:x86-2} 中的 \LangXGlobal{})。}
\label{fig:x86-3}
\end{figure}


将函数引用赋值给变量成为load-effective-address指令，如下所示： \\
\begin{tabular}{lcl}
\begin{minipage}{0.35\textwidth}
\begin{lstlisting}
  |$\itm{lhs}$| = (fun-ref |$f$|);
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$\qquad\qquad
&
\begin{minipage}{0.3\textwidth}
\begin{lstlisting}
leaq (fun-ref |$f$|), |$\itm{lhs}'$|
\end{lstlisting}
\end{minipage}
\end{tabular} \\

关于函数定义，需要删除参数，并使用第~\ref{sec:fun-x86}节中讨论的约定来执行参数传递。也就是说，参数是在寄存器中传递的。建议将形参转换为局部变量，并在函数开始时生成指令，将传递寄存器的实参转移到这些局部变量。
\begin{lstlisting}
  (Def |$f$| '([|$x_1$| : |$T_1$|] [|$x_2$| : |$T_2$|]  |$\ldots$| ) |$T_r$| |$\itm{info}$| |$G$|)
  |$\Rightarrow$|
  (Def |$f$| '() 'Integer |$\itm{info}'$| |$G'$|)
\end{lstlisting}
 $G'$ 控制流图与 $G$ 一样；除了
\code{start} 块被修改为添加从参数寄存器移动到参数变量的指令。所以左边显示的 $G$ 的 \code{start}
块被更改为右边的代码。
\begin{center}
\begin{minipage}{0.3\textwidth}
\begin{lstlisting}
start:
  |$\itm{instr}_1$|
  |$\vdots$|
  |$\itm{instr}_n$|
\end{lstlisting}
\end{minipage}
$\Rightarrow$
\begin{minipage}{0.3\textwidth}
\begin{lstlisting}
start:
  movq %rdi, |$x_1$|
  movq %rsi, |$x_2$|
  |$\vdots$|
  |$\itm{instr}_1$|
  |$\vdots$|
  |$\itm{instr}_n$|
\end{lstlisting}
\end{minipage}
\end{center}
通过将参数更改为局部变量，让寄存器分配器控制使用哪个寄存器或堆栈位置。如果你实现了移动偏置挑战(第~\ref{sec:move-biasing}节)，寄存器分配器尝试将参数变量分配给相应的实参寄存器，在这种情况下， \code{patch-instructions}通道将删除
\code{movq} 指令。这在第~\ref{sec:functions-example}
节的图~\ref{fig:add-fun} 中的 \code{add} 函数的示例转换中发生。
%
另外，请注意，寄存器分配器将对这个移动指令序列进行动态分析，并构建干涉图。例如， $x_1$ 将被标记为干扰
\code{rsi} ，这将阻止将 $x_1$ 赋值给
\code{rsi} ，这很好，因为这会覆盖需要移到 $x_2$ 的参数。

接下来，考虑函数调用的编译。在处理函数定义的形参的镜像中，需要将实参移动到实参传递寄存器中。函数调用本身是通过间接函数调用来执行的。函数的返回值存储在 \code{rax} 中，因此需要将其移动到 \itm{lhs} 中。
\begin{lstlisting}
  |\itm{lhs}| = (call |\itm{fun}| |$\itm{arg}_1~\itm{arg}_2\ldots$|));
  |$\Rightarrow$|
  movq |$\itm{arg}_1$|, %rdi
  movq |$\itm{arg}_2$|, %rsi
  |$\vdots$|
  callq *|\itm{fun}|
  movq %rax, |\itm{lhs}|
\end{lstlisting}
 \code{IndirectCallq} AST 节点包含一个整数来表示函数的数量，即参数的数量。该信息在 \code{uncover-live} 通道中非常有用，可以用来确定调用期间可能读取哪些参数传递寄存器。

对于尾部调用，传递的参数与非尾部调用相同：生成指令将参数移动到参数传递寄存器中。之后，需要从过程调用堆栈中弹出帧。然而，还不知道这个框架有多大；这是在寄存器分配期间决定的。因此，没有在这里生成这些指令，而是发明一个新指令，意思是“弹出帧，然后进行间接跳转”，将其命名为
\code{TailJmp} 。该指令的抽象语法包括一个参数(指定跳转到哪里)和一个整数(表示被调用函数的数量)。

回想一下，在第~\ref{sec:explicate-control-Rvar} 节中，建议在程序的初始块中使用标签 \code{start} ，在第~\ref{sec:select-Rvar} 节中，建议用 \code{conclusion} 标记程序的结尾，这样 $(\key{Return}\;\Arg)$
就可以被编译为对 \code{rax} 的赋值，然后跳转到
\code{conclusion} 。通过添加函数定义，每个函数都有一个开始块和结论，但是它们的标签必须是唯一的。建议将函数名分别放在 \code{start} 和 \code{conclusion} 前面，以获得唯一的标签。(或者，可以使用 \code{gensym} 标签作为开始和结束，并将它们存储在函数定义的 $\itm{info}$ 字段中。)


\section{寄存器分配}
\label{sec:register-allocation-r4}


\subsection{活性分析}
\label{sec:liveness-analysis-r4}
\index{liveness analysis}

%% The rest of the passes need only minor modifications to handle the new
%% kinds of AST nodes: \code{fun-ref}, \code{indirect-callq}, and
%% \code{leaq}. 

 \code{IndirectCallq} 指令应该像
\code{Callq} 一样对待其写入位置 $W$ ，因为它们应该包括所有调用者保存的寄存器。回想一下，这样做的原因是强制将调用活动变量分配给被调用保存的寄存器，或者将其溢出到堆栈中。

对于读位置集合 $R$ ，
\code{TailJmp} 和 \code{IndirectCallq} 的属性字段决定这些指令应该读取多少传递参数的寄存器。

\subsection{建立干涉图}
\label{sec:build-interference-r4}

通过添加函数定义，计算每个函数的干涉图(而不是整个程序的干涉图)。

回想一下，在第~\ref{sec:reg-alloc-gc} 节中，讨论在
\code{collect} 调用期间溢出vector类型变量的必要性。在语言中添加函数之后，需要重新讨论这个问题。许多函数执行分配，因此在它们内部有对收集器的调用。因此，不仅应该在 \code{collect} 调用期间泄漏vector类型的变量，而且应该在任何函数调用期间泄漏该变量。因此，在 \code{build-interference} 通道中，建议在调用实时向量类型的变量和被调用者保存的寄存器之间添加干扰边(除了通常在调用实时变量和被调用者保存的寄存器之间添加边)。


\subsection{配置寄存器}

 \code{allocate-registers}的主要变化是添加一个辅助函数来处理函数定义 (图~\ref{fig:x86-3} 中的 \Def{} 非终端) 。其逻辑与第~\ref{ch:register-allocation-Rvar} 章中描述的相同，除了现在寄存器分配被多次执行，为每个函数定义一次，而不是为整个程序一次。


\section{补丁说明}

在 \code{patch-instructions} 中，你应该处理x86的特性，即 \code{leaq} 的目标参数必须是一个寄存器。此外，应该确保
\code{TailJmp} 的参数是我们的保留寄存器 \itm{rax}---这是为了使代码生成更方便，因为在尾部调用之前破坏了许多寄存器(如下一节所述)。

\section{打印 x86}

对于 \code{print-x86} 通道， \code{FunRef} 和
\code{IndirectCallq} 的情况很简单：输出它们的具体语法。
\begin{lstlisting}
  (FunRef |\itm{label}|) |$\Rightarrow$| |\itm{label}|(%rip)
  (IndirectCallq |\itm{arg}| |\itm{int}|) |$\Rightarrow$| callq *|\itm{arg}'|
\end{lstlisting}

 \code{TailJmp} 节点需要一些工作。 \code{TailJmp} 的一个简单的翻译是 \code{jmp *$\itm{arg}$} ，但在跳转之前，需要弹出当前帧。这个指令序列与函数的结尾代码相同，除了 \code{retq} 被替换为 \code{jmp *$\itm{arg}$} 。

关于函数定义，需要为每个函数生成一个前奏和结论。这段代码类似于在第~\ref{ch:Rvec} 章中生成的 \code{main} 函数的前奏和结论。回顾一下，每个函数的前奏应执行以下步骤。
\begin{enumerate}
\item 以 \code{.global} 和 \code{.align} 指令开头，后面跟着函数的标签。(示例见图~\ref{fig:add-fun} 。)
\item 将 \code{rbp} 推入堆栈，并将 \code{rbp} 设置为当前堆栈指针。
\item 将所有被调用者保存的用于寄存器分配的寄存器推入堆栈。
\item 将堆栈指针 \code{rsp} 向下移动到此函数的堆栈帧的大小，这取决于常规溢出的数量。(对齐到16字节)
\item 将根堆栈指针 \code{r15} 向上移动到这个函数的根堆栈帧的大小，这取决于溢出向量的数量。 \label{root-stack-init}
\item 将根堆栈框架中的所有条目初始化为零。
\item 跳到开始块上。
\end{enumerate}
 \code{main} 函数的前段有一个附加任务：调用 \code{initialize} 函数来设置垃圾收集器，并在\code{r15} 中移动全局 \code{rootstack\_begin} 的值。这应该发生在上面的第\ref{root-stack-init}
步之前，这取决于 \code{r15} 。

每个函数的结论应该做以下工作。
\begin{enumerate}
\item 将堆栈指针按此函数的堆栈帧的大小向上移动。
\item 通过将被调用保存的寄存器从堆栈中取出来恢复它们。
\item 将根堆栈指针向下移动到此函数的根堆栈框架的大小。
\item 通过将 \code{rbp} 从堆栈中取出来恢复它。
\item 使用 \code{retq} 指令返回到调用者。
\end{enumerate}


\begin{exercise}\normalfont
如本章所述，展开你的编译器来处理 \LangFun{} 。创建5个使用函数的新程序，包括从其他函数传递函数和返回函数的例子，递归函数，创建向量的函数，以及进行尾部调用的函数。在这些新程序和之前创建的所有测试程序上测试编译器。
\end{exercise}


\begin{figure}[tbp]
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (Rfun) at (0,2)  {\large \LangFun{}};
\node (Rfun-1) at (3,2)  {\large \LangFun{}};
\node (Rfun-2) at (6,2)  {\large \LangFun{}};
\node (F1-1) at (12,0)  {\large \LangFunRef{}};
\node (F1-2) at (9,0)  {\large \LangFunRef{}};
\node (F1-3) at (6,0)  {\large \LangFunRefAlloc{}};
\node (F1-4) at (3,0)  {\large \LangFunRefAlloc{}};
\node (C3-2) at (3,-2)  {\large \LangCFun{}};

\node (x86-2) at (3,-4)  {\large \LangXIndCallVar{}};
\node (x86-3) at (6,-4)  {\large \LangXIndCallVar{}};
\node (x86-4) at (9,-4) {\large \LangXIndCall{}};
\node (x86-5) at (9,-6) {\large \LangXIndCall{}};

\node (x86-2-1) at (3,-6)  {\large \LangXIndCallVar{}};
\node (x86-2-2) at (6,-6)  {\large \LangXIndCallVar{}};

\path[->,bend left=15] (Rfun) edge [above] node
     {\ttfamily\footnotesize shrink} (Rfun-1);
\path[->,bend left=15] (Rfun-1) edge [above] node
     {\ttfamily\footnotesize uniquify} (Rfun-2);
\path[->,bend left=15] (Rfun-2) edge [right] node
     {\ttfamily\footnotesize ~~reveal-functions} (F1-1);
\path[->,bend left=15] (F1-1) edge [below] node
     {\ttfamily\footnotesize limit-functions} (F1-2);
\path[->,bend right=15] (F1-2) edge [above] node
     {\ttfamily\footnotesize expose-alloc.} (F1-3);
\path[->,bend right=15] (F1-3) edge [above] node
     {\ttfamily\footnotesize remove-complex.} (F1-4);
\path[->,bend left=15] (F1-4) edge [right] node
     {\ttfamily\footnotesize explicate-control} (C3-2);
\path[->,bend right=15] (C3-2) edge [left] node
     {\ttfamily\footnotesize select-instr.} (x86-2);
\path[->,bend left=15] (x86-2) edge [left] node
     {\ttfamily\footnotesize uncover-live} (x86-2-1);
\path[->,bend right=15] (x86-2-1) edge [below] node 
     {\ttfamily\footnotesize build-inter.} (x86-2-2);
\path[->,bend right=15] (x86-2-2) edge [left] node
     {\ttfamily\footnotesize allocate-reg.} (x86-3);
\path[->,bend left=15] (x86-3) edge [above] node
     {\ttfamily\footnotesize patch-instr.} (x86-4);
\path[->,bend right=15] (x86-4) edge [left] node {\ttfamily\footnotesize print-x86} (x86-5);
\end{tikzpicture}
\caption{具有函数的语言 \LangFun{} 的通道图}
\label{fig:Rfun-passes}
\end{figure}

图~\ref{fig:Rfun-passes} 概述将 \LangFun{} 编译到x86的过程。

\section{一个例子的翻译}
\label{sec:functions-example}

图~\ref{fig:add-fun} 显示一个简单函数在 \LangFun{} 到x86转换的示例。图中还包括
\code{explicate-control} 和 \code{select-instructions} 通道的结果。

\begin{figure}[htbp]
\begin{tabular}{ll}
\begin{minipage}{0.5\textwidth}
% s3_2.rkt
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
(define (add [x : Integer] [y : Integer])
   : Integer
   (+ x y))
(add 40 2)
\end{lstlisting}
$\Downarrow$
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
(define (add86 [x87 : Integer]
                 [y88 : Integer]) : Integer
   add86start:
      return (+ x87 y88);
   )
(define (main) : Integer ()
   mainstart:
      tmp89 = (fun-ref add86);
      (tail-call tmp89 40 2)
   )
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
\begin{minipage}{0.5\textwidth}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
(define (add86) : Integer
   add86start:
      movq %rdi, x87
      movq %rsi, y88
      movq x87, %rax
      addq y88, %rax
      jmp add11389conclusion
   )
(define (main) : Integer
   mainstart:
      leaq (fun-ref add86), tmp89
      movq $40, %rdi
      movq $2, %rsi
      tail-jmp tmp89
   )
\end{lstlisting}
$\Downarrow$
\end{minipage}
\end{tabular}
\begin{tabular}{ll}
\begin{minipage}{0.3\textwidth}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
	.globl add86
	.align 16
add86:
	pushq	%rbp
	movq	%rsp, %rbp
	jmp	add86start
add86start:
	movq	%rdi, %rax
	addq	%rsi, %rax
	jmp add86conclusion
add86conclusion:
	popq	%rbp
	retq
\end{lstlisting}
\end{minipage}
&
\begin{minipage}{0.5\textwidth}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
	.globl main
	.align 16
main:
	pushq	%rbp
	movq	%rsp, %rbp
	movq	$16384, %rdi
	movq	$16384, %rsi
	callq	initialize
	movq	rootstack_begin(%rip), %r15
	jmp	mainstart
mainstart:
	leaq	add86(%rip), %rcx
	movq	$40, %rdi
	movq	$2, %rsi
	movq	%rcx, %rax
	popq	%rbp
	jmp	*%rax
mainconclusion:
	popq	%rbp
	retq
\end{lstlisting}
\end{minipage}
\end{tabular}
\caption{一个简单函数在x86上的编译示例。}
\label{fig:add-fun}
\end{figure}


% Challenge idea: inlining! (simple version)

% Further Reading

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{词法作用域的函数}
\label{ch:Rlam}
\index{lambda}
\index{lexical scoping}

本章研究在像Racket这样的函数语言中出现的词法作用域函数。词法作用域是指函数体可以引用绑定位置在函数外部、在封闭作用域中的变量。
%
考虑图~\ref{fig:lexical-scoping} 中用
\LangLam{} 编写的例子，它使用 \key{lambda} 形式扩展 \LangFun{} 的匿名函数。 \key{lambda} 的体引用三个变量： \code{x} 、 \code{y} 和 \code{z} 。
\code{x} 和 \code{y} 的结合位点在 \key{lambda} 之外。变量
\code{y} 以外围 \key{let} 为界， \code{x} 是函数 \code{f} 的参数。 \key{lambda} 是从函数 \code{f} 中返回 。程序的主表达式包括两次对 \code{f} 的调用，使用 \code{x} 的不同参数，先是
\code{5} ，然后是 \code{3} 。从 \code{f} 返回的函数被绑定到变量 \code{g} 和 \code{h} 。尽管这两个函数是由同一个 \code{lambda}创建的，但它们实际上是不同的函数，因为它们对 \code{x} 使用不同的值。对 \code{11} 加 \code{g} 得到 \code{20} ，而对 \code{15} 加 \code{h} 得到 \code{22} 。这个程序的结果是 \code{42} 。

\begin{figure}[btp]
% s4_6.rkt
\begin{lstlisting}
   (define (f [x : Integer]) : (Integer -> Integer)
      (let ([y 4])
         (lambda: ([z : Integer]) : Integer
            (+ x (+ y z)))))

   (let ([g (f 5)])
     (let ([h (f 3)])
       (+ (g 11) (h 15))))
\end{lstlisting}
\caption{一个词法作用域函数的示例。}
\label{fig:lexical-scoping}
\end{figure}


实现词法作用域函数的方法是将它们编译为顶级函数定义，从 \LangLam{} 转换为 \LangFun{} 。但是，编译器需要对图 ~\ref{fig:lexical-scoping} 中的 \code{lambda} 中的 \code{x}
和 \code{y} 等变量进行特殊处理。毕竟， \LangFun{} 函数不能引用外部定义的变量。为了识别这些变量的出现，回顾自由变量的标准概念。

\begin{definition}
如果一个变量出现在 $e$ 中，但在 $e$ 中没有封闭绑定，那么它在表达式 $e$ 中是 \emph{自由} 的。\index{free
  variable}
\end{definition}

例如，在表达式 \code{(+ x (+ y z))} 中，变量
\code{x} 、 \code{y} 和 \code{z} 都是自由的。另一方面，在下面的表达式中只有 \code{x} 和 \code{y} 是自由的，因为 \code{z} 受 \code{lambda} 的限制。
\begin{lstlisting}
   (lambda: ([z : Integer]) : Integer
      (+ x (+ y z)))
\end{lstlisting}

所以， \code{lambda} 的自由变量是需要特殊处理的。需要安排某种方式，在运行时将这些变量的值从创建
\code{lambda} 的地方传输到应用 \code{lambda} 的地方。由于
\citet{Cardelli:1983aa} ，这个问题的一个有效解决方案是将自由变量的值与lambda代码的函数指针捆绑到一个向量中，这种安排称为 \emph{扁平闭包} (将其缩短为“闭包”) 。 \index{closure}\index{flat closure}幸运的是，已经具备闭包的所有要素，第~\ref{ch:Rvec}
章给出向量，第~\ref{ch:Rfun} 章给出函数指针。函数指针驻留在索引 $0$ 处，自由变量的值将填充向量的其余部分。

回顾一下图~\ref{fig:lexical-scoping} 中的示例，看看闭包是如何工作的。分三步。程序首先调用函数 \code{f} ，它为 \code{lambda} 创建一个闭包。闭包是一个向量，它的第一个元素是一个指针，指向我们将为 \code{lambda} 生成的顶级函数，第二个元素是 \code{x} 的值，即 \code{5}，第三个元素是 \code{4} ，即 \code{y} 的值。闭包不包含 \code{z} 的元素，因为 \code{z} 不是 \code{lambda} 的自由变量。创建结束是第一步。闭包从 \code{f} 返回并绑定到 \code{g} ，如图~\ref{fig:closures} 所示。
%
对 \code{f} 的第二次调用创建另一个闭包，这一次
\code{3} 在第二个槽中(用于 \code{x}) 。这个闭包也从 \code{f} 返回，但绑定到 \code{h} ，如图~\ref{fig:closures} 所示。

\begin{figure}[tbp]
\centering \includegraphics[width=0.6\textwidth]{figs/closures}
\caption{~\ref{fig:lexical-scoping} 中的 \key{lambda} 闭包表示示例。}
\label{fig:closures}
\end{figure}

继续这个示例，考虑图~\ref{fig:lexical-scoping} 中 \code{g} 对
\code{11} 的应用。要应用闭包，我们获取闭包第一个元素中的函数指针并调用它，传入闭包本身，然后传入常规参数，在本例中是 \code{11} 。这种应用闭包的技巧是第二步。
%
但是对于参数 \code{z} ，这个 \code{lambda} 不是只有一个参数吗？第三步也是最后一步是为 \code{lambda} 生成顶层函数。为闭包添加一个附加参数，并在每个自由变量的函数开始处插入 \code{let} ，以便将这些变量绑定到闭包参数中的适当元素。
%
这种三步被称为 \emph{闭合转换} 。在第~\ref{sec:closure-conversion} 节讨论闭包转换的细节，并从第~\ref{sec:example-lambda} 节的示例中生成代码。但是首先在 ~\ref{sec:r5} 节中定义 \LangLam{} 的语法和语义。

\section{ \LangLam{} 语言}
\label{sec:r5}

图~\ref{fig:Rlam-concrete-syntax} 和 ~\ref{fig:Rlam-syntax} 定义 \LangLam{} 的具体和抽象语法，这是一种具有匿名函数和词法作用域的语言。它将 \key{lambda} 表单添加到 \LangFun{} 的语法中， \LangFun{} 已经有用于函数应用程序的语法。

\begin{figure}[tp]
\centering
\fbox{
  \begin{minipage}{0.96\textwidth}
    \small
\[
\begin{array}{lcl}
  \Type &::=& \gray{\key{Integer} \mid \key{Boolean}
     \mid (\key{Vector}\;\Type\ldots) \mid \key{Void}
     \mid (\Type\ldots \; \key{->}\; \Type)} \\
  \Exp &::=& \gray{ \Int \mid \CREAD{} \mid \CNEG{\Exp}
     \mid \CADD{\Exp}{\Exp} \mid \CSUB{\Exp}{\Exp} }  \\
    &\mid&  \gray{ \Var \mid \CLET{\Var}{\Exp}{\Exp} }\\
    &\mid& \gray{\key{\#t} \mid \key{\#f} 
     \mid (\key{and}\;\Exp\;\Exp) 
     \mid (\key{or}\;\Exp\;\Exp) 
     \mid (\key{not}\;\Exp) } \\
    &\mid& \gray{ (\key{eq?}\;\Exp\;\Exp) \mid \CIF{\Exp}{\Exp}{\Exp} } \\
    &\mid& \gray{ (\key{vector}\;\Exp\ldots) \mid
          (\key{vector-ref}\;\Exp\;\Int)} \\
    &\mid& \gray{(\key{vector-set!}\;\Exp\;\Int\;\Exp)\mid (\key{void})
    \mid (\Exp \; \Exp\ldots) } \\
    &\mid& \LP \key{procedure-arity}~\Exp\RP \\
    &\mid& \CLAMBDA{\LP\LS\Var \key{:} \Type\RS\ldots\RP}{\Type}{\Exp} \\
  \Def &::=& \gray{ \CDEF{\Var}{\LS\Var \key{:} \Type\RS\ldots}{\Type}{\Exp} } \\
  \LangLam{} &::=& \gray{\Def\ldots \; \Exp}
\end{array}
\]
\end{minipage}
}
\caption{ \LangLam{}的具体语法，用 \key{lambda} 扩展 \LangFun{} (图~\ref{fig:Rfun-concrete-syntax}) 。}
\label{fig:Rlam-concrete-syntax}
\end{figure}

\begin{figure}[tp]
\centering
\fbox{
  \begin{minipage}{0.96\textwidth}
    \small
\[
\begin{array}{lcl}
  \itm{op} &::=& \ldots \mid \code{procedure-arity} \\
  \Exp &::=& \gray{ \INT{\Int} \VAR{\Var} \mid \LET{\Var}{\Exp}{\Exp} } \\
       &\mid& \gray{ \PRIM{\itm{op}}{\Exp\ldots} }\\
     &\mid& \gray{ \BOOL{\itm{bool}}
      \mid \IF{\Exp}{\Exp}{\Exp} } \\
     &\mid& \gray{ \VOID{} \mid \LP\key{HasType}~\Exp~\Type \RP 
     \mid \APPLY{\Exp}{\Exp\ldots} }\\
     &\mid& \LAMBDA{\LP\LS\Var\code{:}\Type\RS\ldots\RP}{\Type}{\Exp}\\
 \Def &::=& \gray{ \FUNDEF{\Var}{\LP\LS\Var \code{:} \Type\RS\ldots\RP}{\Type}{\code{'()}}{\Exp} }\\
  \LangLam{} &::=& \gray{ \PROGRAMDEFSEXP{\code{'()}}{\LP\Def\ldots\RP}{\Exp} }
\end{array}
\]
\end{minipage}
}
\caption{ \LangLam{} 的抽象语法，扩展 \LangFun{} (图~\ref{fig:Rfun-syntax})。}
\label{fig:Rlam-syntax}
\end{figure}

\index{interpreter}
\label{sec:interp-Rlambda}

图~\ref{fig:interp-Rlambda} 显示
\LangLam{} 的定义解释程序。 \key{lambda} 的大小写将当前环境保存在返回的 \key{lambda} 中。 \key{Apply} 的例子在解释 \key{lambda} 的主体时使用 \key{lambda} 中的环境，即 \code{lam-env} 。 \code{lam-env}
环境通过参数到参数值的映射进行扩展。

\begin{figure}[tbp]
\begin{lstlisting}
(define interp-Rlambda-class
  (class interp-Rfun-class
    (super-new)

    (define/override (interp-op op)
      (match op
        ['procedure-arity
         (lambda (v)
           (match v
             [`(function (,xs ...) ,body ,lam-env)  (length xs)]
             [else (error 'interp-op "expected a function, not ~a" v)]))]
        [else (super interp-op op)]))

    (define/override ((interp-exp env) e)
      (define recur (interp-exp env))
      (match e
        [(Lambda (list `[,xs : ,Ts] ...) rT body)
         `(function ,xs ,body ,env)]
        [else ((super interp-exp env) e)]))
    ))

(define (interp-Rlambda p)
  (send (new interp-Rlambda-class) interp-program p))
\end{lstlisting}
\caption{ \LangLam{} 的翻译。}
\label{fig:interp-Rlambda}
\end{figure}


\label{sec:type-check-r5}
\index{type checking}

图~\ref{fig:type-check-Rlambda} 显示如何键入检查新的
\key{lambda} 表单。 \key{lambda} 的主体是在包含当前环境(因为它是词法范围内的)的环境中检查的，并且还包括 \key{lambda} 的参数。我们要求主体的类型与声明的返回类型匹配。

\begin{figure}[tbp]
\begin{lstlisting}
(define (type-check-Rlambda env)
  (lambda (e)
    (match e
      [(Lambda (and params `([,xs : ,Ts] ...)) rT body)
       (define-values (new-body bodyT) 
          ((type-check-exp (append (map cons xs Ts) env)) body))
       (define ty `(,@Ts -> ,rT))
       (cond
         [(equal? rT bodyT)
           (values (HasType (Lambda params rT new-body) ty) ty)]
         [else
           (error "mismatch in return type" bodyT rT)])]
      ...
      )))
\end{lstlisting}
\caption{类型检查 \key{lambda}' 中的 \LangLam{} 。}
\label{fig:type-check-Rlambda}
\end{figure}


\section{揭示函数和 $F_2$ 语言}
\label{sec:reveal-functions-r5}


为了支持 \code{procedure-arity} 操作符，需要将函数的arity传达给闭包创建点。可以通过将 $\FUNREF{\Var}$ 结构体替换为一个具有第二个属性的结构体来实现这一点： $\FUNREFARITY{\Var}{\Int}$ 。这个通道的输出是 $F_2$ 语言，其语法在图~\ref{fig:f2-syntax} 中定义。

\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{lcl}
\Exp &::=& \ldots \mid \FUNREFARITY{\Var}{\Int}\\
 \Def &::=& \gray{ \FUNDEF{\Var}{([\Var \code{:} \Type]\ldots)}{\Type}{\code{'()}}{\Exp} }\\
  F_2 &::=& \gray{\PROGRAMDEFS{\code{'()}}{\LP \Def\ldots \RP}}
\end{array}
\]
\end{minipage}
}
\caption{抽象语法 $F_2$ ， \LangLam{} 的扩展(图~\ref{fig:Rlam-syntax}) 。}
\label{fig:f2-syntax}
\end{figure}


\section{闭包转换}
\label{sec:closure-conversion}
\index{closure conversion}

将词汇作用域的函数编译为顶级函数定义是在 \code{convert-to-closures}
中完成的，该函数位于 \code{reveal-functions} 之后和
\code{limit-functions} 之前。

通常，将通道作为AST上的递归函数来实现。所有的操作都在 \key{Lambda} 和
\key{Apply} 的情况下。将 \key{Lambda} 表达式转换为创建闭包的表达式，即一个向量，其第一个元素是函数指针，其余元素是 \key{Lambda} 的自由变量。在这里使用结构 \code{Closure} 而不是 \code{vector} ，以便可以在第~\ref{sec:optimize-closures} 节中将闭包与vector区别开来，并记录Arity。在下面生成的代码中， \itm{name} 是用来识别函数的唯一符号， \itm{arity} 是参数的数量( \itm{ps} 的长度) 。
\begin{lstlisting}
(Lambda |\itm{ps}| |\itm{rt}| |\itm{body}|)
|$\Rightarrow$|
(Closure |\itm{arity}| (cons (FunRef |\itm{name}|) |\itm{fvs}|))
\end{lstlisting}
除了将每个 \key{Lambda} 转换为一个 \key{Closure} 之外，还为每个 \key{Lambda} 创建一个顶层函数定义，如下所示。\\
\begin{minipage}{0.8\textwidth}
\begin{lstlisting}
(Def |\itm{name}| ([clos : (Vector _ |\itm{fvts}| ...)] |\itm{ps'}| ...) |\itm{rt'}|
   (Let |$\itm{fvs}_1$| (Prim 'vector-ref (list (Var clos) (Int 1)))
     ...
     (Let |$\itm{fvs}_n$| (Prim 'vector-ref (list (Var clos) (Int |$n$|)))
       |\itm{body'}|)...))
\end{lstlisting}
\end{minipage}\\
 \code{clos} 参数指向闭包。转换 \itm{ps} 中的类型注释和返回类型 \itm{rt} ，如下一段所讨论的，以获得 \itm{ps'} 和 \itm{rt'} 。
$\itm{fvts}$ 类型是lambda中的自由变量的类型，而下划线 \code{\_} 是我们使用的虚拟类型，因为在闭包类型中给函数指定类型相当困难。\footnote{要给闭包一个准确的类型，需要向类型检查器添加存在类型~\citep{Minamide:1996ys}。}
在类型检查期间，虚拟类型被认为与任何其他类型相等。 \key{Let} 形式的序列将自由变量绑定到从闭包中获得的值上。

闭包转换将函数转换为向量，因此程序中的类型注释也必须进行转换。建议为此定义一个辅助递归函数。函数类型应按如下方式进行翻译。
\begin{lstlisting}
(|$T_1, \ldots, T_n$| -> |$T_r$|)
|$\Rightarrow$|  
(Vector ((Vector _) |$T'_1, \ldots, T'_n$| -> |$T'_r$|))
\end{lstlisting}

上面的类型表示向量中的第一件事是函数指针。函数指针的第一个参数是一个向量(一个闭包)，其余的参数来自原始函数，类型为 $T'_1 、 \ldots 、 T'_n$ 。闭包的 \code{Vector} 类型省略自由变量的类型，因为： 1) 这些类型在此上下文中不可用； 2) 不需要在为函数应用程序生成的代码中使用它们。

将函数应用程序转换为代码，从闭包中检索函数指针，然后调用该函数，将闭包作为第一个参数传入。将 $e'$ 绑定到一个临时变量，以避免代码重复。
\begin{lstlisting}
(Apply |$e$| |\itm{es}|)
|$\Rightarrow$|
(Let |\itm{tmp}| |$e'$|
  (Apply (Prim 'vector-ref (list (Var |\itm{tmp}|) (Int 0))) (cons |\itm{tmp}| |\itm{es'}|)))
\end{lstlisting}

还有一个问题是如何处理引用顶级函数定义。为了维护函数应用程序的统一翻译，将函数引用转换为闭包。

\begin{tabular}{lll}
\begin{minipage}{0.3\textwidth}
\begin{lstlisting}
(FunRefArity |$f$| |$n$|)
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.5\textwidth}
\begin{lstlisting}
(Closure |$n$| (FunRef |$f$|) '())
\end{lstlisting}
\end{minipage}
\end{tabular}  \\
%
顶层函数定义也需要更新，以接受一个额外的闭包参数。

\section{一个例子的翻译}
\label{sec:example-lambda}

图~\ref{fig:lexical-functions-example} 显示
\code{reveal-functions} 和 \code{convert-to-closures} 的结果，这个示例程序演示在本章开始时讨论的词法作用域。


\begin{figure}[tbp]
  \begin{minipage}{0.8\textwidth}
% tests/lambda_test_6.rkt
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
(define (f6 [x7 : Integer]) : (Integer -> Integer)
   (let ([y8 4])
      (lambda: ([z9 : Integer]) : Integer
         (+ x7 (+ y8 z9)))))

(define (main) : Integer
   (let ([g0 ((fun-ref-arity f6 1) 5)])
      (let ([h1 ((fun-ref-arity f6 1) 3)])
         (+ (g0 11) (h1 15)))))
\end{lstlisting}
$\Rightarrow$
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
(define (f6 [fvs4 : _] [x7 : Integer]) : (Vector ((Vector _) Integer -> Integer))
   (let ([y8 4])
      (closure 1 (list (fun-ref lambda2) x7 y8))))

(define (lambda2 [fvs3 : (Vector _ Integer Integer)] [z9 : Integer]) : Integer
   (let ([x7 (vector-ref fvs3 1)])
      (let ([y8 (vector-ref fvs3 2)])
         (+ x7 (+ y8 z9)))))

(define (main) : Integer
   (let ([g0 (let ([clos5 (closure 1 (list (fun-ref f6)))])
                    ((vector-ref clos5 0) clos5 5))])
      (let ([h1 (let ([clos6 (closure 1 (list (fun-ref f6)))])
                       ((vector-ref clos6 0) clos6 3))])
         (+ ((vector-ref g0 0) g0 11) ((vector-ref h1 0) h1 15)))))
\end{lstlisting}
\end{minipage}

\caption{闭包转换的示例。}
\label{fig:lexical-functions-example}
\end{figure}

\begin{exercise}\normalfont
扩展你的编译器来处理 \LangLam{} 在这一章概述。
创建5个使用 \key{lambda} 函数并利用词法作用域的新程序。在这些新程序和之前创建的所有测试程序上测试编译器。
\end{exercise}


\section{公开分配}
\label{sec:expose-allocation-r5}

编译 $\CLOSURE{\itm{arity}}{\LP\Exp\ldots\RP}$ 形式转换为代码，用于分配和初始化vector，类似于第~\ref{sec:expose-allocation} 节中 \code{vector} 操作符的转换。
唯一的区别是使用 \ALLOCCLOS{\itm{len}}{\itm{type}}{\itm{arity}} 替换 \ALLOC{\itm{len}}{\itm{type}} 。


\section{解释控制和 \LangCLam{}}
\label{sec:explicate-r5}

 \code{explicate-control} 的输出语言是 \LangCLam{} ，其抽象语法在图~\ref{fig:c4-syntax} 中定义。与 \LangCFun{} 的唯一区别是在 $\Exp$ 语法中添加
\code{AllocateClosure} 形式。\code{explicate-control}通道中的 \code{AllocateClosure} 的处理类似于对其他表达式(如原语操作符)的处理。

\begin{figure}[tp]
\fbox{
\begin{minipage}{0.96\textwidth}
\small
\[
\begin{array}{lcl}
\Exp &::= & \ldots
   \mid \ALLOCCLOS{\Int}{\Type}{\Int} \\
\Stmt &::=& \gray{ \ASSIGN{\VAR{\Var}}{\Exp} 
       \mid \LP\key{Collect} \,\itm{int}\RP } \\
\Tail &::= & \gray{ \RETURN{\Exp} \mid \SEQ{\Stmt}{\Tail} 
       \mid \GOTO{\itm{label}} } \\
    &\mid& \gray{ \IFSTMT{\BINOP{\itm{cmp}}{\Atm}{\Atm}}{\GOTO{\itm{label}}}{\GOTO{\itm{label}}}  }\\
    &\mid& \gray{ \TAILCALL{\Atm}{\Atm\ldots} } \\
\Def &::=& \gray{ \DEF{\itm{label}}{\LP[\Var\key{:}\Type]\ldots\RP}{\Type}{\itm{info}}{\LP\LP\itm{label}\,\key{.}\,\Tail\RP\ldots\RP} }\\
\LangCLam{} & ::= & \gray{ \PROGRAMDEFS{\itm{info}}{\LP\Def\ldots\RP} }
\end{array}
\]
\end{minipage}
}
\caption{ \LangCLam{} 的抽象语法，扩展 \LangCFun{} (图~\ref{fig:c3-syntax})。}
\label{fig:c4-syntax}
\end{figure}


\section{选择指令}
\label{sec:select-instructions-Rlambda}

编译 \ALLOCCLOS{\itm{len}}{\itm{type}}{\itm{arity}} 的方式几乎与 \ALLOC{\itm{len}}{\itm{type}} 形式(第~\ref{sec:select-instructions-gc} 节)相同。唯一的区别是，应该将 \itm{arity} 放在存储在向量 $0$ 位置的标记中。回想一下，在第~\ref{sec:select-instructions-gc} 节中没有使用64位标记的一部分。从 $58$ 号位置开始，把它存储在 $5$ 位中。

将 \code{procedure-arity} 操作符编译为一个指令序列，该指令从向量的位置 $0$ 访问标记，并从标记中提取从位置 $58$ 开始的 $5$ 位。

\begin{figure}[p]
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (Rfun) at (0,2)  {\large \LangFun{}};
\node (Rfun-2) at (3,2)  {\large \LangFun{}};
\node (Rfun-3) at (6,2)  {\large \LangFun{}};
\node (F1-1) at (12,0)  {\large \LangFunRef{}};
\node (F1-2) at (9,0)  {\large \LangFunRef{}};
\node (F1-3) at (6,0)  {\large $F_1$};
\node (F1-4) at (3,0)  {\large $F_1$};
\node (F1-5) at (0,0)  {\large $F_1$};
\node (C3-2) at (3,-2)  {\large \LangCFun{}};

\node (x86-2) at (3,-4)  {\large \LangXIndCallVar{}};
\node (x86-2-1) at (3,-6)  {\large \LangXIndCallVar{}};
\node (x86-2-2) at (6,-6)  {\large \LangXIndCallVar{}};
\node (x86-3) at (6,-4)  {\large \LangXIndCallVar{}};
\node (x86-4) at (9,-4) {\large \LangXIndCall{}};
\node (x86-5) at (9,-6) {\large \LangXIndCall{}};


\path[->,bend left=15] (Rfun) edge [above] node
     {\ttfamily\footnotesize shrink} (Rfun-2);
\path[->,bend left=15] (Rfun-2) edge [above] node
     {\ttfamily\footnotesize uniquify} (Rfun-3);
\path[->,bend left=15] (Rfun-3) edge [right] node
     {\ttfamily\footnotesize reveal-functions} (F1-1);
\path[->,bend left=15] (F1-1) edge [below] node
     {\ttfamily\footnotesize convert-to-clos.} (F1-2);
\path[->,bend right=15] (F1-2) edge [above] node
     {\ttfamily\footnotesize limit-fun.} (F1-3);
\path[->,bend right=15] (F1-3) edge [above] node
     {\ttfamily\footnotesize expose-alloc.} (F1-4);
\path[->,bend right=15] (F1-4) edge [above] node
     {\ttfamily\footnotesize remove-complex.} (F1-5);
\path[->,bend right=15] (F1-5) edge [right] node
     {\ttfamily\footnotesize explicate-control} (C3-2);
\path[->,bend left=15] (C3-2) edge [left] node
     {\ttfamily\footnotesize select-instr.} (x86-2);
\path[->,bend right=15] (x86-2) edge [left] node
     {\ttfamily\footnotesize uncover-live} (x86-2-1);
\path[->,bend right=15] (x86-2-1) edge [below] node 
     {\ttfamily\footnotesize build-inter.} (x86-2-2);
\path[->,bend right=15] (x86-2-2) edge [left] node
     {\ttfamily\footnotesize allocate-reg.} (x86-3);
\path[->,bend left=15] (x86-3) edge [above] node
     {\ttfamily\footnotesize patch-instr.} (x86-4);
\path[->,bend left=15] (x86-4) edge [right] node
     {\ttfamily\footnotesize print-x86} (x86-5);
\end{tikzpicture}
  \caption{ \LangLam{}的通道图，这是一种具有词汇作用域的函数的语言。}
\label{fig:Rlambda-passes}
\end{figure}

图~\ref{fig:Rlambda-passes} 提供编译 \LangLam{} 所需的所有通道的概述。

\clearpage

\section{挑战：优化闭包}
\label{sec:optimize-closures}

在本章中，将词汇作用域的函数编译成一个相对有效的表示：扁平闭包。然而，即使是这种表示也会带来一些开销。例如，考虑下面的程序，它的函数 \code{tail-sum} 没有任何自由变量，并且 \code{tail-sum} 所有用法都在我们知道仅应用 \code{tail-sum} 的应用程序中（而不是其他任何函数） 。
\begin{center}
\begin{minipage}{0.95\textwidth}
\begin{lstlisting}
(define (tail-sum [n : Integer] [r : Integer]) : Integer
  (if (eq? n 0)
      r
      (tail-sum (- n 1) (+ n r))))

(+ (tail-sum 5 0) 27)
\end{lstlisting}
\end{minipage}
\end{center}
如本章所述，统一地对所有函数应用闭包转换，得到这个程序的如下输出。
\begin{center}
\begin{minipage}{0.95\textwidth}
\begin{lstlisting}
(define (tail_sum1 [fvs5 : _] [n2 : Integer] [r3 : Integer]) : Integer
   (if (eq? n2 0)
      r3
      (let ([clos4 (closure (list (fun-ref tail_sum1)))])
         ((vector-ref clos4 0) clos4 (+ n2 -1) (+ n2 r3)))))

(define (main) : Integer
   (+ (let ([clos6 (closure (list (fun-ref tail_sum1)))])
         ((vector-ref clos6 0) clos6 5 0)) 27))
\end{lstlisting}
\end{minipage}
\end{center}

在前一章中，程序中没有分配，对\code{tail-sum} 的调用将是直接调用。相比之下，上面的程序为每个 \code{closure} 分配内存，对 \code{tail-sum} 的调用是间接的。这两个差异在这样的程序中产生相当大的开销，在这种程序中，分配和间接调用发生在一个紧密循环中。

有人可能认为这个问题是微不足道的解决：不能只是识别形式的调用 \code{((fun-ref $f$) $e_1 \ldots e_n$)}
，并编译它们直接调用 \code{((fun-ref $f$) $e'_1 \ldots
  e'_n$)} ，而不是把它作为一个闭包的调用？还将删除 \code{tail\_sum1} 的 \code{fvs5} 参数。
%
然而，这个问题并不是那么简单，因为全局函数可能会“转义”，并在也涉及闭包的应用程序中出现。考虑下面的例子，应用程序
\code{(f 41)} 需要被编译成一个闭包应用程序，因为 \code{lambda} 可能被绑定到 \code{f} ，但 \code{add1}
函数也可能被绑定到 \code{f} 。
\begin{lstlisting}
(define (add1 [x : Integer]) : Integer
  (+ x 1))

(let ([y (read)])
  (let ([f (if (eq? (read) 0)
               add1
               (lambda: ([x : Integer]) : Integer (- x y)))])
    (f 41)))
\end{lstlisting}
如果全局函数名不是直接调用中的操作符，而是以其他方式使用，则称该函数
\emph{转义} 。如果全局函数没有转义，则不需要对该函数执行闭包转换。

\begin{exercise}\normalfont
 实现一个辅助函数来检测哪个全局函数转义。使用该函数，实现闭包转换的改进版本，不对闭包转换进行转义，而是将它们作为常规函数编译的全局函数。创建几个新的测试用例，检查是否正确地检测到全局函数是否转义。
\end{exercise}

到目前为止，已经减少调用全局函数的开销，但是当我们可以在编译时确定将调用哪个
\code{lambda} 时，减少调用
\code{lambda} 的开销也会很好。我们称此类调用为 \emph{已知调用} 。考虑下面的例子，在这个例子中， \code{lambda} 被限定为 \code{f} ，然后应用。
\begin{lstlisting}
(let ([y (read)])
  (let ([f (lambda: ([x : Integer]) : Integer
             (+ x y))])
    (f 21)))
\end{lstlisting}
闭包转换 \code{(f 21)} 编译为一个间接调用：
\begin{lstlisting}
(define (lambda5 [fvs6 : (Vector _ Integer)] [x3 : Integer]) : Integer
   (let ([y2 (vector-ref fvs6 1)])
      (+ x3 y2)))

(define (main) : Integer
   (let ([y2 (read)])
      (let ([f4 (Closure 1 (list (fun-ref lambda5) y2))])
         ((vector-ref f4 0) f4 21))))
\end{lstlisting}
但是可以将应用程序 \code{(f 21)} 编译成对 \code{lambda5} 的直接调用：
\begin{lstlisting}
(define (main) : Integer
   (let ([y2 (read)])
      (let ([f4 (Closure 1 (list (fun-ref lambda5) y2))])
         ((fun-ref lambda5) f4 21))))
\end{lstlisting}

一般来说，确定某个特定应用程序将调用哪个lambda的问题相当具有挑战性，这是需要进行大量研究的主题~\citep{Shivers:1988aa,Gilray:2016aa} 。对于下面的练习，建议您将应用程序编译为直接调用，当操作符是一个变量并且变量被
\code{let} 绑定到一个闭包时。这可以通过维护一个将 \code{let} 绑定变量映射到函数名的环境来实现。
当在 \code{let} 的右边遇到一个闭包时，扩展环境，将 \code{let} 绑定变量映射到闭包的全局函数名。

\begin{exercise}\normalfont
实现一个名为 \code{optimize-known-calls} 的编译器通道，将已知调用编译为直接调用。在几个示例程序上验证编译器在这方面是成功的。
\end{exercise}

这些练习只是触及闭包优化的表面。对感兴趣的读者来说，下一步是看看 \citet{Keep:2012ab} 的著作。

\section{延伸阅读}

词法上限定匿名函数的概念比现代计算机早大约十年。它们是由
\citet{Church:1932aa} 发明的，他提出 $\lambda$ 演算作为逻辑的基础。匿名函数包含在
LISP~\citep{McCarthy:1960dz} 编程语言中，但最初是动态作用域的。LISP的Scheme方言采用词法作用域， \citet{Guy-L.-Steele:1978yq} 演示如何高效地编译Scheme程序。但是，环境被表示为链表，所以变量查找在环境的大小中是线性的。在本章中，使用扁平闭包来表示环境，扁平闭包是
\citet{Cardelli:1983aa,Cardelli:1984aa} 为编译ML语言~\citep{Gordon:1978aa,Milner:1990fk} 而发明的。对于扁平闭包，变量查找的时间是固定的，但是创建闭包的时间与它的自由变量的数量成正比。扁平闭包是由 \citet{Dybvig:1987ab} 在他的博士论文中重新发明的，并在Chez Scheme 版本 1~\citep{Dybvig:2006aa} 中使用。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{动态类型}
\label{ch:Rdyn}
\index{dynamic typing}

本章讨论 \LangDyn{} 的编译，是一种动态类型语言，是 Racket 的一个子集。这是与前面的章节形成对比，其中已经研究类型化 Racket 的编译。在 \LangDyn{} 等动态类型语言中，给定的表达式每次执行时可能产生不同类型的值。考虑下面的示例，该示例带有条件 \code{if}
表达式，它可能根据程序的输入返回一个布尔值或整数。
% part of  dynamic_test_25.rkt
\begin{lstlisting}
   (not (if (eq? (read) 1) #f 0))
\end{lstlisting}
允许表达产生不同值的语言被称为 \emph{多态} ，这个词由希腊语词根“poly”(意为“许多”)和“morph”(意为“形状”)组成。在编程语言中有几种多态性，例如子类型多态性和参数多态性~\citep{Cardelli:1985kx} 。在本章中研究的多态性没有一个特殊的名称，但它是动态类型语言中出现的一种。

动态类型语言的另一个特征是基元操作，比如 \code{not} ，通常被定义为对许多不同类型的值进行操作。实际上，在 Racket 中， \code{not}
操作符为任何类型的值产生结果：给定 \code{\#f} 返回 \code{\#t} ，给定其他任何值返回 \code{\#f} 。
此外，即使原语操作将其输入限制为某种类型的值，也会在运行时而不是编译期间强制执行这种限制。例如，下面的向量引用导致运行时契约违反，因为索引必须是整数，而不是像 \code{\#t} 这样的布尔值。
\begin{lstlisting}
   (vector-ref (vector 42) #t)
\end{lstlisting}

\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.97\textwidth}
\[
\begin{array}{rcl}
  \itm{cmp} &::= & \key{eq?} \mid \key{<} \mid \key{<=} \mid \key{>} \mid \key{>=} \\
\Exp &::=& \Int \mid \CREAD{} \mid \CNEG{\Exp}
      \mid \CADD{\Exp}{\Exp} \mid \CSUB{\Exp}{\Exp}  \\
     &\mid&  \Var \mid \CLET{\Var}{\Exp}{\Exp} \\
     &\mid& \key{\#t} \mid \key{\#f} 
      \mid \CBINOP{\key{and}}{\Exp}{\Exp} 
     \mid \CBINOP{\key{or}}{\Exp}{\Exp} 
     \mid \CUNIOP{\key{not}}{\Exp} \\
     &\mid& \LP\itm{cmp}\;\Exp\;\Exp\RP \mid \CIF{\Exp}{\Exp}{\Exp} \\
     &\mid& \LP\key{vector}\;\Exp\ldots\RP \mid
      \LP\key{vector-ref}\;\Exp\;\Exp\RP \\
     &\mid& \LP\key{vector-set!}\;\Exp\;\Exp\;\Exp\RP \mid \LP\key{void}\RP \\
      &\mid& \LP\Exp \; \Exp\ldots\RP
      \mid \LP\key{lambda}\;\LP\Var\ldots\RP\;\Exp\RP \\
     & \mid & \LP\key{boolean?}\;\Exp\RP \mid \LP\key{integer?}\;\Exp\RP\\
     & \mid & \LP\key{vector?}\;\Exp\RP \mid \LP\key{procedure?}\;\Exp\RP \mid \LP\key{void?}\;\Exp\RP \\
  \Def &::=& \LP\key{define}\; \LP\Var \; \Var\ldots\RP \; \Exp\RP \\
\LangDyn{}  &::=& \Def\ldots\; \Exp
\end{array}
\]
\end{minipage}
}
\caption{ \LangDyn{} 的语法，一种非类型化语言( Racket 的子集)。}
\label{fig:r7-concrete-syntax}
\end{figure}


\begin{figure}[tp]
\centering
\fbox{
  \begin{minipage}{0.96\textwidth}
    \small
\[
\begin{array}{lcl}
  \Exp &::=& \INT{\Int} \mid \VAR{\Var} \mid \LET{\Var}{\Exp}{\Exp} \\
       &\mid& \PRIM{\itm{op}}{\Exp\ldots} \\
     &\mid& \BOOL{\itm{bool}}
      \mid \IF{\Exp}{\Exp}{\Exp}  \\
     &\mid& \VOID{} \mid \APPLY{\Exp}{\Exp\ldots} \\
     &\mid& \LAMBDA{\LP\Var\ldots\RP}{\code{'Any}}{\Exp}\\
 \Def &::=& \FUNDEF{\Var}{\LP\Var\ldots\RP}{\code{'Any}}{\code{'()}}{\Exp} \\
  \LangDyn{} &::=& \PROGRAMDEFSEXP{\code{'()}}{\LP\Def\ldots\RP}{\Exp} 
\end{array}
\]
\end{minipage}
}
\caption{ \LangDyn{} 的抽象语法。}
\label{fig:r7-syntax}
\end{figure}


Racket 子集的 \LangDyn{} 的具体和抽象语法在图~\ref{fig:r7-concrete-syntax} 和
\ref{fig:r7-syntax} 中定义。
%
 \LangDyn{} 没有类型检查器，因为它不是静态类型语言(它是动态类型的！)。

 \LangDyn{} 的定义解释器如图~\ref{fig:interp-Rdyn} 所示，其辅助函数在图~\ref{fig:interp-Rdyn-aux} 中定义。考虑 \code{(Int n)} 的匹配情况。代替简单地返回整数 \code{n} (如图~\ref{fig:interp-Rvar} 中 \LangVar{} 解释器)，  \LangDyn{} 的解释器创建一个 \emph{标记值}\index{tagged
  value} ，该值将基础值与标识其类型的标记结合在一起。定义以下结构来表示标记值。
\begin{lstlisting}
(struct Tagged (value tag) #:transparent)
\end{lstlisting}
标签是 \code{Integer} 、 \code{Boolean} 、 \code{Void} 、
\code{Vector} 和 \code{Procedure} 。标记与类型密切相关，但并不总是捕获类型所做的所有信息。例如，一个类型为 \code{(Vector Any Any)} 的向量被标记为
\code{Vector} ，一个类型为 \code{(Any Any -> Any)}
的过程被标记为 \code{Procedure} 。

接下来考虑向量 \code{vector-ref} 的匹配情况。
\code{check-tag} 辅助函数(图~\ref{fig:interp-Rdyn-aux})
用于确保第一个参数是一个向量，第二个参数是一个整数。如果不是，将引发 \code{trapped-error} 。
回想一下第~\ref{sec:interp-Rint} 节，当定义解释器引发 \code{trapped-error} 错误时，编译后的代码也必须通过退出返回代码 \code{255} 发出错误信号。如果索引不小于向量的长度，也会引发\code{trapped-error} 。


\begin{figure}[tbp]
\begin{lstlisting}
(define ((interp-Rdyn-exp env) ast)
  (define recur (interp-Rdyn-exp env))
  (match ast
    [(Var x) (lookup x env)]
    [(Int n) (Tagged n 'Integer)]
    [(Bool b) (Tagged b 'Boolean)]
    [(Lambda xs rt body)
     (Tagged `(function ,xs ,body ,env) 'Procedure)]
    [(Prim 'vector es)
     (Tagged (apply vector (for/list ([e es]) (recur e))) 'Vector)]
    [(Prim 'vector-ref (list e1 e2))
     (define vec (recur e1)) (define i (recur e2))
     (check-tag vec 'Vector ast) (check-tag i 'Integer ast)
     (unless (< (Tagged-value i) (vector-length (Tagged-value vec)))
       (error 'trapped-error "index ~a too big\nin ~v" (Tagged-value i) ast))
     (vector-ref (Tagged-value vec) (Tagged-value i))]
    [(Prim 'vector-set! (list e1 e2 e3))
     (define vec (recur e1)) (define i (recur e2)) (define arg (recur e3))
     (check-tag vec 'Vector ast) (check-tag i 'Integer ast)
     (unless (< (Tagged-value i) (vector-length (Tagged-value vec)))
       (error 'trapped-error "index ~a too big\nin ~v" (Tagged-value i) ast))
     (vector-set! (Tagged-value vec) (Tagged-value i) arg)
     (Tagged (void) 'Void)]
    [(Let x e body) ((interp-Rdyn-exp (cons (cons x (recur e)) env)) body)]
    [(Prim 'and (list e1 e2)) (recur (If e1 e2 (Bool #f)))]
    [(Prim 'or (list e1 e2))
     (define v1 (recur e1))
     (match (Tagged-value v1) [#f (recur e2)] [else v1])]
    [(Prim 'eq? (list l r)) (Tagged (equal? (recur l) (recur r)) 'Boolean)]
    [(Prim op (list e1))
     #:when (set-member? type-predicates op)
     (tag-value ((interp-op op) (Tagged-value (recur e1))))]
\end{lstlisting}
\end{figure}
\begin{figure}[tbp]
\begin{lstlisting}     
    [(Prim op es)
     (define args (map recur es))
     (define tags (for/list ([arg args]) (Tagged-tag arg)))
     (unless (for/or ([expected-tags (op-tags op)])
               (equal? expected-tags tags))
       (error 'trapped-error "illegal argument tags ~a\nin ~v" tags ast))
     (tag-value
      (apply (interp-op op) (for/list ([a args]) (Tagged-value a))))]
    [(If q t f)
     (match (Tagged-value (recur q)) [#f (recur f)] [else (recur t)])]
    [(Apply f es)
     (define new-f (recur f)) (define args (map recur es))
     (check-tag new-f 'Procedure ast) (define f-val (Tagged-value new-f))
     (match f-val 
       [`(function ,xs ,body ,lam-env)
        (unless (eq? (length xs) (length args))
         (error 'trapped-error "~a != ~a\nin ~v" (length args) (length xs) ast))
        (define new-env (append (map cons xs args) lam-env))
        ((interp-Rdyn-exp new-env) body)]
       [else (error "interp-Rdyn-exp, expected function, not" f-val)])]))
\end{lstlisting}
\caption{ \LangDyn{} 语言的解释器。}
\label{fig:interp-Rdyn}
\end{figure}

\begin{figure}[tbp]
\begin{lstlisting}
(define (interp-op op)
  (match op
    ['+ fx+]
    ['- fx-]
    ['read read-fixnum]
    ['not (lambda (v) (match v [#t #f] [#f #t]))]
    ['< (lambda (v1 v2)
	  (cond [(and (fixnum? v1) (fixnum? v2)) (< v1 v2)]))]
    ['<= (lambda (v1 v2)
	   (cond [(and (fixnum? v1) (fixnum? v2)) (<= v1 v2)]))]
    ['> (lambda (v1 v2)
	  (cond [(and (fixnum? v1) (fixnum? v2)) (> v1 v2)]))]
    ['>= (lambda (v1 v2)
	   (cond [(and (fixnum? v1) (fixnum? v2)) (>= v1 v2)]))]
    ['boolean? boolean?]
    ['integer? fixnum?]
    ['void? void?]
    ['vector? vector?]
    ['vector-length vector-length]
    ['procedure? (match-lambda
                   [`(functions ,xs ,body ,env) #t] [else #f])]
    [else (error 'interp-op "unknown operator" op)]))

(define (op-tags op)
  (match op
    ['+ '((Integer Integer))]
    ['- '((Integer Integer) (Integer))]
    ['read '(())]
    ['not '((Boolean))]
    ['< '((Integer Integer))]
    ['<= '((Integer Integer))]
    ['> '((Integer Integer))]
    ['>= '((Integer Integer))]
    ['vector-length '((Vector))]))
\end{lstlisting}
\end{figure}
\begin{figure}[tbp]
\begin{lstlisting}
(define type-predicates
  (set 'boolean? 'integer? 'vector? 'procedure? 'void?))

(define (tag-value v)
  (cond [(boolean? v) (Tagged v 'Boolean)]
        [(fixnum? v) (Tagged v 'Integer)]
        [(procedure? v) (Tagged v 'Procedure)]
        [(vector? v) (Tagged v 'Vector)]
        [(void? v) (Tagged v 'Void)]
        [else (error 'tag-value "unidentified value ~a" v)]))

(define (check-tag val expected ast)
  (define tag (Tagged-tag val))
  (unless (eq? tag expected)
    (error 'trapped-error "expected ~a, not ~a\nin ~v" expected tag ast)))
\end{lstlisting}
\caption{ \LangDyn{} 解释器的辅助函数。}
\label{fig:interp-Rdyn-aux}
\end{figure}

\clearpage

\section{标记值的表示}

 \LangDyn{} 的解释器引入一种新的值，标记值。要将 \LangDyn{} 编译为x86，必须决定如何在位级别表示标记值。因为 \LangDyn{}
中的几乎每个操作都涉及到操作标记值，所以表示必须是高效的。回想一下，所有的值都是64位的。取最右边的3位来编码标签。使用 $001$ 来标识整数， $100$ 用于布尔值， $010$ 用于向量， $011$ 用于过程， $101$ 用于空值。定义以下用于将类型映射到标记代码的辅助函数。
\begin{align*}
\itm{tagof}(\key{Integer}) &= 001 \\
\itm{tagof}(\key{Boolean}) &= 100 \\
\itm{tagof}((\key{Vector} \ldots)) &= 010 \\
\itm{tagof}((\ldots \key{->} \ldots)) &= 011 \\
\itm{tagof}(\key{Void}) &= 101
\end{align*}
这种取3位的行为是有代价的：整数被减少到 $-2^{60}$ 到 $2^{60}$ 之间。这种窃取并不会对向量和过程产生负面影响，因为这些值是地址，而的地址是8字节对齐的，所以最右边的3位是没有用的，它们总是 $000$ 。因此，通过用标签覆盖最右边的3位，不会丢失信息，而且可以简单地使标签归零以恢复原始地址。

为了将标记值放入第一类实体中，可以给它们一个名为 \code{Any} 的类型，并定义诸如 \code{Inject}
和 \code{Project} 之类的操作来创建和使用它们，从而生成 \LangAny{}
中间语言。在第 \ref{sec:compile-r7} 节中描述如何将 \LangDyn{} 编译为 \LangAny{} ，但首先将更详细地描述 \LangAny{} 语言。

\section{ \LangAny{} 语言}
\label{sec:Rany-lang}

\begin{figure}[tp]
\centering
\fbox{
  \begin{minipage}{0.96\textwidth}
    \small
\[
\begin{array}{lcl}
\Type &::= & \ldots \mid \key{Any} \\
\itm{op} &::= & \ldots \mid \code{any-vector-length}
     \mid \code{any-vector-ref} \mid \code{any-vector-set!}\\
    &\mid& \code{boolean?} \mid \code{integer?} \mid \code{vector?}
     \mid \code{procedure?} \mid \code{void?} \\
\Exp &::=& \ldots
     \mid \gray{ \PRIM{\itm{op}}{\Exp\ldots} } \\
    &\mid& \INJECT{\Exp}{\FType} \mid \PROJECT{\Exp}{\FType} \\
 \Def &::=& \gray{ \FUNDEF{\Var}{\LP[\Var \code{:} \Type]\ldots\RP}{\Type}{\code{'()}}{\Exp} }\\
  \LangAny{} &::=& \gray{ \PROGRAMDEFSEXP{\code{'()}}{\LP\Def\ldots\RP}{\Exp} }
\end{array}
\]
\end{minipage}
}
\caption{ \LangAny{} 的抽象语法，扩展 \LangLam{} (图~\ref{fig:Rlam-syntax})。}
\label{fig:Rany-syntax}
\end{figure}


 \LangAny{} 的抽象语法在图~\ref{fig:Rany-syntax} 中定义。
( \LangAny{} 的具体语法见附录图~\ref{fig:Rany-concrete-syntax}。)  $\INJECT{e}{T}$ 形式将 $T$ 类型的表达式 $e$ 产生的值转换为标记值。 $\PROJECT{e}{T}$ 形式将表达式 $e$ 产生的标记值转换为类型 $T$ 的值，或者如果类型标记不等同于 $T$ ，则停止程序。
%
请注意，在 \code{Inject} 和 \code{Project} 中，类型 $T$ 都被限制为平面类型 $\FType$ ，这简化实现，并与编译 \LangDyn{} 所需的类型相对应。

 \code{any-vector} 操作符适用于vector操作，因此它们可以应用于 \code{Any} 类型的值。它们还推广向量操作，即索引在语法中不被限制为一个字面整数，但允许为任何表达式。

像 \key{boolean?} 这样的类型谓词期望它们的参数产生一个标记值；如果标记对应于谓词，则返回 \key{\#t} ，否则返回 \key{\#f} 。

 \LangAny{} 的类型检查器如图~\ref{fig:type-check-Rany-part-1} 和
\ref{fig:type-check-Rany-part-2} 所示，并使用图~\ref{fig:type-check-Rany-aux} 中的辅助函数。
%
 \LangAny{} 的解释器在图~\ref{fig:interp-Rany} 中，辅助函数 \code{apply-inject} 和 \code{apply-project} 在图~\ref{fig:apply-project} 中。


\begin{figure}[btp]
 \begin{lstlisting}
(define type-check-Rany-class
  (class type-check-Rlambda-class
    (super-new)
    (inherit check-type-equal?)

    (define/override (type-check-exp env)
      (lambda (e)
        (define recur (type-check-exp env))
        (match e
          [(Inject e1 ty)
           (unless (flat-ty? ty)
             (error 'type-check "may only inject from flat type, not ~a" ty))
           (define-values (new-e1 e-ty) (recur e1))
           (check-type-equal? e-ty ty e)
           (values (Inject new-e1 ty) 'Any)]
          [(Project e1 ty)
           (unless (flat-ty? ty)
             (error 'type-check "may only project to flat type, not ~a" ty))
           (define-values (new-e1 e-ty) (recur e1))
           (check-type-equal? e-ty 'Any e)
           (values (Project new-e1 ty) ty)]
          [(Prim 'any-vector-length (list e1))
           (define-values (e1^ t1) (recur e1))
           (check-type-equal? t1 'Any e)
           (values (Prim 'any-vector-length (list e1^)) 'Integer)]
\end{lstlisting}
\end{figure}
\begin{figure}[tbp]
\begin{lstlisting}           
          [(Prim 'any-vector-ref (list e1 e2))
           (define-values (e1^ t1) (recur e1))
           (define-values (e2^ t2) (recur e2))
           (check-type-equal? t1 'Any e)
           (check-type-equal? t2 'Integer e)
           (values (Prim 'any-vector-ref (list e1^ e2^)) 'Any)]
          [(Prim 'any-vector-set! (list e1 e2 e3))
           (define-values (e1^ t1) (recur e1))
           (define-values (e2^ t2) (recur e2))
           (define-values (e3^ t3) (recur e3))
           (check-type-equal? t1 'Any e)
           (check-type-equal? t2 'Integer e)
           (check-type-equal? t3 'Any e)
           (values (Prim 'any-vector-set! (list e1^ e2^ e3^)) 'Void)]
\end{lstlisting}
\caption{ \LangAny{} 语言的类型检查器，第1部分。}
\label{fig:type-check-Rany-part-1}
\end{figure}

\begin{figure}[btp]
 \begin{lstlisting}
      [(ValueOf e ty)
       (define-values (new-e e-ty) (recur e))
       (values (ValueOf new-e ty) ty)]
      [(Prim pred (list e1))
       #:when (set-member? (type-predicates) pred)
       (define-values (new-e1 e-ty) (recur e1))
       (check-type-equal? e-ty 'Any e)
       (values (Prim pred (list new-e1)) 'Boolean)]
      [(If cnd thn els)
       (define-values (cnd^ Tc) (recur cnd))
       (define-values (thn^ Tt) (recur thn))
       (define-values (els^ Te) (recur els))
       (check-type-equal? Tc 'Boolean cnd)
       (check-type-equal? Tt Te e)
       (values (If cnd^ thn^ els^) (combine-types Tt Te))]
      [(Exit) (values (Exit) '_)]
      [(Prim 'eq? (list arg1 arg2))
       (define-values (e1 t1) (recur arg1))
       (define-values (e2 t2) (recur arg2))
       (match* (t1 t2)
         [(`(Vector ,ts1 ...) `(Vector ,ts2 ...))   (void)]
         [(other wise) (check-type-equal? t1 t2 e)])
       (values (Prim 'eq? (list e1 e2)) 'Boolean)]
      [else ((super type-check-exp env) e)])))

))
\end{lstlisting}
\caption{ \LangAny{} 语言的类型检查器，第2部分。}
\label{fig:type-check-Rany-part-2}
\end{figure}


\begin{figure}[tbp]
\begin{lstlisting}
    (define/override (operator-types)
      (append
       '((integer? . ((Any) . Boolean))
         (vector? . ((Any) . Boolean))
         (procedure? . ((Any) . Boolean))
         (void? . ((Any) . Boolean))
         (tag-of-any . ((Any) . Integer))
         (make-any . ((_ Integer) . Any))
         )
       (super operator-types)))

    (define/public (type-predicates)
      (set 'boolean? 'integer? 'vector? 'procedure? 'void?))

    (define/public (combine-types t1 t2)
      (match (list t1 t2)
        [(list '_ t2) t2]
        [(list t1 '_) t1]
        [(list `(Vector ,ts1 ...)
               `(Vector ,ts2 ...))
         `(Vector ,@(for/list ([t1 ts1] [t2 ts2])
                      (combine-types t1 t2)))]
        [(list `(,ts1 ... -> ,rt1)
               `(,ts2 ... -> ,rt2))
         `(,@(for/list ([t1 ts1] [t2 ts2])
               (combine-types t1 t2))
           -> ,(combine-types rt1 rt2))]
        [else t1]))

    (define/public (flat-ty? ty)
      (match ty
        [(or `Integer `Boolean '_ `Void) #t]
        [`(Vector ,ts ...) (for/and ([t ts]) (eq? t 'Any))]
        [`(,ts ... -> ,rt)
         (and (eq? rt 'Any) (for/and ([t ts]) (eq? t 'Any)))]
        [else #f]))
\end{lstlisting}
\caption{类型检查 \LangAny{} 的辅助方法。}
\label{fig:type-check-Rany-aux}
\end{figure}


\begin{figure}[btp]
\begin{lstlisting}
(define interp-Rany-class
  (class interp-Rlambda-class
    (super-new)

    (define/override (interp-op op)
      (match op
        ['boolean? (match-lambda
                     [`(tagged ,v1 ,tg) (equal? tg (any-tag 'Boolean))]
                     [else #f])]
        ['integer? (match-lambda
                     [`(tagged ,v1 ,tg) (equal? tg (any-tag 'Integer))]
                     [else #f])]
        ['vector? (match-lambda
                    [`(tagged ,v1 ,tg) (equal? tg (any-tag `(Vector Any)))]
                    [else #f])]
        ['procedure? (match-lambda
                       [`(tagged ,v1 ,tg) (equal? tg (any-tag `(Any -> Any)))]
                       [else #f])]
        ['eq? (match-lambda*
                [`((tagged ,v1^ ,tg1) (tagged ,v2^ ,tg2))
                 (and (eq? v1^ v2^) (equal? tg1 tg2))]
                [ls (apply (super interp-op op) ls)])]
        ['any-vector-ref (lambda (v i)
                           (match v [`(tagged ,v^ ,tg) (vector-ref v^ i)]))]
        ['any-vector-set! (lambda (v i a)
                            (match v [`(tagged ,v^ ,tg) (vector-set! v^ i a)]))]
        ['any-vector-length (lambda (v)
                            (match v [`(tagged ,v^ ,tg) (vector-length v^)]))]
        [else (super interp-op op)]))
\end{lstlisting}
\end{figure}
\begin{figure}[tbp]
\begin{lstlisting}
    (define/override ((interp-exp env) e)
      (define recur (interp-exp env))
      (match e
        [(Inject e ty) `(tagged ,(recur e) ,(any-tag ty))]
        [(Project e ty2)  (apply-project (recur e) ty2)]
        [else ((super interp-exp env) e)]))
    ))

(define (interp-Rany p)
  (send (new interp-Rany-class) interp-program p))
\end{lstlisting}
\caption{ \LangAny{} 解释器。}
\label{fig:interp-Rany}
\end{figure}

\begin{figure}[tbp]
\begin{lstlisting}
(define/public (apply-inject v tg) (Tagged v tg))

(define/public (apply-project v ty2)
  (define tag2 (any-tag ty2))
  (match v
    [(Tagged v1 tag1)
     (cond
       [(eq? tag1 tag2)
        (match ty2
          [`(Vector ,ts ...)
           (define l1 ((interp-op 'vector-length) v1))
           (cond
             [(eq? l1 (length ts)) v1]
             [else (error 'apply-project "vector length mismatch, ~a != ~a"
                          l1 (length ts))])]
          [`(,ts ... -> ,rt)
           (match v1
             [`(function ,xs ,body ,env)
              (cond [(eq? (length xs) (length ts)) v1]
                    [else
                     (error 'apply-project "arity mismatch ~a != ~a"
                            (length xs) (length ts))])]
             [else (error 'apply-project "expected function not ~a" v1)])]
          [else v1])]
       [else (error 'apply-project "tag mismatch ~a != ~a" tag1 tag2)])]
    [else (error 'apply-project "expected tagged value, not ~a" v)]))
\end{lstlisting}
  \caption{用于注入和投影的辅助功能。}
  \label{fig:apply-project}
\end{figure}

\clearpage

\section{强制转换插入：将 \LangDyn{} 编译为 \LangAny{}}
\label{sec:compile-r7}

 \code{cast-insert} 通道从 \LangDyn{} 编译到 \LangAny{} 。
图~\ref{fig:compile-r7-Rany} 显示将许多
\LangDyn{} 表单编译成 \LangAny{} 的过程。此通道的一个重要不变式是，给定
\LangDyn{} 程序中的子表达式 $e$ ，通道将产生
\LangAny{} 中的表达式 $e'$ ，该表达式的类型为 \key{Any} 。例如，图~\ref{fig:compile-r7-Rany} 中的第一行显示布尔 \code{\#t} 的编译，必须注入它才能产生类型 \key{Any} 的表达式。
%
图~\ref{fig:compile-r7-Rany} 的第二行是加法的编译，它代表许多基本操作的编译:参数的类型为 \key{Any} ，并且必须在加法执行之前被映射为 \key{Integer} 。

 \key{lambda} 的编译(图~\ref{fig:compile-r7-Rany} 的第三行)显示当我们需要产生类型注释时发生了什么：只需使用 \key{Any} 。
%
 \code{if} 和 \code{eq?} 的编译说明这个通道如何解释 \LangDyn{} 和
\LangAny{} 之间行为上的一些差异。 \LangDyn{} 语言比 \LangAny{} 更宽容，可以在不同的地方使用什么样的值。例如， \key{if} 的条件不一定是布尔值。对于 \key{eq?} ，参数不需要是相同类型的(在这种情况下结果是 \code{\#f})。

\begin{figure}[btp]
\centering
\begin{tabular}{|lll|} \hline
\begin{minipage}{0.27\textwidth}
\begin{lstlisting}
#t
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}
(inject #t Boolean)
\end{lstlisting}
\end{minipage}
\\[2ex]\hline
\begin{minipage}{0.27\textwidth}
\begin{lstlisting}
(+ |$e_1$| |$e_2$|)
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}
(inject
   (+ (project |$e'_1$| Integer)
      (project |$e'_2$| Integer))
   Integer)
\end{lstlisting}
\end{minipage}
\\[2ex]\hline
\begin{minipage}{0.27\textwidth}
\begin{lstlisting}
(lambda (|$x_1 \ldots x_n$|) |$e$|)
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}
(inject
   (lambda: ([|$x_1$|:Any]|$\ldots$|[|$x_n$|:Any]):Any |$e'$|)
   (Any|$\ldots$|Any -> Any))
\end{lstlisting}
\end{minipage}
\\[2ex]\hline
\begin{minipage}{0.27\textwidth}
\begin{lstlisting}
(|$e_0$| |$e_1 \ldots e_n$|)
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}
((project |$e'_0$| (Any|$\ldots$|Any -> Any)) |$e'_1 \ldots e'_n$|)
\end{lstlisting}
\end{minipage}
\\[2ex]\hline
\begin{minipage}{0.27\textwidth}
\begin{lstlisting}
(vector-ref |$e_1$| |$e_2$|)
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}
(any-vector-ref |$e_1'$| |$e_2'$|)
\end{lstlisting}
\end{minipage}
\\[2ex]\hline
\begin{minipage}{0.27\textwidth}
\begin{lstlisting}
(if |$e_1$| |$e_2$| |$e_3$|)
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}
(if (eq? |$e'_1$| (inject #f Boolean)) |$e'_3$| |$e'_2$|)
\end{lstlisting}
\end{minipage}
\\[2ex]\hline
\begin{minipage}{0.27\textwidth}
\begin{lstlisting}
(eq? |$e_1$| |$e_2$|)
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}
(inject (eq? |$e'_1$| |$e'_2$|) Boolean)
\end{lstlisting}
\end{minipage}
\\[2ex]\hline
\begin{minipage}{0.27\textwidth}
\begin{lstlisting}
(not |$e_1$|)
\end{lstlisting}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}
(if (eq? |$e'_1$| (inject #f Boolean))
    (inject #t Boolean) (inject #f Boolean))
\end{lstlisting}
\end{minipage}
\\[2ex]\hline
\end{tabular} 

\caption{演员表插入}
\label{fig:compile-r7-Rany}
\end{figure}



\section{显示演员表}
\label{sec:reveal-casts-Rany}

% TODO: define R'_6

在 \code{reveal-casts} 通道中，建议将 \code{project}
编译成 \code{if} 表达式，用于检查值的标记是否与目标类型匹配;如果是，则通过删除标记将值转换为目标类型的值;如果没有，程序退出。为了执行这些操作，需要一个新的基本操作，
\code{tag-of-any} ，以及两个新的表单， \code{ValueOf} 和 \code{Exit} 。
 \code{tag-of-any} 操作从 \code{Any} 类型的标记值中检索类型标记。 \code{ValueOf} 表单从标记值中检索基础值。 \code{ValueOf} 表单包含类型检查器使用的基础值的类型。最后， \code{Exit} 表单结束程序的执行。

如果投影的目标类型是 \code{Boolean} 或
\code{Integer} ，那么 \code{Project} 可以翻译如下。
\begin{center}
\begin{minipage}{1.0\textwidth}
\begin{lstlisting}
(Project |$e$| |$\FType$|)
|$\Rightarrow$|
(Let |$\itm{tmp}$| |$e'$|
   (If (Prim 'eq? (list (Prim 'tag-of-any (list (Var |$\itm{tmp}$|)))
                           (Int |$\itm{tagof}(\FType)$|)))
      (ValueOf |$\itm{tmp}$| |$\FType$|)
      (Exit)))
\end{lstlisting}
\end{minipage}
\end{center}
如果投影的目标类型是向量或函数类型，则需要做更多的工作。对于向量，检查向量类型的长度是否与向量的长度匹配(使用
\code{vector-length} 原语)。对于函数，检查函数类型中的参数数量是否与函数的属性匹配(使用
\code{procedure-arity})。

关于 \code{inject} ，建议将其编译为一个稍低级别的原语操作 \code{make-any} 。该操作接受一个标记而不是类型。
\begin{center}
\begin{minipage}{1.0\textwidth}
\begin{lstlisting}
(Inject |$e$| |$\FType$|)
|$\Rightarrow$|
(Prim 'make-any (list |$e'$| (Int |$\itm{tagof}(\FType)$|)))
\end{lstlisting}
\end{minipage}
\end{center}

类型谓词 (\code{boolean?} 等) 可以被翻译成 \code{tag-of-any} 和 \code{eq?} 的用法，类似于 \code{Project} 的翻译。

 \code{any-vector-ref} 和 \code{any-vector-set!} 操作结合投影操作和向量操作。另外，读和写操作允许索引的任意表达式，因此 \LangAny{} 的类型检查器(图~\ref{fig:type-check-Rany-part-1})
不能保证索引在范围内。因此，插入代码在运行时执行边界检查。
\code{any-vector-ref} 的转换如下，其他两个操作以类似的方式进行转换。

\begin{lstlisting}
(Prim 'any-vector-ref (list |$e_1$| |$e_2$|))
|$\Rightarrow$|
(Let |$v$| |$e'_1$|
  (Let |$i$| |$e'_2$|
    (If (Prim 'eq? (list (Prim 'tag-of-any (list (Var |$v$|))) (Int 2)))
      (If (Prim '< (list (Var |$i$|)
            (Prim 'any-vector-length (list (Var |$v$|)))))
        (Prim 'any-vector-ref (list (Var |$v$|) (Var |$i$|)))
        (Exit))))
\end{lstlisting}

\section{去除复杂的操作数}
\label{sec:rco-Rany}

 \code{ValueOf} 和 \code{Exit} 表单都是复杂表达式。 \code{ValueOf} 的子表达式必须是原子的。
\section{解释控制和 \LangCAny{}}
\label{sec:explicate-Rany}

 \code{explicate-control} 的输出是 \LangCAny{} 语言，其语法在图~\ref{fig:c5-syntax} 中定义。添加到 \LangAny{} 中的 \code{ValueOf}
形式仍然是一个表达式，而 \code{Exit} 表达式变成 $\Tail$ 。另外，注意
\code{vector-ref} 和 \code{vector-set!} 的索引参数是 $\Atm$ 而不是整数，就像 \LangCVec{} (图~\ref{fig:c2-syntax})。


\begin{figure}[tp]
\fbox{
\begin{minipage}{0.96\textwidth}
\small
\[
\begin{array}{lcl}
\Exp &::= & \ldots
   \mid \BINOP{\key{'any-vector-ref}}{\Atm}{\Atm}  \\
   &\mid& (\key{Prim}~\key{'any-vector-set!}\,(\key{list}\,\Atm\,\Atm\,\Atm))\\
   &\mid& \VALUEOF{\Exp}{\FType} \\
\Stmt &::=& \gray{ \ASSIGN{\VAR{\Var}}{\Exp} 
  \mid \LP\key{Collect} \,\itm{int}\RP }\\
\Tail &::= & \gray{ \RETURN{\Exp} \mid \SEQ{\Stmt}{\Tail} 
       \mid \GOTO{\itm{label}} } \\
    &\mid& \gray{ \IFSTMT{\BINOP{\itm{cmp}}{\Atm}{\Atm}}{\GOTO{\itm{label}}}{\GOTO{\itm{label}}}  }\\
&\mid& \gray{ \TAILCALL{\Atm}{\Atm\ldots} } 
  \mid \LP\key{Exit}\RP \\
\Def &::=& \gray{ \DEF{\itm{label}}{\LP[\Var\key{:}\Type]\ldots\RP}{\Type}{\itm{info}}{\LP\LP\itm{label}\,\key{.}\,\Tail\RP\ldots\RP} }\\
\LangCLam{} & ::= & \gray{ \PROGRAMDEFS{\itm{info}}{\LP\Def\ldots\RP} }
\end{array}
\]
\end{minipage}
}
\caption{ \LangCAny{} 的抽象语法，扩展 \LangCLam{} (图~\ref{fig:c4-syntax})。}
\label{fig:c5-syntax}
\end{figure}


\section{选择指令}
\label{sec:select-Rany}

在 \code{select-instructions} 中，将 \code{Any} 类型上的基本操作转换为x86指令，该指令涉及操作标记值的3个标记位。

\paragraph{Make-any}

如果标签是 \key{Integer} 或 \key{Boolean} ，建议按如下方式编译 \key{make-any} 原语。 \key{salq} 指令将目的地向左移动指定其源参数的位数(在本例中为 $3$ ，标记的长度)，并保留整数的符号。使用 \key{orq} 指令将标记和值组合起来，形成标记值。  \\
\begin{lstlisting}
(Assign |\itm{lhs}| (Prim 'make-any (list |$e$| (Int |$\itm{tag}$|))))
|$\Rightarrow$|
movq |$e'$|, |\itm{lhs'}|
salq $3, |\itm{lhs'}|
orq $|$\itm{tag}$|, |\itm{lhs'}|
\end{lstlisting}
对于向量和过程的指令选择是不同的，因为它们不需要将它们向左移动。最右边的3位已经是0，就像本章开头描述的那样。因此，只需使用 \key{orq} 将值和标记结合起来。 \\
\begin{lstlisting}
(Assign |\itm{lhs}| (Prim 'make-any (list |$e$| (Int |$\itm{tag}$|))))
|$\Rightarrow$|
movq |$e'$|, |\itm{lhs'}|
orq $|$\itm{tag}$|, |\itm{lhs'}|
\end{lstlisting}

\paragraph{Tag-of-any}

回想一下， \code{tag-of-any} 操作从 \code{Any} 类型的值中提取类型标记。类型标签是最下面的三位，所以通过取位和值的 $111$
(十进制数为 $7$ )来获得标签。
\begin{lstlisting}
(Assign |\itm{lhs}| (Prim 'tag-of-any (list |$e$|)))
|$\Rightarrow$|
movq |$e'$|, |\itm{lhs'}|
andq $7, |\itm{lhs'}|
\end{lstlisting}

\paragraph{ValueOf}

与 \key{make-any} 一样， \key{ValueOf} 的指令也因 $T$ 类型是指针 (向量或过程)
或非指针 (整数或布尔)而不同。下面显示整数和布尔的指令选择。通过向右移动3位来产生未标记的值。
\begin{lstlisting}
(Assign |\itm{lhs}| (ValueOf |$e$| |$T$|))
|$\Rightarrow$|
movq |$e'$|, |\itm{lhs'}|
sarq $3, |\itm{lhs'}|
\end{lstlisting}
%
对于向量和程序，没有必要进行转移。相反，只需要去掉最右边的3位。通过创建位模式 $\ldots 0111$ (十进制 $7$ ) 并应用 \code{bitwise-not} 来获得 $\ldots 11111000$ (十进制 -8) ，将其 \code{movq} 放入目标 $\itm{lhs}$ 中来实现这一点。然后，应用 \code{andq} 与标记值以获得所需的结果。 \\
\begin{lstlisting}
(Assign |\itm{lhs}| (ValueOf |$e$| |$T$|))
|$\Rightarrow$|
movq $|$-8$|, |\itm{lhs'}|
andq |$e'$|, |\itm{lhs'}|
\end{lstlisting}

%% \paragraph{Type Predicates} We leave it to the reader to
%% devise a sequence of instructions to implement the type predicates
%% \key{boolean?}, \key{integer?}, \key{vector?}, and \key{procedure?}.

\paragraph{Any-vector-length}

\begin{lstlisting}
(Assign |$\itm{lhs}$| (Prim 'any-vector-length (list |$a_1$|)))
|$\Longrightarrow$|
movq |$\neg 111$|, %r11
andq |$a_1'$|,  %r11
movq 0(%r11), %r11
andq $126, %r11
sarq $1, %r11
movq %r11, |$\itm{lhs'}$|
\end{lstlisting}

\paragraph{Any-vector-ref}

索引可以是一个任意的原子，所以不是在编译时计算偏移量，而是需要生成指令在运行时计算偏移量，如下所示。注意新指令\code{imulq} 的使用。
\begin{center}
\begin{minipage}{0.96\textwidth}
\begin{lstlisting}
(Assign |$\itm{lhs}$| (Prim 'any-vector-ref (list |$a_1$| |$a_2$|)))
|$\Longrightarrow$|
movq |$\neg 111$|, %r11
andq |$a_1'$|, %r11
movq |$a_2'$|, %rax
addq $1, %rax
imulq $8, %rax
addq %rax, %r11
movq 0(%r11) |$\itm{lhs'}$|
\end{lstlisting}
\end{minipage}
\end{center}

\paragraph{Any-vector-set!}

 \code{any-vector-set!} 的代码生成类似于其他 \code{any-vector} 操作。

\section{ \LangAny{} 的寄存器分配}
\label{sec:register-allocation-Rany}
\index{register allocation}

标记值和垃圾收集之间有一个有趣的交互，它会影响寄存器分配。类型为 \code{Any} 的变量可能引用一个向量，因此它可能是一个根，需要在垃圾收集期间检查和复制。因此，为了实现寄存器分配，需要以类似于 \code{Vector} 类型变量的方式来处理 \code{Any} 类型变量。尤其，
\begin{itemize}
\item 如果一个 \code{Any} 类型的变量在函数调用期间处于活动状态，那么它必须被溢出。这可以通过更改 \code{build-interference} 来完成，将 \code{callq} 之后存在的所有类型为 \code{Any}
的变量标记为干扰所有寄存器。

\item 如果溢出类型为 \code{Any} 的变量，则必须将其溢出到根堆栈，而不是常规过程调用堆栈。
\end{itemize}

关于根堆栈的另一个问题是，垃圾收集器需要区分： (1) 普通旧的元组指针； (2) 指向元组的标记值； (3) 不是元组的标记值。通过选择在 $\itm{tagof}$
函数中不使用标签 $000$ 来实现这种区分。相反，该位模式被保留用于标识指向元组的普通旧指针。这样，如果设置前三个位中的一个，那么就有一个标记值，并且检查标记可以区分向量 ($010$) 和其他类型的值。

\begin{exercise}\normalfont
展开编译器以处理后面几节中讨论的 \LangAny{} 。创建5个新程序，使用 \code{Any} 类型和新操作(\code{inject} 、 \code{project} 、 \code{boolean?} 等)。在这些新程序和之前创建的所有测试程序上测试编译器。
\end{exercise}


\begin{exercise}\normalfont
展开编译器来处理 \LangDyn{} ，如本章所述。
通过删除类型注释来调整以前的十个测试程序，为 \LangDyn{} 创建测试。添加另外5个测试程序，这些程序特别依赖于被动态类型化的语言。也就是说，它们不应该是静态类型语言中的合法程序，但是，它们应该是有效的 \LangDyn{} 程序，运行到完成没有错误。
\end{exercise}


\begin{figure}[p]
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (Rfun) at (0,4)  {\large \LangDyn{}};
\node (Rfun-2) at (3,4)  {\large \LangDyn{}};
\node (Rfun-3) at (6,4)  {\large \LangDyn{}};
\node (Rfun-4) at (9,4)  {\large \LangDynFunRef{}};
\node (Rfun-5) at (9,2)  {\large \LangAnyFunRef{}};
\node (Rfun-6) at (12,2)  {\large \LangAnyFunRef{}};
\node (Rfun-7) at (12,0)  {\large \LangAnyFunRef{}};

\node (F1-2) at (9,0)  {\large \LangAnyFunRef{}};
\node (F1-3) at (6,0)  {\large \LangAnyFunRef{}};
\node (F1-4) at (3,0)  {\large \LangAnyAlloc{}};
\node (F1-5) at (0,0)  {\large \LangAnyAlloc{}};
\node (C3-2) at (3,-2)  {\large \LangCAny{}};

\node (x86-2) at (3,-4)  {\large \LangXIndCallVar{}};
\node (x86-2-1) at (3,-6)  {\large \LangXIndCallVar{}};
\node (x86-2-2) at (6,-6)  {\large \LangXIndCallVar{}};
\node (x86-3) at (6,-4)  {\large \LangXIndCallVar{}};
\node (x86-4) at (9,-4) {\large \LangXIndCall{}};
\node (x86-5) at (9,-6) {\large \LangXIndCall{}};

\path[->,bend left=15] (Rfun) edge [above] node
     {\ttfamily\footnotesize shrink} (Rfun-2);
\path[->,bend left=15] (Rfun-2) edge [above] node
     {\ttfamily\footnotesize uniquify} (Rfun-3);
\path[->,bend left=15] (Rfun-3) edge [above] node
     {\ttfamily\footnotesize reveal-functions} (Rfun-4);
\path[->,bend right=15] (Rfun-4) edge [left] node
     {\ttfamily\footnotesize cast-insert} (Rfun-5);
\path[->,bend left=15] (Rfun-5) edge [above] node
     {\ttfamily\footnotesize check-bounds} (Rfun-6);
\path[->,bend left=15] (Rfun-6) edge [left] node
     {\ttfamily\footnotesize reveal-casts} (Rfun-7);
     
\path[->,bend left=15] (Rfun-7) edge [below] node
     {\ttfamily\footnotesize convert-to-clos.} (F1-2);
\path[->,bend right=15] (F1-2) edge [above] node
     {\ttfamily\footnotesize limit-fun.} (F1-3);
\path[->,bend right=15] (F1-3) edge [above] node
     {\ttfamily\footnotesize expose-alloc.} (F1-4);
\path[->,bend right=15] (F1-4) edge [above] node
     {\ttfamily\footnotesize remove-complex.} (F1-5);
\path[->,bend right=15] (F1-5) edge [right] node
     {\ttfamily\footnotesize explicate-control} (C3-2);
\path[->,bend left=15] (C3-2) edge [left] node
     {\ttfamily\footnotesize select-instr.} (x86-2);
\path[->,bend right=15] (x86-2) edge [left] node
     {\ttfamily\footnotesize uncover-live} (x86-2-1);
\path[->,bend right=15] (x86-2-1) edge [below] node 
     {\ttfamily\footnotesize build-inter.} (x86-2-2);
\path[->,bend right=15] (x86-2-2) edge [left] node
     {\ttfamily\footnotesize allocate-reg.} (x86-3);
\path[->,bend left=15] (x86-3) edge [above] node
     {\ttfamily\footnotesize patch-instr.} (x86-4);
\path[->,bend left=15] (x86-4) edge [right] node
     {\ttfamily\footnotesize print-x86} (x86-5);
\end{tikzpicture}
  \caption{动态类型语言 \LangDyn{} 的通道图。}
\label{fig:Rdyn-passes}
\end{figure}

图~\ref{fig:Rdyn-passes} 提供编译 \LangDyn{} 所需的所有通道的概览。

% Further Reading

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{循环和赋值}
\label{ch:Rwhile}

% TODO: define R'_8

% TODO: multi-graph


在本章中，将研究命令式编程语言的两个特征:循环和局部变量赋值。下面的示例通过计算前5个正整数的和来演示这些新特性。
% similar to loop_test_1.rkt
\begin{lstlisting}
(let ([sum 0])
  (let ([i 5])
    (begin
      (while (> i 0)
        (begin
          (set! sum (+ sum i))
          (set! i (- i 1))))
      sum)))
\end{lstlisting}
 \code{while} 循环由一个条件和一个循环体组成。
%
 \code{set!} 由一个变量和右边的表达式组成。
%
 \code{while} 循环和 \code{set!} 的主要目的都是为了引起副作用，所以在语言特性中也包含用于排序副作用的 \code{begin} 表达式是很方便的。它由一个或多个从左到右求值的子表达式组成。

\section{ \LangLoop{} 语言}

\begin{figure}[tp]
\centering
\fbox{
  \begin{minipage}{0.96\textwidth}
    \small
\[
\begin{array}{lcl}
  \Exp &::=& \gray{ \Int \mid \CREAD{} \mid \CNEG{\Exp}
     \mid \CADD{\Exp}{\Exp} \mid \CSUB{\Exp}{\Exp} }  \\
    &\mid&  \gray{ \Var \mid \CLET{\Var}{\Exp}{\Exp} }\\
    &\mid& \gray{\key{\#t} \mid \key{\#f} 
     \mid (\key{and}\;\Exp\;\Exp) 
     \mid (\key{or}\;\Exp\;\Exp) 
     \mid (\key{not}\;\Exp) } \\
    &\mid& \gray{ (\key{eq?}\;\Exp\;\Exp) \mid \CIF{\Exp}{\Exp}{\Exp} } \\
    &\mid& \gray{ (\key{vector}\;\Exp\ldots) \mid
          (\key{vector-ref}\;\Exp\;\Int)} \\
    &\mid& \gray{(\key{vector-set!}\;\Exp\;\Int\;\Exp)\mid (\key{void})
    \mid (\Exp \; \Exp\ldots) } \\
    &\mid& \gray{ \LP \key{procedure-arity}~\Exp\RP 
    \mid \CLAMBDA{\LP\LS\Var \key{:} \Type\RS\ldots\RP}{\Type}{\Exp} } \\
  &\mid& \CSETBANG{\Var}{\Exp}
  \mid \CBEGIN{\Exp\ldots}{\Exp}
  \mid \CWHILE{\Exp}{\Exp} \\
  \Def &::=& \gray{ \CDEF{\Var}{\LS\Var \key{:} \Type\RS\ldots}{\Type}{\Exp} } \\
  \LangLoop{} &::=& \gray{\Def\ldots \; \Exp}
\end{array}
\]
\end{minipage}
}
\caption{ \LangLoop{} 的具体语法，扩展 \LangAny{} (图~\ref{fig:Rany-concrete-syntax})。}
\label{fig:Rwhile-concrete-syntax}
\end{figure}

\begin{figure}[tp]
\centering
\fbox{
  \begin{minipage}{0.96\textwidth}
    \small
\[
\begin{array}{lcl}
  \Exp &::=& \gray{ \INT{\Int} \VAR{\Var} \mid \LET{\Var}{\Exp}{\Exp} } \\
       &\mid& \gray{ \PRIM{\itm{op}}{\Exp\ldots} }\\
     &\mid& \gray{ \BOOL{\itm{bool}}
      \mid \IF{\Exp}{\Exp}{\Exp} } \\
     &\mid& \gray{ \VOID{} \mid \LP\key{HasType}~\Exp~\Type \RP 
     \mid \APPLY{\Exp}{\Exp\ldots} }\\
  &\mid& \gray{ \LAMBDA{\LP\LS\Var\code{:}\Type\RS\ldots\RP}{\Type}{\Exp} }\\
  &\mid& \SETBANG{\Var}{\Exp} \mid \BEGIN{\LP\Exp\ldots\RP}{\Exp}
   \mid \WHILE{\Exp}{\Exp} \\
 \Def &::=& \gray{ \FUNDEF{\Var}{\LP\LS\Var \code{:} \Type\RS\ldots\RP}{\Type}{\code{'()}}{\Exp} }\\
  \LangLoop{} &::=& \gray{ \PROGRAMDEFSEXP{\code{'()}}{\LP\Def\ldots\RP}{\Exp} }
\end{array}
\]
\end{minipage}
}
\caption{ \LangLoop{} 的抽象语法，扩展 \LangAny{} (图~\ref{fig:Rany-syntax})。}
\label{fig:Rwhile-syntax}
\end{figure}

 \LangLoop{} 的具体语法定义在图~\ref{fig:Rwhile-concrete-syntax} 中，抽象语法定义在图~\ref{fig:Rwhile-syntax} 中。
%
 \LangLoop{} 的定义解释器如图~\ref{fig:interp-Rwhile} 所示。我们添加 \code{SetBang} 、
\code{WhileLoop} 和 \code{Begin} 的三个新情况，并对变量 \code{Var} 、 \code{Let} 和 \code{Apply} 的情况进行更改。为了支持对变量的赋值并使它们的生存期不确定(见~\ref{sec:assignment-scoping} 节中的第二个例子)，将绑定到每个变量(在 \code{Let} 中)的值和函数参数(在 \code{Apply} 中)的值框起来。 \code{Var} 的情况取消该值的框。
%
现在来讨论一下新的案例。对于 \code{SetBang} ，在环境中查找变量以获得装箱值，然后使用 \code{set-box!} 将其更改为右侧求值的结果。 \code{SetBang} 的结果值是 \code{void} 。
%
对于 \code{WhileLoop} ，我们重复： 1) 计算条件，如果结果为真； 2) 对主体求值。
 \code{while} 循环的结果值也是 \code{void} 。
%
最后， $\BEGIN{\itm{es}}{\itm{body}}$ 表达式计算子表达式 \itm{es} 的效果，然后计算并返回 \itm{body} 的结果。


\begin{figure}[tbp]
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
(define interp-Rwhile-class
  (class interp-Rany-class
    (super-new)

    (define/override ((interp-exp env) e)
      (define recur (interp-exp env))
      (match e
        [(SetBang x rhs)
         (set-box! (lookup x env) (recur rhs))]
        [(WhileLoop cnd body)
         (define (loop)
           (cond [(recur cnd)  (recur body) (loop)]
                 [else         (void)]))
         (loop)]
        [(Begin es body)
         (for ([e es]) (recur e))
         (recur body)]
        [else ((super interp-exp env) e)]))
    ))

(define (interp-Rwhile p)
  (send (new interp-Rwhile-class) interp-program p))
\end{lstlisting}
\caption{ \LangLoop{} 解释器。}
\label{fig:interp-Rwhile}
\end{figure}

 \LangLoop{} 的类型检查器在图~\ref{fig:type-check-Rwhile} 中定义。对于 \code{SetBang} ，变量的类型和右侧必须一致。结果类型为
\code{Void} 。对于 \code{WhileLoop} ，条件必须是
\code{Boolean} 。结果类型也是 \code{Void} 。对于
\code{Begin} ，结果类型是其最后一个子表达式的类型。

\begin{figure}[tbp]
\begin{lstlisting}
(define type-check-Rwhile-class
  (class type-check-Rany-class
    (super-new)
    (inherit check-type-equal?)

    (define/override (type-check-exp env)
      (lambda (e)
        (define recur (type-check-exp env))
        (match e
          [(SetBang x rhs)
           (define-values (rhs^ rhsT) (recur rhs))
           (define varT (dict-ref env x))
           (check-type-equal? rhsT varT e)
           (values (SetBang x rhs^) 'Void)]
          [(WhileLoop cnd body)
           (define-values (cnd^ Tc) (recur cnd))
           (check-type-equal? Tc 'Boolean e)
           (define-values (body^ Tbody) ((type-check-exp env) body))
           (values (WhileLoop cnd^ body^) 'Void)]
          [(Begin es body)
           (define-values (es^ ts)
             (for/lists (l1 l2) ([e es]) (recur e)))
           (define-values (body^ Tbody) (recur body))
           (values (Begin es^ body^) Tbody)]
          [else ((super type-check-exp env) e)])))
    ))

(define (type-check-Rwhile p)
  (send (new type-check-Rwhile-class) type-check-program p))
\end{lstlisting}
\caption{ 在 \LangLoop{}中键入检查 \key{SetBang} 、 \key{WhileLoop} 和 \code{Begin} 的类型。}
\label{fig:type-check-Rwhile}
\end{figure}


  
乍一看，将这些语言特性转换到x86似乎很简单，因为 \LangCFun{} 中间语言已经支持我们需要的所有元素：赋值、 \code{goto} 、条件分支和排序。但是，出现了两个复杂问题，将在下两个部分中讨论。之后，引入一个新的编译器传递，并对现有传递进行必要的更改。

\section{赋值函数和词法作用域函数}
\label{sec:assignment-scoping}

添加赋值给实现词汇作用域函数的方法带来一个问题。考虑下面的例子，在这个例子中，函数 \code{f} 有一个自由变量 \code{x} ，它在创建 \code{f} 之后，但在调用 \code{f} 之前发生改变。
% loop_test_11.rkt
\begin{lstlisting}
(let ([x 0])
  (let ([y 0])
    (let ([z 20])
      (let ([f (lambda: ([a : Integer]) : Integer (+ a (+ x z)))])
        (begin
          (set! x 10)
          (set! y 12)
          (f y))))))
\end{lstlisting}
本例的正确输出是 \code{42} ，因为调用
\code{f} 需要使用 \code{x} 的当前值(即
\code{10}) 。不幸的是，闭包转换通道(第~\ref{sec:closure-conversion} 节)为
\code{lambda} 生成将 \code{x} 的旧值复制到闭包的代码。因此，如果简单地添加对当前编译器赋值的支持，这个程序的输出将是 \code{32}。

解决这个问题的第一个尝试是在闭包中保存一个指向
\code{x} 的指针，并将 \code{x} 在lambda中的出现更改为对该指针的解引用。当然，这需要将 \code{x} 赋值给堆栈，而不是寄存器。然而，问题更严重一些。考虑下面的例子，在这个例子中，通过创建一对共享自由变量 \code{x} 的函数来创建一个反抽象。
% similar to loop_test_10.rkt
\begin{lstlisting}
(define (f [x : Integer]) : (Vector ( -> Integer) ( -> Void))
  (vector
   (lambda: () : Integer x)
   (lambda: () : Void (set! x (+ 1 x)))))

(let ([counter (f 0)])
  (let ([get (vector-ref counter 0)])
    (let ([inc (vector-ref counter 1)])
      (begin
        (inc)
        (get)))))
\end{lstlisting}
在这个例子中， \code{x} 的生命周期超过调用 \code{f} 的生命周期。因此，如果要在堆栈帧中存储 \code{x} 用于调用 \code{f} ，那么当调用 \code{inc} 和 \code{get} 时，\code{x} 就会消失，只留下
\code{x} 的悬空指针。这个例子演示了当变量在 \code{lambda} 中自由出现时，它的生存期变得不确定。因此，变量的值需要存在于堆上。动词“box”通常用于在堆上分配单个值，产生一个指针，而“unbox”用于对指针解引用。

建议通过“boxing”在交集的局部变量来解决这些问题: 1) 出现在 \code{set!} 左边的变量； 2) 在 \code{lambda} 中自由出现的变量。将在第~\ref{sec:convert-assignments} 节中引入一个名为
\code{convert-assignments} 的新过程来执行这个转换。但是在深入讨论编译器传递之前，还要讨论另一个问题。

\section{循环控制流与数据流分析}
\label{sec:dataflow-analysis}

到目前为止，在
\code{explicate-control} 中生成的控制流图保证是无循环的。然而，每个
\code{while} 循环在控制流图中引入一个循环。但这有关系吗?
%
事实上确实如此。回想一下，对于寄存器分配，编译器执行动态分析，以确定哪些变量可以共享相同的寄存器。在第~\ref{sec:liveness-analysis-Rif} 节中，以逆拓扑顺序分析了控制流图，但拓扑顺序仅对无环图进行定义。

让回到计算前5个正整数的和的例子。这是在指令选择之后但在寄存器分配之前的程序。
\begin{center}
\begin{minipage}{0.45\textwidth}
\begin{lstlisting}
(define (main) : Integer
   mainstart:
      movq $0, sum1
      movq $5, i2
      jmp block5
   block5:
      movq i2, tmp3
      cmpq tmp3, $0
      jl block7
      jmp block8
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.45\textwidth}
  \begin{lstlisting}

    
block7:
      addq i2, sum1
      movq $1, tmp4
      negq tmp4
      addq tmp4, i2
      jmp block5
   block8:
      movq $27, %rax
      addq sum1, %rax
      jmp mainconclusion
)
\end{lstlisting}
  \end{minipage}
\end{center}
回想一下，活性分析是反向的，从每个函数的末尾开始。对于这个例子，可以从 \code{block8}
开始，因为我们知道在结论的开头是什么，就是 \code{rax} 和 \code{rsp} 。因此 \code{block8} 的live-before设置为 $\{\ttm{rsp},\ttm{sum1}\}$ 。
%
接下来，可能会尝试分析 \code{block5} 或 \code{block7} ，但
\code{block5} 跳转到 \code{block7} ，反之亦然，所以我们似乎被卡住了。

走出这一僵局的方法来自于这样一种认识:可以从一个空的生存后集合开始进行生存分析，以计算一个低于生存前集合的近似。所谓的
\emph{欠近似} ，是指该集合只包含真正存在的变量，但可能会遗漏一些变量。接下来，每个块的欠近似可以通过以下方法加以改进： 1) 使用来自其他块的近似的live-before集更新每个块的live-after集； 2) 再次对每个街区进行动态分析。事实上，通过迭代这个过程，欠近似最终会成为正确的解!
%
这种迭代分析控制流图的方法适用于许多静态分析问题，称为
\emph{数据流分析}\index{dataflow analysis} 。它是
\citet{Kildall:1973vn} 在华盛顿大学的博士论文中发明的。

将此方法应用于上面的示例。对于每个块，使用空集合作为初始的live-before集合。假设 $m_0$ 是从标签名到一组位置(变量和寄存器)的映射。
\begin{center}
\begin{lstlisting}
mainstart: {}
block5: {}
block7: {}
block8: {}
\end{lstlisting}
\end{center}
使用上述live-before逼近，确定每个区块的live-after，然后对每个区块应用live-after分析。这就产生live-before集合的下一个近似 $m_1$ 。
\begin{center}
  \begin{lstlisting}
mainstart: {}
block5: {i2}
block7: {i2, sum1}
block8: {rsp, sum1}
\end{lstlisting}
\end{center}

对于第二轮， \code{mainstart} 的live-after是 \code{block5} 的live-before，即 \code{\{i2\}} 。因此， \code{mainstart} 的活性分析计算的是空集合。 \code{block5} 的live-after是
\code{block7} 和 \code{block8} 的live- before集的并集，即 \code{\{i2 , rsp, sum1\}}。
因此，对 \code{block5} 的活性分析计算 \code{\{i2 , rsp,
  sum1\}} 。 \code{block7} 的live-after是
\code{block5} (来自上一个迭代)的live-before，即 \code{\{i2\}}。
因此， \code{block7} 的活性分析仍然是 \code{\{i2,
  sum1\}} 。这些组合在一起产生以下近似 $m_2$ 的 live-before 集合。
\begin{center}
  \begin{lstlisting}
mainstart: {}
block5: {i2, rsp, sum1}
block7: {i2, sum1}
block8: {rsp, sum1}
\end{lstlisting}
\end{center}
在前面的迭代中，只有 \code{block5} 发生了变化，所以可以将注意力限制在 \code{mainstart} 和 \code{block7}，这两个跳转到 \code{block5} 的块。因此， \code{mainstart} 和 \code{block7} 的live-before集合被更新为包含
\code{rsp} ，产生如下近似 $m_3$ 。
\begin{center}
  \begin{lstlisting}
mainstart: {rsp}
block5: {i2, rsp, sum1}
block7: {i2, rsp, sum1}
block8: {rsp, sum1}
\end{lstlisting}
\end{center}
因为 \code{block7} 改变，再次分析 \code{block5} ，但是它的live-before集合仍然是 \code{\{ i2, rsp, sum1 \}} 。在这一点上，我们的近似收敛了，所以 $m_3$ 是解。

通过关于格上函数的一般定理Kleene不动点定理，该迭代过程保证收敛到一个解~\citep{Kleene:1952aa} 。粗略地说， \emph{格} 是对其元素进行部分排序' $\sqsubseteq$ 、最小元素 $\bot$ (发音为 bottom) 和连接操作符 $\sqcup$ 的集合。\index{lattice}\index{bottom}\index{partial
  ordering}\index{join}\footnote{从技术上讲，我们将使用连接半格。} 当两个元素被排序为 $m_i
\sqsubseteq m_j$ ，这意味着 $m_j$ 包含的信息至少和 $m_i$ 一样多，所以可以认为 $m_j$ 是一个比 $m_i$ 更好或相等的近似值。底部的元素 $\bot$ 表示完全缺乏信息，即最糟糕的近似。连接运算符取两个格元并组合它们的信息，也就是说，它产生这两个格元的最小上界。\index{least upper
  bound}

数据流分析通常涉及两个格:一个格表示抽象状态，另一个格聚集控制流图中所有块的抽象状态。对于活性分析，抽象状态是一组位置。将晶格 $L$ 的元素取为位置集合，其顺序为集合包含 ($\subseteq$)，底部为空集合，连接算子为集合并集，从而构成晶格 $L$ 。
%
通过把它的元素从块标签映射到位置集合( $L$ 的元素)来形成第二个格 $M$ 。使用 $L$ 的顺序逐点排列映射。因此给定任意两个映射 $m_i$ 和 $m_j$ ， $m_i \sqsubseteq_M m_j$ ，当 $m_i(\ell)
\subseteq m_j(\ell)$ 对应程序中的每个块标号 $\ell$ '时。 $M$ 的底部元素是将每个标号发送到空集合的映射 $\bot_M$ ，即 $\bot_M(\ell) = \emptyset$ 。

可以把活性分析的一次迭代看成是晶格 $M$ 上的函数 $f$ 。它将一个映射作为输入，并计算一个新的映射。
\[
   f(m_i) = m_{i+1}
\]
接下来，思考一下 $m_s$
的最终解决方案应该是什么样的。如果使用
$m_s$ 作为输入进行活性分析，应该再次得到 $m_s$ 作为输出。也就是说，解应该是函数 $f$ 的一个 \emph{不动点} 。\index{fixed point}
\[
   f(m_s) = m_s
\]
此外，该解决方案应该只包括通过对程序执行活性分析而强制出现的位置，因此该解决方案应该是 \emph{最小} 固定点。\index{least fixed point}

Kleene不动点定理指出，如果一个函数 $f$ 是单调的(更好的输入产生更好的输出)，那么 $f$ 的最小不动点就是从 $\bot$ 开始，按照下面的方法迭代 $f$ 得到的 \emph{上升Kleene链} 的最小上界。\index{Kleene Fixed-Point Theorem}
\[
\bot \sqsubseteq f(\bot) \sqsubseteq f(f(\bot)) \sqsubseteq \cdots
  \sqsubseteq f^n(\bot) \sqsubseteq \cdots
\]
当一个晶格只包含有限长的上升链时，每个Kleene链在 $f$ 的多次迭代后在某个不动点上达到顶点。所以不动点也是链的最小上界。
\[
\bot \sqsubseteq f(\bot) \sqsubseteq f(f(\bot)) \sqsubseteq \cdots
\sqsubseteq f^k(\bot) = f^{k+1}(\bot) = m_s
\]

活性分析确实是一个单调函数，格
$M$ 只有有限长的上升链，因为程序中只有有限数量的变量和块。从而保证对程序中所有块进行活性分析迭代，最终得到最小不动点解。

接下来考虑一般的数据流分析，并讨论通用的工作列表算法(图~\ref{fig:generic-dataflow})。
%
该算法有四个参数:控制流图 \code{G} ，将分析应用于一个块的函数 \code{transfer} ，抽象状态格的
\code{bottom} 和 \code{join} 操作符。该算法首先创建由散列表表示的底部映射。然后，它将控制流图中的所有节点推入工作列表(一个队列)。只要工作列表中还有项目，算法就重复 \code{while} 循环。在每次迭代中，从工作列表中弹出一个节点并进行处理。节点的
\code{input} 是通过接受所有前任节点的抽象状态的连接来计算的。然后应用 \code{transfer}
函数来获得 \code{output} 抽象状态。如果此块的输出与之前的状态不同，则更新此块的映射，并将其后续节点推入工作列表。

\begin{figure}[tb]
\begin{lstlisting}
(define (analyze-dataflow G transfer bottom join)
  (define mapping (make-hash))
  (for ([v (in-vertices G)])
    (dict-set! mapping v bottom))
  (define worklist (make-queue))
  (for ([v (in-vertices G)])
    (enqueue! worklist v))
  (define trans-G (transpose G))
  (while (not (queue-empty? worklist))
    (define node (dequeue! worklist)) 
    (define input (for/fold ([state bottom])
                            ([pred (in-neighbors trans-G node)])
                    (join state (dict-ref mapping pred))))
    (define output (transfer node input))
    (cond [(not (equal? output (dict-ref mapping node)))
           (dict-set! mapping node output)
           (for ([v (in-neighbors G node)])
             (enqueue! worklist v))]))
  mapping)
\end{lstlisting}
\caption{用于数据流分析的通用工作表算法}
  \label{fig:generic-dataflow}
\end{figure}

讨论由于添加对赋值和循环的支持而引起的两个复杂问题之后，转而讨论一个新的编译器通道以及对现有通道的重大更改。

\section{转换任务}
\label{sec:convert-assignments}

回想一下，在第~\ref{sec:assignment-scoping} 节中，学习赋值和词法作用域函数的组合要求将那些既被赋值又在 \code{lambda} 中显示为自由的变量框起来。
\code{convert-assignments} 通道的目的就是执行转换。
建议将此通行证放在 \code{uniquify} 之后，但在\code{reveal-functions} 之前。

再次考虑~\ref{sec:assignment-scoping} 节中的第一个例子:
\begin{lstlisting}
(let ([x 0])
  (let ([y 0])
    (let ([z 20])
      (let ([f (lambda: ([a : Integer]) : Integer (+ a (+ x z)))])
        (begin
          (set! x 10)
          (set! y 12)
          (f y))))))
\end{lstlisting}

变量 \code{x} 和 \code{y} 被赋值。变量
\code{x} 和 \code{z} 在 \code{lambda} 中自由出现。因此，变量 \code{x} 需要装箱，而不是 \code{y} 和 \code{z}
。 \code{x} 的装箱由三个变换组成:用向量初始化
\code{x} ，用 \code{vector-ref} 替换从 \code{x} 读取的内容，用 \code{vector-set!} 替换 \code{x} 上的每个 \code{set!} 。这个例子的 \code{convert-assignments} 输出如下所示。
\begin{lstlisting}
(define (main) : Integer
  (let ([x0 (vector 0)])
    (let ([y1 0])
      (let ([z2 20])
        (let ([f4 (lambda: ([a3 : Integer]) : Integer
                      (+ a3 (+ (vector-ref x0 0) z2)))])
          (begin 
            (vector-set! x0 0 10)
            (set! y1 12)
            (f4 y1)))))))
\end{lstlisting}

\paragraph{Assigned \& Free}

建议定义一个名为
\code{assigned\&free} 的辅助函数，它接受一个表达式并同时进行计算： 1) 一组赋值变量 $A$ ； 2) 在Lambda的范围内自由出现的一组变量 $F$ ； 3) 一个新版本的表达式，记录在 $A$ 和 $F$ 的交点上出现的边界变量。可以使用结构
\code{AssignedFree} 来做这个。考虑
$\LET{x}{\itm{rhs}}{\itm{body}}$ 的情况。假设对
$\itm{rhs}$ 的递归调用产生 $\itm{rhs}'$ 、 $A_r$ 和 $F_r$ ，对 $\itm{body}$ 的递归调用产生 $\itm{body}'$ 、 $A_b$ 和 $F_b$ 。如果 $x$ 在 $A_b\cap F_b$ 中，那么对 \code{Let} 进行如下变换。
\begin{lstlisting}
  (Let |$x$| |$rhs$| |$body$|)
  |$\Rightarrow$|
  (Let (AssignedFree |$x$|) |$rhs'$| |$body'$|)
\end{lstlisting}
如果 $x$ 不在 $A_b\cap F_b$ 中，则省略 \code{AssignedFree} 。
为此 \code{Let} 分配的变量集为 $A_r \cup (A_b - \{x\})$
，在lambda中自由的变量集为 $F_r \cup (F_b - \{x\})$ 。

 $\SETBANG{x}{\itm{rhs}}$ 的情况很简单，但很重要。递归处理 \itm{rhs} 得到 \itm{rhs'} 、 $A_r$
和 $F_r$ 。结果是 $\SETBANG{x}{\itm{rhs'}}$, $\{x\} \cup A_r$ 和 $F_r$ 。

 $\LAMBDA{\itm{params}}{T}{\itm{body}}$ 的情况有点复杂。设 \itm{body'} 、 $A_b$ 和 $F_b$ 为递归处理 \itm{body} 的结果。将 $A_b \cap F_b$ 中出现的每个参数用 \code{AssignedFree} 包装以产生 \itm{params'} 。
设 $P$ 是 \itm{params} 中的参数名集合。结果是
$\LAMBDA{\itm{params'}}{T}{\itm{body'}}$, $A_b - P$ 和 $(F_b \cup
\mathrm{FV}(\itm{body})) - P$ ，其中 $\mathrm{FV}$ 计算表达式的自由变量(见第~\ref{ch:Rlam} 章)。

\paragraph{转换任务}

接下来，将讨论 \code{convert-assignment} 通道及其用于表达式和定义的辅助函数。表达式的函数 \code{cnvt-assign-exp} 应该接受一个表达式和一组赋值和自由变量(从
\code{assigned\&free} 的结果中获得)。在 $\VAR{x}$ 的情况下，如果 $x$ 是赋值和自由，那么通过将 $\VAR{x}$ 转换为 \code{vector-ref} 来取消框。
\begin{lstlisting}
  (Var |$x$|)
  |$\Rightarrow$|
  (Prim 'vector-ref (list (Var |$x$|) (Int 0)))
\end{lstlisting}
%
对于 $\LET{\LP\code{AssignedFree}\,
  x\RP}{\itm{rhs}}{\itm{body}}$ ，递归处理 \itm{rhs} 得到 \itm{rhs'} 。接下来，递归地处理 \itm{body} 以获得
\itm{body'} ，但是将 $x$ 添加到赋值和自由变量集合中。将let表达式按照如下方式进行转换，将 $x$ 绑定到一个已装箱的值。
\begin{lstlisting}
  (Let (AssignedFree |$x$|) |$rhs$| |$body$|)
  |$\Rightarrow$|
  (Let |$x$| (Prim 'vector (list |$rhs'$|)) |$body'$|)
\end{lstlisting}
%
在 $\SETBANG{x}{\itm{rhs}}$ 的情况下，递归地处理
\itm{rhs} 以获得 \itm{rhs'} 。如果 $x$ 在赋值和自由变量中，将 \code{set!} 转换为 \code{vector-set!}
，如下所示。
\begin{lstlisting}
  (SetBang |$x$| |$\itm{rhs}$|)
  |$\Rightarrow$|
  (Prim 'vector-set! (list (Var |$x$|) (Int 0) |$\itm{rhs'}$|))
\end{lstlisting}
%
 \code{Lambda} 的情况并不简单，但它与我们接下来讨论的函数定义的情况类似。

定义的辅助函数 \code{cnvt-assign-def} 将赋值转换应用于函数定义。
将函数定义翻译如下。
\begin{lstlisting}
  (Def |$f$| |$\itm{params}$| |$T$| |$\itm{info}$| |$\itm{body_1}$|)
  |$\Rightarrow$|
  (Def |$f$| |$\itm{params'}$| |$T$| |$\itm{info}$| |$\itm{body_4}$|)
\end{lstlisting}

因此，仍然需要解释 \itm{params'} 和 $\itm{body}_4$ 。
让 \itm{body_2} 、 $A_b$ 和 $F_b$ 是
\code{assigned\&free} 在 $\itm{body_1}$ 上的结果。
设 $P$ 为 \itm{params} 中的参数名。
然后应用 \code{cnvt-assign-exp} 到 $\itm{body_2}$ 获得 \itm{body_3} ，传递 $A_b \cap F_b \cap P$
作为赋值和自由变量集。
最后，通过将 \itm{body_3} 包装在一个序列的let表达式中，
这个表达式参数绑定在 $A_b \cap F_b$，来获得 \itm{body_4} 。
%
关于 \itm{params'} ，更改 $A_b \cap F_b$ 中的参数名称以保持唯一性(这样let-bound变量可以保留原来的名称)。回想一下第~\ref{sec:assignment-scoping} 节中涉及反抽象的第二个例子。下面是函数 \code{f} 的赋值版本的输出。
\begin{lstlisting}
(define (f0 [x1 : Integer]) : (Vector ( -> Integer) ( -> Void))
  (vector
   (lambda: () : Integer x1)
   (lambda: () : Void (set! x1 (+ 1 x1)))))
|$\Rightarrow$|
(define (f0 [param_x1 : Integer]) : (Vector (-> Integer) (-> Void))
  (let ([x1 (vector param_x1)])
    (vector (lambda: () : Integer (vector-ref x1 0))
             (lambda: () : Void
                (vector-set! x1 0 (+ 1 (vector-ref x1 0)))))))
\end{lstlisting}


\section{去除复杂的操作数}
\label{sec:rco-loop}

三种新的语言形式， \code{while} 、 \code{set!} 和
\code{begin} 都是复杂表达式，它们的子表达式也允许是复杂的。图~\ref{fig:Rfun-anf-syntax} 定义这个通道的输出语言 \LangFunANF{} 。

\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\small
\[
\begin{array}{rcl}
\Atm &::=& \gray{ \INT{\Int} \mid \VAR{\Var} \mid \BOOL{\itm{bool}}
       \mid \VOID{} } \\
\Exp &::=& \ldots \mid \gray{ \LET{\Var}{\Exp}{\Exp} } \\
    &\mid& \WHILE{\Exp}{\Exp} \mid \SETBANG{\Var}{\Exp}
   \mid \BEGIN{\LP\Exp\ldots\RP}{\Exp} \\
\Def &::=& \gray{ \FUNDEF{\Var}{([\Var \code{:} \Type]\ldots)}{\Type}{\code{'()}}{\Exp} }\\
R^{\dagger}_8  &::=& \gray{ \PROGRAMDEFS{\code{'()}}{\Def} }
\end{array}
\]
\end{minipage}
}
\caption{\LangLoopANF{} 是管理标准形式(ANF)中的 \LangLoop{} 。}
\label{fig:Rwhile-anf-syntax}
\end{figure}

通常，当复杂表达式出现在需要是原子性的语法位置时，例如原语操作符的参数，必须引入一个临时变量并将其绑定到复杂表达式。这种方法同样适用于处理新的语言形式。例如，在下面的代码中，有两个
\code{begin} 表达式作为 \code{+} 的参数出现。 \code{rco-exp} 的输出如下所示，其中 \code{begin}
表达式已经绑定到临时变量。回想一下， \LangLoopANF{} 中的
\code{let} 表达式被允许在其右侧表达式中有任意表达式，所以将 \code{begin} 放在那里是没问题的。

\begin{lstlisting}
(let ([x0 10])
  (let ([y1 0])
    (+ (+ (begin (set! y1 (read)) x0)
           (begin (set! x0 (read)) y1))
       x0)))
|$\Rightarrow$|
(let ([x0 10])
  (let ([y1 0])
    (let ([tmp2 (begin (set! y1 (read)) x0)])
      (let ([tmp3 (begin (set! x0 (read)) y1)])
        (let ([tmp4 (+ tmp2 tmp3)])
          (+ tmp4 x0))))))
\end{lstlisting}

\section{说明控制和 \LangCLoop{}}
\label{sec:explicate-loop}

回想一下，在 \code{explicate-control} 通道中，为程序中的每种位置定义一个助手函数。对于整数和变量的 \LangVar{}
语言，需要各种位置:赋值和尾部。\LangIf{} 的 \code{if} 表达式引入谓词位置。对于 \LangLoop{} ， \code{begin} 表达式引入另一种位置:效果位置。除最后一个子表达式外， \code{begin} 语句中的子表达式只计算它们的效果。它们的结果值将被丢弃。考虑到这一点，可以生成更好的代码。

 \code{explicate-control} 的输出语言是 \LangCLoop{}(图~\ref{fig:c7-syntax}) ，它几乎等同于
\LangCLam{} 。唯一的语法区别是 \code{Call} 、
\code{vector-set!} 和 \code{read} 也可以作为语句出现。
 \LangCLam{} 和 \LangCLoop{} 语言的最大区别是什么?后者的控制流图可能包含循环。


\begin{figure}[tp]
\fbox{
\begin{minipage}{0.96\textwidth}
\small
\[
\begin{array}{lcl}
\Stmt &::=& \gray{ \ASSIGN{\VAR{\Var}}{\Exp} 
       \mid \LP\key{Collect} \,\itm{int}\RP } \\
     &\mid& \CALL{\Atm}{\LP\Atm\ldots\RP} \mid \READ{}\\
     &\mid& \LP\key{Prim}~\key{'vector-set!}\,\LP\key{list}\,\Atm\,\INT{\Int}\,\Atm\RP\RP \\
\Def &::=& \DEF{\itm{label}}{\LP\LS\Var\key{:}\Type\RS\ldots\RP}{\Type}{\itm{info}}{\LP\LP\itm{label}\,\key{.}\,\Tail\RP\ldots\RP}\\
\LangCLoop{} & ::= & \PROGRAMDEFS{\itm{info}}{\LP\Def\ldots\RP} 
\end{array}
\]
\end{minipage}
}
\caption{ \LangCLoop{} 的抽象语法，扩展 \LangCLam{} (图~\ref{fig:c4-syntax})。}
\label{fig:c7-syntax}
\end{figure}

新的辅助函数 \code{explicate-effect} 接受一个表达式(在effect位置)和一个延续块的承诺。该函数返回一个 $\Tail$ 的承诺，其中包括为输入表达式生成的代码，后面跟着延续块。如果表达式明显是纯的，也就是说，从不引起副作用，那么可以删除该表达式，因此结果只是延续块。
%
 $\WHILE{\itm{cnd}}{\itm{body}}$ 表达式是最有趣的情况。首先，需要一个新的标签 $\itm{loop}$ 作为循环的顶部。用 \code{goto} 递归处理 \itm{body} （有效位置），以 $\itm{loop}$ 作为延续，产生
\itm{body'} 。接下来，处理 \itm{cnd} (谓词位置)，将
\itm{body'} 作为then-branch，并将continuation块作为else-branch。结果应该添加到带有 \itm{loop} 标签的控制流图中。整个 \code{while} 循环的结果是
\code{goto} 到 \itm{loop} 标签。请注意，只有在确实使用循环时，才应该将循环添加到控制流图中，这可以使用 \code{delay} 来完成。

用于尾部、赋值和谓词位置的辅助函数需要更新。三种新的语言形式， \code{while} 、
\code{set!} 和 \code{begin} ，可以出现在赋值和尾部位置。只有 \code{begin} 可以出现在谓词位置中;另外两个结果类型为 \code{Void} 。

\section{选择指令}
\label{sec:select-instructions-loop}

在\code{select-instructions} 通道中只需要三个小的添加就可以处理对 \LangCLoop{} 的更改。也就是说， \code{Call} 、 \code{read} 和 \code{vector-set!} 现在可以作为独立语句出现，而不是只出现在赋值语句的右侧。代码生成几乎是相同的;只要去掉将结果移到左边的指令。

\section{寄存器分配}
\label{sec:register-allocation-loop}

如第~\ref{sec:dataflow-analysis} 节所述， \LangLoop{} 中循环的存在意味着控制流图可能包含循环，这使寄存器分配所需的动态分析变得复杂。

\subsection{活性分析}
\label{sec:liveness-analysis-r8}

建议使用 ~\ref{sec:dataflow-analysis} 节末尾介绍的泛型 \code{analyze-dataflow} 函数来执行活性分析，替换
\code{uncover-live-CFG} 中按照拓扑顺序处理基本块的代码(~\ref{sec:liveness-analysis-Rif} 节)。

 \code{analyze-dataflow} 函数有四个参数。
\begin{enumerate}
\item 第一个参数 \code{G} 应该是一个来自
  \code{racket/graph} 包(见~\ref{sec:build-interference} 节侧边栏)的有向图，它表示控制流图。
\item 第二个参数 \code{transfer} 是一个将活性分析应用于基本块的函数。它需要两个参数:要分析的块的标签和该块的live-after设置。传递函数应该返回活动前设置块。此外，作为一个副作用，它应该用每个指令的活性信息更新块的
  $\itm{info}$ 。要实现 \code{transfer} 函数，你应该能够重用代码，你已经有分析基本块。
\item  \code{analyze-dataflow} 的第三和第四个参数是抽象状态格的
  \code{bottom} 和 \code{join} ，即位置集合。格的底部是空集
  \code{(set)} ，连接算子是 \code{set-union} 。
\end{enumerate}


\begin{figure}[p]
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (Rfun) at (0,2)  {\large \LangLoop{}};
\node (Rfun-2) at (3,2)  {\large \LangLoop{}};
\node (Rfun-3) at (6,2)  {\large \LangLoop{}};
\node (Rfun-4) at (9,2)  {\large \LangLoopFunRef{}};
\node (F1-1) at (12,0)  {\large \LangLoopFunRef{}};
\node (F1-2) at (9,0)  {\large \LangLoopFunRef{}};
\node (F1-3) at (6,0)  {\large \LangLoopFunRef{}};
\node (F1-4) at (3,0)  {\large \LangLoopAlloc{}};
\node (F1-5) at (0,0)  {\large \LangLoopAlloc{}};
\node (C3-2) at (3,-2)  {\large \LangCLoop{}};

\node (x86-2) at (3,-4)  {\large \LangXIndCallVar{}};
\node (x86-2-1) at (3,-6)  {\large \LangXIndCallVar{}};
\node (x86-2-2) at (6,-6)  {\large \LangXIndCallVar{}};
\node (x86-3) at (6,-4)  {\large \LangXIndCallVar{}};
\node (x86-4) at (9,-4) {\large \LangXIndCall{}};
\node (x86-5) at (9,-6) {\large \LangXIndCall{}};


%% \path[->,bend left=15] (Rfun) edge [above] node
%%      {\ttfamily\footnotesize type-check} (Rfun-2);
\path[->,bend left=15] (Rfun) edge [above] node
     {\ttfamily\footnotesize shrink} (Rfun-2);
\path[->,bend left=15] (Rfun-2) edge [above] node
     {\ttfamily\footnotesize uniquify} (Rfun-3);
\path[->,bend left=15] (Rfun-3) edge [above] node
     {\ttfamily\footnotesize reveal-functions} (Rfun-4);
\path[->,bend left=15] (Rfun-4) edge [right] node
     {\ttfamily\footnotesize convert-assignments} (F1-1);
\path[->,bend left=15] (F1-1) edge [below] node
     {\ttfamily\footnotesize convert-to-clos.} (F1-2);
\path[->,bend right=15] (F1-2) edge [above] node
     {\ttfamily\footnotesize limit-fun.} (F1-3);
\path[->,bend right=15] (F1-3) edge [above] node
     {\ttfamily\footnotesize expose-alloc.} (F1-4);
\path[->,bend right=15] (F1-4) edge [above] node
     {\ttfamily\footnotesize remove-complex.} (F1-5);
\path[->,bend right=15] (F1-5) edge [right] node
     {\ttfamily\footnotesize explicate-control} (C3-2);
\path[->,bend left=15] (C3-2) edge [left] node
     {\ttfamily\footnotesize select-instr.} (x86-2);
\path[->,bend right=15] (x86-2) edge [left] node
     {\ttfamily\footnotesize uncover-live} (x86-2-1);
\path[->,bend right=15] (x86-2-1) edge [below] node 
     {\ttfamily\footnotesize build-inter.} (x86-2-2);
\path[->,bend right=15] (x86-2-2) edge [left] node
     {\ttfamily\footnotesize allocate-reg.} (x86-3);
\path[->,bend left=15] (x86-3) edge [above] node
     {\ttfamily\footnotesize patch-instr.} (x86-4);
\path[->,bend left=15] (x86-4) edge [right] node {\ttfamily\footnotesize print-x86} (x86-5);
\end{tikzpicture}
  \caption{ \LangLoop{} 的通道图(循环和赋值)。}
\label{fig:Rwhile-passes}
\end{figure}

图~\ref{fig:Rwhile-passes} 提供了编译 \LangLoop{} 所需的所有通道的概述。


\section{挑战:数组}
\label{sec:arrays}

在第~\ref{ch:Rvec} 章中，学习元组，即元素序列，其长度在编译时确定，并且元组中的每个元素可能有不同的类型(它们是异构的)。这个挑战也与序列有关，但这一次的长度是在运行时确定的，并且所有元素都具有相同的类型(它们是同构的)。对于后面的这种序列，我们使用术语“数组”。

 Racket 语言不区分元组和数组，它们都用向量表示。但是，类型化 Racket 区分元组和数组: \code{Vector} 类型用于元组， \code{Vectorof} 类型用于数组。
%
图~\ref{fig:Rvecof-concrete-syntax} 定义 \LangArray{} 的具体语法，使用 \code{Vectorof} 类型和 \code{make-vector} 原语操作符扩展  \LangLoop{} ，用于创建数组，其参数是数组的长度和数组中所有元素的初始值。为元组定义的 \code{vector-length} 、\code{vector-ref} 和 \code{vector-ref!} 操作符被重载以用于数组。
%
还在 \LangArray{} 中包含整数乘法，因为它在许多涉及数组的例子中很有用，比如计算两个数组的内积(图~\ref{fig:inner-product})。


\begin{figure}[tp]
\centering
\fbox{
  \begin{minipage}{0.96\textwidth}
    \small
\[
\begin{array}{lcl}
  \Type &::=& \ldots \mid \LP \key{Vectorof}~\Type \RP \\
  \Exp &::=& \gray{ \Int \mid \CREAD{} \mid \CNEG{\Exp}
     \mid \CADD{\Exp}{\Exp} \mid \CSUB{\Exp}{\Exp} }  \mid \CMUL{\Exp}{\Exp}\\
    &\mid&  \gray{ \Var \mid \CLET{\Var}{\Exp}{\Exp} }\\
    &\mid& \gray{\key{\#t} \mid \key{\#f} 
     \mid \LP\key{and}\;\Exp\;\Exp\RP 
     \mid \LP\key{or}\;\Exp\;\Exp\RP 
     \mid \LP\key{not}\;\Exp\RP } \\
    &\mid& \gray{ \LP\key{eq?}\;\Exp\;\Exp\RP \mid \CIF{\Exp}{\Exp}{\Exp} } \\
    &\mid& \gray{ \LP\key{vector}\;\Exp\ldots\RP \mid
          \LP\key{vector-ref}\;\Exp\;\Int\RP} \\
    &\mid& \gray{\LP\key{vector-set!}\;\Exp\;\Int\;\Exp\RP\mid \LP\key{void}\RP
    \mid \LP\Exp \; \Exp\ldots\RP } \\
    &\mid& \gray{ \LP \key{procedure-arity}~\Exp\RP 
    \mid \CLAMBDA{\LP\LS\Var \key{:} \Type\RS\ldots\RP}{\Type}{\Exp} } \\
  &\mid& \gray{ \CSETBANG{\Var}{\Exp}
  \mid \CBEGIN{\Exp\ldots}{\Exp}
  \mid \CWHILE{\Exp}{\Exp} } \\
  &\mid& \CMAKEVEC{\Exp}{\Exp} \\
  \Def &::=& \gray{ \CDEF{\Var}{\LS\Var \key{:} \Type\RS\ldots}{\Type}{\Exp} } \\
  \LangArray{} &::=& \gray{\Def\ldots \; \Exp}
\end{array}
\]
\end{minipage}
}
\caption{ \LangArray{} 的具体语法，扩展 \LangLoop{} (图~\ref{fig:Rwhile-concrete-syntax})。}
\label{fig:Rvecof-concrete-syntax}
\end{figure}


\begin{figure}[tp]
\begin{lstlisting}
(define (inner-product [A : (Vectorof Integer)] [B : (Vectorof Integer)]
                       [n : Integer]) : Integer
  (let ([i 0])
    (let ([prod 0])
      (begin
        (while (< i n)
          (begin
            (set! prod (+ prod (* (vector-ref A i)
                                  (vector-ref B i))))
            (set! i (+ i 1))
            ))
        prod))))
  

(let ([A (make-vector 2 2)])
  (let ([B (make-vector 2 3)])
    (+ (inner-product A B 2)
       30)))
\end{lstlisting}
\caption{计算内积的示例程序。}
\label{fig:inner-product}
\end{figure}


 \LangArray{} 的类型检查器在图~\ref{fig:type-check-Rvecof} 中定义。
\code{make-vector} 的结果类型是 \code{(Vectorof T)} ，其中 \code{T} 是初始化表达式的类型。长度表达式必须具有 \code{Integer} 类型。操作符
\code{vector-length} 、 \code{vector-ref} 和 \code{vector-set!}  的类型检查更新以处理向量具有
\code{Vectorof} 类型的情况。在这些情况下，将操作符转换为
\code{vectorof} 形式，以便稍后的通道可以很容易地区分元组和数组上的操作。重写
\code{operator-types} 方法以提供用于乘法的类型签名:它接受两个整数并返回一个整数。为了支持 \code{Any} 类型的数组注入和投影(~\ref{sec:Rany-lang} 节)，还覆盖 \code{flat-ty?} 谓词。

\begin{figure}[tbp]
\begin{lstlisting}
(define type-check-Rvecof-class
  (class type-check-Rwhile-class
    (super-new)
    (inherit check-type-equal?)

    (define/override (flat-ty? ty)
      (match ty
        ['(Vectorof Any) #t]
        [else (super flat-ty? ty)]))
    
    (define/override (operator-types)
      (append '((* . ((Integer Integer) . Integer)))
              (super operator-types)))
    
    (define/override (type-check-exp env)
      (lambda (e)
        (define recur (type-check-exp env))
        (match e
          [(Prim 'make-vector (list e1 e2))
           (define-values (e1^ t1) (recur e1))
           (define-values (e2^ elt-type) (recur e2))
           (define vec-type `(Vectorof ,elt-type))
           (values (HasType (Prim 'make-vector (list e1^ e2^)) vec-type)
                   vec-type)]
          [(Prim 'vector-ref (list e1 e2))
           (define-values (e1^ t1) (recur e1))
           (define-values (e2^ t2) (recur e2))
           (match* (t1 t2)
             [(`(Vectorof ,elt-type) 'Integer)
              (values (Prim 'vectorof-ref (list e1^ e2^)) elt-type)]
             [(other wise) ((super type-check-exp env) e)])]
\end{lstlisting}
\end{figure}
\begin{figure}[tbp]
\begin{lstlisting}             
          [(Prim 'vector-set! (list e1 e2 e3) )
           (define-values (e-vec t-vec) (recur e1))
           (define-values (e2^ t2) (recur e2))
           (define-values (e-arg^ t-arg) (recur e3))
           (match t-vec
             [`(Vectorof ,elt-type)
              (check-type-equal? elt-type t-arg e)
              (values (Prim 'vectorof-set! (list e-vec e2^ e-arg^))  'Void)]
             [else ((super type-check-exp env) e)])]
          [(Prim 'vector-length (list e1))
           (define-values (e1^ t1) (recur e1))
           (match t1
             [`(Vectorof ,t)
              (values (Prim 'vectorof-length (list e1^))  'Integer)]
             [else ((super type-check-exp env) e)])]
          [else ((super type-check-exp env) e)])))
    ))

(define (type-check-Rvecof p)
  (send (new type-check-Rvecof-class) type-check-program p))
\end{lstlisting}
\caption{ \LangArray{} 语言的类型检查器。}
\label{fig:type-check-Rvecof}
\end{figure}

 \LangArray{} 的解释器定义在图~\ref{fig:interp-Rvecof} 中。 \code{make-vector} 运算符是通过 Racket 的 \code{make-vector} 函数实现的，乘法是 \code{fx*} ，用于 \code{fixnum} 整数的乘法。

\begin{figure}[tbp]
\begin{lstlisting}
(define interp-Rvecof-class
  (class interp-Rwhile-class
    (super-new)

    (define/override (interp-op op)
      (verbose "Rvecof/interp-op" op)
      (match op
        ['make-vector make-vector]
        ['* fx*]
        [else (super interp-op op)]))
    ))

(define (interp-Rvecof p)
  (send (new interp-Rvecof-class) interp-program p))
\end{lstlisting}
\caption{\LangArray{} 解释器}
\label{fig:interp-Rvecof}
\end{figure}


\subsection{数据表示法}
\label{sec:array-rep}

就像元组一样，将数组存储在堆上，这意味着垃圾收集器将需要检查数组。一个直接的想法是对数组使用与元组相同的表示。
但是，将元组的长度限制为 $50$ ，以便它们的长度和指针掩码可以适合每个元组开始的64位标签(~\ref{sec:data-rep-gc} 节)。希望数组允许数百万个元素，所以需要更多的位来存储长度。
但是，因为数组是同构的，所以指针掩码只需要 $1$ 位，而不是每个数组元素需要1位。最后，垃圾收集器需要能够区分元组和数组，因此需要为此保留 $1$ 位。因此，得到数组开头的64位标签的如下布局:
\begin{itemize}
\item 最右边的位是转发位，就像在元组中一样。
   $0$ 表示是转发指针， $1$ 表示不是。
  
\item 左边的下一位是指针掩码。 $0$ 表示没有一个元素是指向堆的指针， $1$
  表示所有元素都是指针。

\item 接下来的 $61$ 位存储数组的长度。

\item 最左边的位区分元组 ($0$) 和数组 ($1$)。
\end{itemize}


回想一下在第~\ref{ch:Rdyn} 章中，使用 $3$ 位标记来区分注入到
\code{Any} 类型中的值的类型。使用位模式 \code{110} (或十进制的 $6$ )
来表示该值是一个数组。

在下面的小节中，提供有关如何更新传递以处理数组的提示。


\subsection{显示演员表}

数组访问操作符 \code{vectorof-ref} 和
\code{vectorof-set!} 与第 ~\ref{ch:Rdyn} 章的 \code{any-vector-ref} 和
\code{any-vector-set!} 类似，，因为类型检查器不能判断索引是否有边界，所以必须在运行时执行边界检查。回想一下，
\code{reveal-casts} 通道(第~\ref{sec:reveal-casts-Rany} 节)在vector引用周围包裹一个 \code{If} ，以便更新以检查索引是否小于长度。应该对\code{vectorof-ref} 和 \code{vectorof-set!} 做同样的事情。

此外，需要更新 \code{reveal-casts} 的 \code{any-vector} 操作符的处理，以考虑注入到 \code{Any} 中的数组。对于 \code{any-vector-length} 操作符，生成的代码应该测试标记是用于元组 (\code{010})
还是数组 (\code{110}) ，然后分派到
\code{any-vector-length} 或 \code{any-vectorof-length} 。对于后者，在 \code{select-instructions} 中添加一个case，以生成从数组头访问数组长度的适当指令。

 \code{any-vector-ref} 和 \code{any-vector-set!} 操作符,件给出代码需要检查指数小于向量的长度,就像 \code{any-vector-length} 的代码,检查标签是否使用 \code{any-vector-length} 或
\code{any-vectorof-length} 这一目的。一旦边界检查完成，生成的代码就可以使用 \code{any-vector-ref} 和
\code{any-vector-set!} ，对于元组和数组，因为用于这些操作符的指令不查看元组或数组前面的标记。
\subsection{公开分配}

这个过程应该把 \code{make-vector} 操作符转换成更低级的操作。特别是，新的AST节点
$\LP\key{AllocateArray}~\Exp~\Type\RP$ 分配一个 $\Exp$ 指定长度的数组，但不初始化数组中的元素。(类似于元组的 \code{Allocate} AST 节点。)
 $\Type$ 参数必须是 $\LP\key{Vectorof}~T\RP$ ，其中 $T$ 是数组的元素类型。关于数组的初始化，建议生成一个 \code{while} 循环，使用
\code{vector-set!} 将初始值放入数组的每个元素中。

\subsection{去除复杂的操作数}

在 \code{AllocateArray} 的 \code{rco-atom} 和 \code{rco-exp} 中添加案例。特别是， \code{AllocateArray} 节点是复杂的，它的子表达式必须是原子的。

\subsection{说明控制}

为 \code{AllocateArray} 添加 \code{explicate-tail} 和 \code{explicate-assign} 案例。

\subsection{选择指令}

为 \code{AllocateArray} 生成与第 ~\ref{sec:select-instructions-gc} 节中的
\code{Allocate} 类似的指令，除了在数组开头的标签应使用第~\ref{sec:array-rep} 节中讨论的表示形式。

对于 \code{vectorof-length} ，根据第~\ref{sec:array-rep} 节中讨论的表示从标签中提取长度。

 \code{vectorof-ref} 生成的指令不同于 \code{vector-ref} (~\ref{sec:select-instructions-gc} 节) ，因为索引不是一个常量，所以偏移量必须在运行时计算，类似于
\code{any-vector-of-ref} (~\ref{sec:select-Rany} 节)生成的指令。 \code{vectorof-set!} 也是如此。此外， \code{vectorof-set!} 可能会出现在赋值语句中，并作为单独的语句出现，所以要确保在此传递中处理这两种情况。

最后， \code{any-vectorof-length} 的指令应该类似于 \code{vectorof-length} 的指令，除了必须首先将数组投射到 $3$ 位标记中

\begin{exercise}\normalfont

通过扩展 \LangLoop{} 的编译器来实现 \LangArray{} 语言的编译器。在6个新程序上测试编译器，包括图~\ref{fig:inner-product} 中的程序和一个将两个矩阵相乘的程序。请注意，矩阵是二维数组，但通过排列数组中的每一行，可以将它们编码为一维数组。
  
\end{exercise}

% Further Reading: dataflow analysis

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{渐进的打字}
\label{ch:Rgrad}
\index{gradual typing}

这一章研究一种语言， \LangGrad{} ，程序员可以在程序的不同部分在静态类型检查和动态类型检查之间进行选择，从而将静态类型的 \LangLoop{} 语言和动态类型的 \LangDyn{} 混合在一起。有几种方法可以混合静态和动态类型，包括多语言集成~\citep{Tobin-Hochstadt:2006fk,Matthews:2007zr} 和混合类型检查~\citep{Flanagan:2006mn,Gronski:2006uq} 。在本章中，将重点关注 \emph{渐进式类型}\index{gradual typing} ，在这种类型中，程序员通过在参数和变量上添加或删除类型注释来控制静态和动态检查的数量~\citep{Anderson:2002kd,Siek:2006bh}。
%
 \LangGrad{} 的具体语法定义在图~\ref{fig:Rgrad-concrete-syntax} 中，其抽象语法定义在图~\ref{fig:Rgrad-syntax} 中。
\LangLoop{} 和 \LangGrad{} 之间的主要语法区别是附加的 \itm{param} 和 \itm{ret}
非终结符，使类型注释成为可选的。返回类型在抽象语法中不是可选的;当返回类型没有在具体语法中指定时，解析器将填充
\code{Any}。

\begin{figure}[tp]
\centering
\fbox{
  \begin{minipage}{0.96\textwidth}
    \small
\[
\begin{array}{lcl}
  \itm{param} &::=& \Var \mid \LS\Var \key{:} \Type\RS \\
  \itm{ret} &::=& \epsilon \mid \key{:} \Type \\
  \Exp &::=& \gray{ \Int \mid \CREAD{} \mid \CNEG{\Exp}
     \mid \CADD{\Exp}{\Exp} \mid \CSUB{\Exp}{\Exp} }  \\
    &\mid&  \gray{ \Var \mid \CLET{\Var}{\Exp}{\Exp} }\\
    &\mid& \gray{\key{\#t} \mid \key{\#f} 
     \mid (\key{and}\;\Exp\;\Exp) 
     \mid (\key{or}\;\Exp\;\Exp) 
     \mid (\key{not}\;\Exp) } \\
    &\mid& \gray{ (\key{eq?}\;\Exp\;\Exp) \mid \CIF{\Exp}{\Exp}{\Exp} } \\
    &\mid& \gray{ (\key{vector}\;\Exp\ldots) \mid
          (\key{vector-ref}\;\Exp\;\Int)} \\
    &\mid& \gray{(\key{vector-set!}\;\Exp\;\Int\;\Exp)\mid (\key{void})
    \mid (\Exp \; \Exp\ldots) } \\
    &\mid& \gray{ \LP \key{procedure-arity}~\Exp\RP }
    \mid \CGLAMBDA{\LP\itm{param}\ldots\RP}{\itm{ret}}{\Exp} \\
  &\mid& \gray{ \CSETBANG{\Var}{\Exp}
  \mid \CBEGIN{\Exp\ldots}{\Exp}
  \mid \CWHILE{\Exp}{\Exp} } \\
  \Def &::=& \CGDEF{\Var}{\itm{param}\ldots}{\itm{ret}}{\Exp} \\
  \LangGrad{} &::=& \gray{\Def\ldots \; \Exp}
\end{array}
\]
\end{minipage}
}
\caption{ \LangGrad{} 的具体语法，扩展 \LangLoop{} (图~\ref{fig:Rwhile-concrete-syntax})。}
\label{fig:Rgrad-concrete-syntax}
\end{figure}

\begin{figure}[tp]
\centering
\fbox{
  \begin{minipage}{0.96\textwidth}
    \small
\[
\begin{array}{lcl}
  \itm{param} &::=& \Var \mid \LS\Var \key{:} \Type\RS \\
  \Exp &::=& \gray{ \INT{\Int} \VAR{\Var} \mid \LET{\Var}{\Exp}{\Exp} } \\
       &\mid& \gray{ \PRIM{\itm{op}}{\Exp\ldots} }\\
     &\mid& \gray{ \BOOL{\itm{bool}}
      \mid \IF{\Exp}{\Exp}{\Exp} } \\
     &\mid& \gray{ \VOID{} \mid \LP\key{HasType}~\Exp~\Type \RP 
     \mid \APPLY{\Exp}{\Exp\ldots} }\\
  &\mid& \LAMBDA{\LP\itm{param}\ldots\RP}{\Type}{\Exp} \\
  &\mid& \gray{ \SETBANG{\Var}{\Exp} \mid \BEGIN{\LP\Exp\ldots\RP}{\Exp} } \\
  &\mid& \gray{ \WHILE{\Exp}{\Exp} } \\
 \Def &::=& \FUNDEF{\Var}{\LP\itm{param}\ldots\RP}{\Type}{\code{'()}}{\Exp} \\
  \LangGrad{} &::=& \gray{ \PROGRAMDEFSEXP{\code{'()}}{\LP\Def\ldots\RP}{\Exp} }
\end{array}
\]
\end{minipage}
}
\caption{ \LangGrad{} 的抽象语法，扩展 \LangLoop{} (图~\ref{fig:Rwhile-syntax})。}
\label{fig:Rgrad-syntax}
\end{figure}



 \LangGrad{} 的类型检查器和解释器都需要一些有趣的更改来启用渐进类型，在在第~\ref{ch:Rfun} 章的 \code{map-vec} 示例的上下文的下两节中讨论这一点。在图~\ref{fig:gradual-map-vec} 中，修改 \code{map-vec} 示例，省略 \code{add1} 函数的类型注释。

\begin{figure}[btp]
% gradual_test_9.rkt
\begin{lstlisting}
(define (map-vec [f : (Integer -> Integer)]
                   [v : (Vector Integer Integer)])
                   : (Vector Integer Integer)
  (vector (f (vector-ref v 0)) (f (vector-ref v 1))))

(define (add1 x) (+ x 1))

(vector-ref (map-vec add1 (vector 0 41)) 1)
\end{lstlisting}
\caption{ \code{map-vec} 示例的部分类型版本。}
\label{fig:gradual-map-vec}
\end{figure}

\section{类型检查 \LangGrad{} 、强制转换和 \LangCast{}}
\label{sec:gradual-type-check}

 \LangGrad{} 的类型检查器使用 \code{Any} 类型来缺少参数和返回类型。例如，图~\ref{fig:gradual-map-vec} 中
\code{add1} 的 \code{x} 参数的类型为
\code{Any} ，而 \code{add1} 的返回类型为 \code{Any} 。接下来考虑
\code{add1} 中的 \code{+} 运算符。它希望两个参数都具有 \code{Integer} 类型，但它的第一个参数 \code{x}
具有 \code{Any} 类型。在逐渐类型语言中，只要类型 \emph{一致} ，这种差异是允许的，也就是说，除了存在 \code{Any} 类型的地方，它们是相等的。
\code{Any} 类型与其他所有类型一致。
图~\ref{fig:consistent} 定义 \code{consistent?} 谓词。

\begin{figure}[tbp]
\begin{lstlisting}
(define/public (consistent? t1 t2)
  (match* (t1 t2)
    [('Integer 'Integer) #t]
    [('Boolean 'Boolean) #t]
    [('Void 'Void) #t]
    [('Any t2) #t]
    [(t1 'Any) #t]
    [(`(Vector ,ts1 ...) `(Vector ,ts2 ...))
     (for/and ([t1 ts1] [t2 ts2]) (consistent? t1 t2))]
    [(`(,ts1 ... -> ,rt1) `(,ts2 ... -> ,rt2))
     (and (for/and ([t1 ts1] [t2 ts2]) (consistent? t1 t2))
          (consistent? rt1 rt2))]
    [(other wise) #f]))
\end{lstlisting}
\caption{类型上的一致性谓词。}
\label{fig:consistent}
\end{figure}

返回到图~\ref{fig:gradual-map-vec} 中的 \code{map-vec} 示例， \code{add1} 函数具有类型
\code{(Any -> Any)} ，但 \code{map-vec} 的参数 \code{f} 具有类型
\code{(Integer -> Integer)} 。 \LangGrad{} 的类型检查器允许这样做，因为这两种类型是一致的。特别地， \code{->} 等于 \code{->} ，因为 \code{Any} 与 \code{Integer} 一致。

接下来考虑一个带有错误的程序，例如将
\code{map-vec} 应用于有时返回布尔值的函数，如图~\ref{fig:map-vec-maybe-add1} 所示。
\LangGrad{} 的类型检查器接受此程序，因为 \code{maybe-add1} 的类型与 \code{map-vec} 的参数 \code{f}的类型一致，即 \code{(Any -> Any)} 与 \code{(Integer ->
  Integer)} 一致。有人可能会说，渐进式类型检查器是乐观的，因为它接受可能执行时没有运行时类型错误的程序。
%
不幸的是，当 \code{maybe-add1} 函数返回 \code{\#t} 时，使用输入 \code{1} 运行这个程序将触发一个错误。 \LangGrad{} 在运行时执行检查以确保静态类型的完整性，例如 \code{map-vec} 的参数
\code{f} 上的 \code{(Integer -> Integer)} 注释。此运行时检查由类型检查器插入的新 \code{Cast} 表单执行。因此，类型检查器的输出是 \LangCast{} 语言中的一个程序，它将 \code{Cast} 添加到 \LangLoop{} 中，如图~\ref{fig:Rgrad-prime-syntax} 所示。

\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.96\textwidth}
\small
\[
\begin{array}{lcl}
  \Exp &::=& \ldots \mid \CAST{\Exp}{\Type}{\Type} \\
  \LangCast{} &::=& \gray{ \PROGRAMDEFSEXP{\code{'()}}{\LP\Def\ldots\RP}{\Exp} }
\end{array}
\]
\end{minipage}
}
\caption{ \LangCast{} 的抽象语法，扩展 \LangLoop{} (图~\ref{fig:Rwhile-syntax})。}
\label{fig:Rgrad-prime-syntax}
\end{figure}


\begin{figure}[tbp]
\begin{lstlisting}
(define (map-vec [f : (Integer -> Integer)]
                   [v : (Vector Integer Integer)])
                   : (Vector Integer Integer)
  (vector (f (vector-ref v 0)) (f (vector-ref v 1))))
(define (add1 x) (+ x 1))
(define (true) #t)
(define (maybe-add1 x) (if (eq? 0 (read)) (add1 x) (true)))

(vector-ref (map-vec maybe-add1 (vector 0 41)) 0)
\end{lstlisting}
\caption{一个带有错误的 \code{map-vec} 示例的变体。}
\label{fig:map-vec-maybe-add1}
\end{figure}

图~\ref{fig:map-vec-cast} 显示
\code{map-vec} 和 \code{maybe-add1} 的类型检查器的输出。其思想是，每当类型检查器看到两个类型一致但不相等时，就插入 \code{Cast} 。在 \code{add1} 函数中， \code{x} 被转换为 \code{Integer} ，而 \code{+} 的结果被转换为
\code{Any} 。在对 \code{map-vec} 的调用中， \code{add1} 参数从 \code{(Any -> Any)} 转换为 \code{(Integer -> Integer)} 。

\begin{figure}[btp]
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
(define (map-vec [f : (Integer -> Integer)] [v : (Vector Integer Integer)])
                   : (Vector Integer Integer)
  (vector (f (vector-ref v 0)) (f (vector-ref v 1))))
(define (add1 [x : Any]) : Any
  (cast (+ (cast x Any Integer) 1) Integer Any))
(define (true) : Any (cast #t Boolean Any))
(define (maybe-add1 [x : Any]) : Any
  (if (eq? 0 (read)) (add1 x) (true)))

(vector-ref (map-vec (cast maybe-add1 (Any -> Any) (Integer -> Integer))
                       (vector 0 41)) 0)
\end{lstlisting}
\caption{类型检查 \code{map-vec} 和 \code{maybe-add1} 的输出。}
\label{fig:map-vec-cast}
\end{figure}


 \LangGrad{} 的类型检查器在图~\ref{fig:type-check-Rgradual-1} 、 \ref{fig:type-check-Rgradual-2} 和 \ref{fig:type-check-Rgradual-3} 中定义。


\begin{figure}[tbp]
\begin{lstlisting}
(define type-check-gradual-class
  (class type-check-Rwhile-class
    (super-new)
    (inherit operator-types type-predicates)

    (define/override (type-check-exp env)
      (lambda (e)
	(define recur (type-check-exp env))
	(match e
	  [(Prim 'vector-length (list e1))
           (define-values (e1^ t) (recur e1))
	   (match t
             [`(Vector ,ts ...)
              (values (Prim 'vector-length (list e1^)) 'Integer)]
             ['Any (values (Prim 'any-vector-length (list e1^)) 'Integer)])]
	  [(Prim 'vector-ref (list e1 e2))
           (define-values (e1^ t1) (recur e1))
           (define-values (e2^ t2) (recur e2))
           (check-consistent? t2 'Integer e)
	   (match t1
	     [`(Vector ,ts ...)
              (match e2^
                [(Int i)
                 (unless (and (0 . <= . i) (i . < . (length ts)))
                   (error 'type-check "invalid index ~a in ~a" i e))
                 (values (Prim 'vector-ref (list e1^ (Int i))) (list-ref ts i))]
                [else (define e1^^ (make-cast e1^ t1 'Any))
                      (define e2^^ (make-cast e2^ t2 'Integer))
                      (values (Prim 'any-vector-ref (list e1^^ e2^^)) 'Any)])]
             ['Any
              (define e2^^ (make-cast e2^ t2 'Integer))
              (values (Prim 'any-vector-ref (list e1^ e2^^)) 'Any)]
             [else (error 'type-check "expected vector not ~a\nin ~v" t1 e)])]
	  [(Prim 'vector-set! (list e1 e2 e3) )
           (define-values (e1^ t1) (recur e1))
           (define-values (e2^ t2) (recur e2))
           (define-values (e3^ t3) (recur e3))
           (check-consistent? t2 'Integer e)
\end{lstlisting}
\end{figure}
\begin{figure}[tbp]
\begin{lstlisting}           
	   (match t1
	     [`(Vector ,ts ...)
              (match e2^
                [(Int i)
                 (unless (and (0 . <= . i) (i . < . (length ts)))
                   (error 'type-check "invalid index ~a in ~a" i e))
                 (check-consistent? (list-ref ts i) t3 e)
                 (define e3^^ (make-cast e3^ t3 (list-ref ts i)))
                 (values (Prim 'vector-set! (list e1^ (Int i) e3^^)) 'Void)]
                [else
                 (define e1^^ (make-cast e1^ t1 'Any))
                 (define e2^^ (make-cast e2^ t2 'Integer))
                 (define e3^^ (make-cast e3^ t3 'Any))
                 (values (Prim 'any-vector-set! (list e1^^ e2^^ e3^^)) 'Void)])]
             ['Any
              (define e2^^ (make-cast e2^ t2 'Integer))
              (define e3^^ (make-cast e3^ t3 'Any))
              (values (Prim 'any-vector-set! (list e1^ e2^^ e3^^)) 'Void)]
	     [else (error 'type-check "expected vector not ~a\nin ~v" t1 e)])]
\end{lstlisting}
\caption{ \LangGrad{} 语言的类型检查器，第1部分。}
\label{fig:type-check-Rgradual-1}
\end{figure}

\begin{figure}[tbp]
\begin{lstlisting}
          [(Prim 'eq? (list e1 e2))
           (define-values (e1^ t1) (recur e1))
           (define-values (e2^ t2) (recur e2))
           (check-consistent? t1 t2 e)
           (define T (meet t1 t2))
           (values (Prim 'eq? (list (make-cast e1^ t1 T) (make-cast e2^ t2 T)))
                   'Boolean)]
          [(Prim 'not (list e1))
           (define-values (e1^ t1) (recur e1))
           (match t1
             ['Any
              (recur (If (Prim 'eq? (list e1 (Inject (Bool #f) 'Boolean)))
                         (Bool #t) (Bool #f)))]
             [else
              (define-values (t-ret new-es^)
                (type-check-op 'not (list t1) (list e1^) e))
              (values (Prim 'not new-es^) t-ret)])]
          [(Prim 'and (list e1 e2))
           (recur (If e1 e2 (Bool #f)))]
          [(Prim 'or (list e1 e2))
           (define tmp (gensym 'tmp))
           (recur (Let tmp e1 (If (Var tmp) (Var tmp) e2)))]
	  [(Prim op es)
           #:when (not (set-member? explicit-prim-ops op))
           (define-values (new-es ts)
             (for/lists (exprs types) ([e es])
               (recur e)))
           (define-values (t-ret new-es^) (type-check-op op ts new-es e))
           (values (Prim op new-es^) t-ret)]
          [(If e1 e2 e3)
           (define-values (e1^ T1) (recur e1))
\end{lstlisting}
\end{figure}
\begin{figure}[tbp]
\begin{lstlisting}           
	   (define-values (e2^ T2) (recur e2))
	   (define-values (e3^ T3) (recur e3))
	   (check-consistent? T2 T3 e)
           (match T1
             ['Boolean
              (define Tif (join T2 T3))
              (values (If e1^ (make-cast e2^ T2 Tif)
                          (make-cast e3^ T3 Tif)) Tif)]
             ['Any
              (define Tif (meet T2 T3))
              (values (If (Prim 'eq? (list e1^ (Inject (Bool #f) 'Boolean)))
                          (make-cast e3^ T3 Tif) (make-cast e2^ T2 Tif))
                      Tif)]
             [else (error 'type-check "expected Boolean not ~a\nin ~v" T1 e)])]
          [(HasType e1 T)
           (define-values (e1^ T1) (recur e1))
           (check-consistent? T1 T)
           (values (make-cast e1^ T1 T) T)]          
          [(SetBang x e1)
           (define-values (e1^ T1) (recur e1))
           (define varT (dict-ref env x))
           (check-consistent? T1 varT e)
           (values (SetBang x (make-cast e1^ T1 varT)) 'Void)]
          [(WhileLoop e1 e2)
           (define-values (e1^ T1) (recur e1))
           (check-consistent? T1 'Boolean e)
           (define-values (e2^ T2) ((type-check-exp env) e2))
           (values (WhileLoop (make-cast e1^ T1 'Boolean) e2^) 'Void)]
\end{lstlisting}
\caption{ \LangGrad{} 语言的类型检查器，第2部分。}
\label{fig:type-check-Rgradual-2}
\end{figure}


\begin{figure}[tbp]
\begin{lstlisting}
	  [(Apply e1 e2s)
	   (define-values (e1^ T1) (recur e1))
	   (define-values (e2s^ T2s) (for/lists (e* ty*) ([e2 e2s]) (recur e2)))
	   (match T1
	     [`(,T1ps ... -> ,T1rt)
              (for ([T2 T2s] [Tp T1ps])
                (check-consistent? T2 Tp e))
              (define e2s^^ (for/list ([e2 e2s^] [src T2s] [tgt T1ps])
                              (make-cast e2 src tgt)))
	      (values (Apply e1^ e2s^^) T1rt)]
             [`Any
              (define e1^^ (make-cast e1^ 'Any
                                      `(,@(for/list ([e e2s]) 'Any) -> Any)))
              (define e2s^^ (for/list ([e2 e2s^] [src T2s])
                              (make-cast e2 src 'Any)))
              (values (Apply e1^^ e2s^^) 'Any)]
	     [else (error 'type-check "expected function not ~a\nin ~v" T1 e)])]
          [(Lambda params Tr e1)
           (define-values (xs Ts) (for/lists (l1 l2) ([p params])
                                    (match p
                                      [`[,x : ,T] (values x T)]
                                      [(? symbol? x) (values x 'Any)])))
           (define-values (e1^ T1) 
             ((type-check-exp (append (map cons xs Ts) env)) e1))
           (check-consistent? Tr T1 e)
           (values (Lambda (for/list ([x xs] [T Ts]) `[,x : ,T]) Tr
                           (make-cast e1^ T1 Tr)) `(,@Ts -> ,Tr))]
          [else  ((super type-check-exp env) e)]
          )))
\end{lstlisting}
\caption{ \LangGrad{} 语言的类型检查器，第3部分。}
\label{fig:type-check-Rgradual-3}
\end{figure}


\begin{figure}[tbp]
\begin{lstlisting}
    (define/public (join t1 t2)
      (match* (t1 t2)
        [('Integer 'Integer) 'Integer]
        [('Boolean 'Boolean) 'Boolean]
        [('Void  'Void) 'Void]
        [('Any t2) t2]
        [(t1 'Any) t1]
        [(`(Vector ,ts1 ...) `(Vector ,ts2 ...))
         `(Vector ,@(for/list ([t1 ts1] [t2 ts2]) (join t1 t2)))]
        [(`(,ts1 ... -> ,rt1) `(,ts2 ... -> ,rt2))
         `(,@(for/list ([t1 ts1] [t2 ts2]) (join t1 t2))
           -> ,(join rt1 rt2))]))

    (define/public (meet t1 t2)
      (match* (t1 t2)
        [('Integer 'Integer) 'Integer]
        [('Boolean  'Boolean) 'Boolean]
        [('Void 'Void) 'Void]
        [('Any t2) 'Any]
        [(t1 'Any) 'Any]
        [(`(Vector ,ts1 ...) `(Vector ,ts2 ...))
         `(Vector ,@(for/list ([t1 ts1] [t2 ts2]) (meet t1 t2)))]
        [(`(,ts1 ... -> ,rt1) `(,ts2 ... -> ,rt2))
         `(,@(for/list ([t1 ts1] [t2 ts2]) (meet t1 t2))
           -> ,(meet rt1 rt2))]))

    (define/public (make-cast e src tgt)
      (cond [(equal? src tgt) e] [else (Cast e src tgt)]))

    (define/public (check-consistent? t1 t2 e)
      (unless (consistent? t1 t2)
        (error 'type-check "~a is inconsistent with ~a\nin ~v" t1 t2 e)))
\end{lstlisting}
\end{figure}
\begin{figure}[tbp]
\begin{lstlisting}
    (define/override (type-check-op op arg-types args e)
      (match (dict-ref (operator-types) op)
        [`(,param-types . ,return-type)
         (for ([at arg-types] [pt param-types]) 
           (check-consistent? at pt e))
         (values return-type
                 (for/list ([e args] [s arg-types] [t param-types])
                   (make-cast e s t)))]
        [else (error 'type-check-op "unrecognized ~a" op)]))

    (define explicit-prim-ops
      (set-union
       (type-predicates)
       (set 'procedure-arity 'eq?
            'vector 'vector-length 'vector-ref 'vector-set!
            'any-vector-length 'any-vector-ref 'any-vector-set!)))

    (define/override (fun-def-type d)
      (match d
	[(Def f params rt info body)
         (define ps
           (for/list ([p params])
             (match p
               [`[,x : ,T] T]
               [(? symbol?) 'Any]
               [else (error 'fun-def-type "unmatched parameter ~a" p)])))
	 `(,@ps -> ,rt)]
	[else (error 'fun-def-type "ill-formed function definition in ~a" d)]))
\end{lstlisting}
\caption{用于类型检查 \LangGrad{} 的辅助函数}
\label{fig:type-check-Rgradual-aux}
\end{figure}

\clearpage

\section{解释 \LangCast{}}
\label{sec:interp-casts}

一阶强制转换的运行时行为很简单，即涉及简单类型(如 \code{Integer} 和
\code{Boolean} )的强制转换。例如，从 \code{Integer} 强制转换为 \code{Any}
，可以用 \LangAny{} 的 \code{Inject} 操作符完成，它将整型放入一个带标记的值(图~\ref{fig:interp-Rany})。 类似地，从 \code{Any} 到 \code{Integer} 的强制转换是通过 \code{Project} 操作符完成的，也就是说，通过检查值的标记，检索底层的整数，或者在标记不是用于整数的时候发出错误信号(图~\ref{fig:apply-project})。
%
对于更高阶的类型转换，也就是涉及函数或向量类型的类型转换，事情会变得更有趣。

考虑将函数 \code{maybe-add1} 从 \code{(Any ->
  Any)} 强制转换为 \code{(Integer -> Integer)} 。当函数在运行时执行此强制转换时，通常无法知道该函数是否总是返回整数。\footnote{预测函数的返回值相当于停止问题，这是无法确定的。}  因此， \LangCast{} 解释器将延迟对转换的检查，直到应用了函数。这是通过将 \code{maybe-add1} 包装在一个新函数中来实现的，该函数将其参数从 \code{Integer} '转换为 \code{Any} ，应用 \code{maybe-add1} ，然后将返回值从 \code{Any} 转换为 \code{Integer} 。

把注意力转到涉及vector类型的强制转换上，考虑图~\ref{fig:map-vec-bang} 中的例子，它定义 \code{map-vec} 的部分类型版本，其形参 \code{v} 具有类型 \code{(Vector Any Any)} ，并在适当位置更新 \code{v} ，而不是返回一个新的vector。因此将这个函数命名为 \code{map-vec!} 。将 \code{map-vec!} 应用于一个整数向量，因此类型检查器插入从 \code{(Vector Integer Integer)}
到 \code{(Vector Any Any)} 的强制转换。 \LangCast{} t解释器在vector类型之间进行类型转换的一种简单方法是构建一个新的向量，其元素是将每个原始元素转换为适当的目标类型的结果。然而，这种方法仅对不可变向量有效;向量是可变的。在图~\ref{fig:map-vec-bang} 的例子中，如果强制转换创建一个新的向量，那么 \code{map-vec!} 内部的更新将发生在新的向量上，而不是原来的向量上。

\begin{figure}[tbp]
  % gradual_test_11.rkt
\begin{lstlisting}
(define (map-vec! [f : (Any -> Any)]
                  [v : (Vector Any Any)]) : Void
  (begin
    (vector-set! v 0 (f (vector-ref v 0)))
    (vector-set! v 1 (f (vector-ref v 1)))))

(define (add1 x) (+ x 1))

(let ([v (vector 0 41)])
  (begin (map-vec! add1 v) (vector-ref v 1)))
\end{lstlisting}
\caption{一个涉及向量强制转换的例子。}
\label{fig:map-vec-bang}
\end{figure}

相反，解释器需要创建一种新的值，一个
\emph{向量代理} ，它拦截每一个vector操作。在读取时，代理读取底层向量，然后对结果值应用强制转换。在写操作中，代理对参数值进行强制转换，然后对基础向量执行写操作。对于 \code{map-vec!} 中的第一个 \code{(vector-ref v 0)} ，代理将 \code{0} 从 \code{Integer} 转换为 \code{Any} 。对于第一个
\code{vector-set!} ，代理将标记 \code{1} 从 \code{Any} 转换为 \code{Integer} 。

需要考虑的最后一类类型转换是 \code{Any} 类型与函数类型或向量类型之间的类型转换。图~\ref{fig:map-vec-any} 显示 \code{map-vec!}
的一个变体，其中参数 \code{v} 没有类型注释，因此给它指定类型 \code{Any} 。在对 \code{map-vec!} 的调用中，vector具有类型 \code{(Vector Integer Integer)} ，因此类型检查器将 \code{(Vector Integer Integer)} 强制转换到 \code{Any} 。第一个想法是使用 \code{Inject} ，但这不起作用，因为
\code{(Vector Integer Integer)} 不是一个平面类型。相反，必须先强制转换为 \code{(Vector Any Any)} (它是平面的)，然后注入到 \code{Any} 。

\begin{figure}[tbp]
\begin{lstlisting}
(define (map-vec! [f : (Any -> Any)] v) : Void
  (begin
    (vector-set! v 0 (f (vector-ref v 0)))
    (vector-set! v 1 (f (vector-ref v 1)))))

(define (add1 x) (+ x 1))

(let ([v (vector 0 41)])
  (begin (map-vec! add1 v) (vector-ref v 1)))
\end{lstlisting}
\caption{将向量强制转换为 \code{Any} 。}
\label{fig:map-vec-any}
\end{figure}

 \LangCast{} 解释器使用一个名为
\code{apply-cast} 的辅助函数将一个值从源类型强制转换为目标类型，如图~\ref{fig:apply-cast} 所示。发现它处理在本节中讨论的所有类型的强制转换。

\begin{figure}[tbp]
\begin{lstlisting}
(define/public (apply-cast v s t)
  (match* (s t)
    [(t1 t2) #:when (equal? t1 t2) v]
    [('Any t2) 
     (match t2
       [`(,ts ... -> ,rt)
        (define any->any `(,@(for/list ([t ts]) 'Any) -> Any))
        (define v^ (apply-project v any->any))
        (apply-cast v^ any->any `(,@ts -> ,rt))]
       [`(Vector ,ts ...)
        (define vec-any `(Vector ,@(for/list ([t ts]) 'Any)))
        (define v^ (apply-project v vec-any))
        (apply-cast v^ vec-any `(Vector ,@ts))]
       [else (apply-project v t2)])]
    [(t1 'Any) 
     (match t1
       [`(,ts ... -> ,rt)
        (define any->any `(,@(for/list ([t ts]) 'Any) -> Any))
        (define v^ (apply-cast v `(,@ts -> ,rt) any->any))
        (apply-inject v^ (any-tag any->any))]
       [`(Vector ,ts ...)
        (define vec-any `(Vector ,@(for/list ([t ts]) 'Any)))
        (define v^ (apply-cast v `(Vector ,@ts) vec-any))
        (apply-inject v^ (any-tag vec-any))]
       [else (apply-inject v (any-tag t1))])]
\end{lstlisting}
\end{figure}
\begin{figure}[tbp]
\begin{lstlisting}       
    [(`(Vector ,ts1 ...) `(Vector ,ts2 ...))
     (define x (gensym 'x))
     (define cast-reads (for/list ([t1 ts1] [t2 ts2])
                          `(function (,x) ,(Cast (Var x) t1 t2) ())))
     (define cast-writes
       (for/list ([t1 ts1] [t2 ts2])
         `(function (,x) ,(Cast (Var x) t2 t1) ())))
     `(vector-proxy ,(vector v (apply vector cast-reads)
                             (apply vector cast-writes)))]
    [(`(,ts1 ... -> ,rt1) `(,ts2 ... -> ,rt2))
     (define xs (for/list ([t2 ts2]) (gensym 'x)))
     `(function ,xs ,(Cast
                      (Apply (Value v)
                             (for/list ([x xs][t1 ts1][t2 ts2])
                               (Cast (Var x) t2 t1)))
                      rt1 rt2) ())]
    ))
\end{lstlisting}
\caption{ \code{apply-cast} 辅助方法。}
  \label{fig:apply-cast}
\end{figure}

 \LangCast{} 的解释器定义在图~\ref{fig:interp-Rcast} 中，其中 \code{Cast}
被分派到 \code{apply-cast} 。为了处理向量代理的添加，使用图~\ref{fig:guarded-vector} 中的函数更新 \code{interp-op} 中的向量原语。

\begin{figure}[tbp]
\begin{lstlisting}
(define interp-Rcast-class
  (class interp-Rwhile-class
    (super-new)
    (inherit apply-fun apply-inject apply-project)

    (define/override (interp-op op)
      (match op
        ['vector-length guarded-vector-length]
        ['vector-ref guarded-vector-ref]
        ['vector-set! guarded-vector-set!]
        ['any-vector-ref (lambda (v i)
                           (match v [`(tagged ,v^ ,tg)
                                     (guarded-vector-ref v^ i)]))]
        ['any-vector-set! (lambda (v i a)
                            (match v [`(tagged ,v^ ,tg)
                                      (guarded-vector-set! v^ i a)]))]
        ['any-vector-length (lambda (v)
                              (match v [`(tagged ,v^ ,tg)
                                        (guarded-vector-length v^)]))]
        [else (super interp-op op)]
        ))

    (define/override ((interp-exp env) e)
      (define (recur e) ((interp-exp env) e))
      (match e
        [(Value v) v]
        [(Cast e src tgt) (apply-cast (recur e) src tgt)]
        [else ((super interp-exp env) e)]))
    ))

(define (interp-Rcast p)
  (send (new interp-Rcast-class) interp-program p))
\end{lstlisting}
\caption{ \LangCast{} 的解释器。}
  \label{fig:interp-Rcast}
\end{figure}


\begin{figure}[tbp]
\begin{lstlisting}
    (define (guarded-vector-ref vec i)
      (match vec
        [`(vector-proxy ,proxy)
         (define val (guarded-vector-ref (vector-ref proxy 0) i))
         (define rd (vector-ref (vector-ref proxy 1) i))
         (apply-fun rd (list val) 'guarded-vector-ref)]
        [else (vector-ref vec i)]))
        
    (define (guarded-vector-set! vec i arg)
      (match vec
        [`(vector-proxy ,proxy)
         (define wr (vector-ref (vector-ref proxy 2) i))
         (define arg^ (apply-fun wr (list arg) 'guarded-vector-set!))
         (guarded-vector-set! (vector-ref proxy 0) i arg^)]
        [else (vector-set! vec i arg)]))
        
    (define (guarded-vector-length vec)
      (match vec
        [`(vector-proxy ,proxy)
         (guarded-vector-length (vector-ref proxy 0))]
        [else (vector-length vec)]))
\end{lstlisting}
\caption{被保护向量辅助函数。}
  \label{fig:guarded-vector}
\end{figure}


\section{低投入}
\label{sec:lower-casts}

x86进程的下一步是 \code{lower-casts}
通道，它将 \LangCast{} 中的cast转换为更低级的
\code{Inject} 和 \code{Project} 操作符，以及一个用于创建矢量代理的新操作符，扩展 \LangLoop{} 语言来创建
\LangProxy{} 。建议创建一个名为
\code{lower-cast} 的辅助函数，它接受一个表达式(在 \LangCast{} 中)、一个源类型和一个目标类型，并将其转换为 \LangProxy{} 中的表达式，该表达式具有与在解释器中将表达式从源类型转换为目标类型相同的行为。

 \code{lower-cast} 函数的代码结构类似于 \LangCast{} 解释器中使用的 \code{apply-cast} 函数(图~\ref{fig:apply-cast}) ，因为它必须处理与
\code{apply-cast} 相同的情况，并且它需要模仿
\code{apply-cast} 的行为。最有趣的情况是两种向量类型之间和两种函数类型之间的强制转换。

如第~\ref{sec:interp-casts} 节所述，将一种向量类型强制转换为另一种向量类型是通过创建一个代理来拦截对底层向量的操作来完成的。这里我们使用 \code{vector-proxy} 原语操作显式创建代理。它有三个参数，第一个是向量的表达式，第二个是函数的向量，用于对从向量中读取的元素进行类型转换，第三个是函数的向量，用于对写入向量的元素进行类型转换。
可以使用 \code{Lambda} 创建函数。此外，正如在下一节中看到的，需要将这些向量与用户创建的向量区分开来，因此，建议使用一个名为 \code{raw-vector} 而不是 \code{vector} 的新原始运算符来创建函数的这些向量。图~\ref{fig:map-vec-bang-lower-cast} 显示 \code{lower-casts} 对图~\ref{fig:map-vec-bang} 中的示例的输出，该示例涉及将一个整数向量转换为 \code{Any} 向量。

\begin{figure}[tbp]
\begin{lstlisting}
(define (map-vec! [f : (Any -> Any)] [v : (Vector Any Any)]) : Void
   (begin 
      (vector-set! v 0 (f (vector-ref v 0)))
      (vector-set! v 1 (f (vector-ref v 1)))))
  
(define (add1 [x : Any]) : Any
   (inject (+ (project x Integer) 1) Integer))

(let ([v (vector 0 41)])
   (begin 
      (map-vec! add1 (vector-proxy v
                        (raw-vector (lambda: ([x9 : Integer]) : Any
                                       (inject x9 Integer))
                                     (lambda: ([x9 : Integer]) : Any
                                       (inject x9 Integer)))
                        (raw-vector (lambda: ([x9 : Any]) : Integer
                                       (project x9 Integer))
                                    (lambda: ([x9 : Any]) : Integer
                                       (project x9 Integer)))))
      (vector-ref v 1)))
\end{lstlisting}
\caption{图~\ref{fig:map-vec-bang} 中的示例的 \code{lower-casts} 的输出。}
\label{fig:map-vec-bang-lower-cast}
\end{figure}

通过生成参数和返回类型与目标函数类型匹配的 \code{Lambda} 来完成从一个函数类型到另一个函数类型的强制转换。 \code{Lambda} 的函数体应该将形参从目标类型转换为源类型(是的，
backwards! 函数在形参中是逆变的\index{contravariant} )，然后调用底层函数，最后将源返回类型的结果转换为目标返回类型。
图~\ref{fig:map-vec-lower-cast} 在图~\ref{fig:gradual-map-vec} 的 \code{map-vec} 示例中显示
\code{lower-casts} 通道的输出。注意，对 \code{map-vec} 调用中的 \code{add1} 参数被包装在 \code{lambda} 中。

\begin{figure}[tbp]
\begin{lstlisting}
(define (map-vec [f : (Integer -> Integer)]
                   [v : (Vector Integer Integer)])
                   : (Vector Integer Integer)
  (vector (f (vector-ref v 0)) (f (vector-ref v 1))))

(define (add1 [x : Any]) : Any
  (inject (+ (project x Integer) 1) Integer))

(vector-ref (map-vec (lambda: ([x9 : Integer]) : Integer
                        (project (add1 (inject x9 Integer)) Integer))
                      (vector 0 41)) 1)
\end{lstlisting}
\caption{在图~\ref{fig:gradual-map-vec} 的例子中 \code{lower-casts} 。}
\label{fig:map-vec-lower-cast}
\end{figure}


\section{区分代理}
\label{sec:differentiate-proxies}

到目前为止，区分向量和向量代理的工作一直是解释器的工作。例如， \LangCast{}
的解释器使用 \code{guarded-vector-ref} 函数实现 \code{vector-ref} 
，如图~\ref{fig:guarded-vector} 所示。在
\code{differentiate-proxies} 通道中，将此责任转移到生成的代码。

首先设计输出语言 $R^p_8$ 。在
\LangGrad{} 中，我们对实向量和向量代理都使用类型 \code{Vector} 。在 $R^p_8$ 中，返回 \code{Vector} 类型的原始含义，作为实向量的类型，并且引入一种新的类型， \code{PVector} ，它的值可以是实向量或向量代理。这个新类型附带一套新的原语操作，用于创建和使用 \code{PVector} 类型的值。不需要引入新的类型来表示向量代理。代理由包含以下三种内容的向量表示:1) 底层的向量； 2) 一个函数的向量类型，用于对从向量中读取的元素进行类型转换； 3)一个函数的向量，用于对写入向量的值进行强制转换。因此，定义以下矢量代理类型的缩写:
\[
\itm{Proxy} (T\ldots \Rightarrow T'\ldots)
= (\ttm{Vector}~(\ttm{PVector}~ T\ldots) ~R~ W)
  \to (\key{PVector}~ T' \ldots)
\]
当 $R = (\ttm{Vector}~(T\to T') \ldots)$ 和
$W = (\ttm{Vector}~(T'\to T) \ldots)$ 。
%
接下来，将描述每个新的原语操作。

\begin{description}
\item[\code{inject-vector} : (\key{Vector} $T \ldots$) $\to$
  (\key{PVector} $T \ldots$)]\ \\
%
  将一个向量标记为 \code{PVector} 类型的值。
\item[\code{inject-proxy} : $\itm{Proxy}(T\ldots \Rightarrow T'\ldots)$
  $\to$ (\key{PVector} $T' \ldots$)]\ \\
%
  将矢量代理标记为 \code{PVector} 类型的值。
\item[\code{proxy?} : (\key{PVector} $T \ldots$) $\to$
  \code{Boolean}] \ \\
%
  如果值是向量代理则返回true，如果是实向量则返回false。
\item[\code{project-vector} : (\key{PVector} $T \ldots$) $\to$
  (\key{Vector} $T \ldots$)]\ \\
%
  假设输入是一个向量(而不是一个代理)，将返回向量。
  
\item[\code{proxy-vector-length} : (\key{PVector} $T \ldots$)
  $\to$ \code{Boolean}]\ \\
%
  给定一个向量代理，将返回基础向量的长度。
  
\item[\code{proxy-vector-ref} : (\key{PVector} $T \ldots$)
  $\to$ ($i$ : \code{Integer}) $\to$ $T_i$]\ \\
%
  给定一个向量代理，将返回基础向量的第 $i$ 个元素。
  
\item[\code{proxy-vector-set!} : (\key{PVector} $T \ldots$) $\to$ ($i$
  : \code{Integer}) $\to$ $T_i$ $\to$ \key{Void}]\ \\ 给定一个向量代理，将一个值写入基础向量的第 $i$ 个元素。
\end{description}

现在来讨论区分向量和代理的转换。首先，程序中的每个类型注释都必须(递归地)转换为用 \code{PVector} 替换 \code{Vector} 。
接下来，必须在适当的位置插入 \code{PVector} 操作的用法。例如，用一个
\code{inject-vector} 来包装每个向量的创建。
\begin{lstlisting}
(vector |$e_1 \ldots e_n$|)
|$\Rightarrow$|
(inject-vector (vector |$e'_1 \ldots e'_n$|))
\end{lstlisting}
在前一节中介绍的 \code{raw-vector} 操作符没有被注入。
\begin{lstlisting}
(raw-vector |$e_1 \ldots e_n$|)
|$\Rightarrow$|
(vector |$e'_1 \ldots e'_n$|)
\end{lstlisting}

 \code{vector-proxy} 原语的翻译如下。
\begin{lstlisting}
(vector-proxy |$e_1~e_2~e_3$|)
|$\Rightarrow$|
(inject-proxy (vector |$e'_1~e'_2~e'_3$|))
\end{lstlisting}

将向量操作转换为条件表达式，检查值是否为代理，然后将其分派到适当的代理向量操作或常规向量操作。
例如，下面是 \code{vector-ref} 的转换。
\begin{lstlisting}
(vector-ref |$e_1$| |$i$|)
|$\Rightarrow$|
(let ([|$v~e_1$|])
  (if (proxy? |$v$|)
    (proxy-vector-ref |$v$| |$i$|)
    (vector-ref (project-vector |$v$|) |$i$|)
\end{lstlisting}
注意在实向量的情况下，必须在 \code{vector-ref} 之前应用 \code{project-vector} 。

\section{真实成本}
\label{sec:reveal-casts-gradual}

回想一下， \code{reveal-casts} 通道
(第~\ref{sec:reveal-casts-Rany}) 节)负责将
\code{Inject} 和 \code{Project} 降低到较低级别的操作中。特别是， \code{Project} 变成一个检查标记并检索基础值的条件表达式。这里，需要增加 \code{Project} 的翻译，以处理目标类型为 \code{PVector} 的情况。需要使用 \code{proxy-vector-length} 而不是 \code{vector-length} 。
\begin{lstlisting}
(project |$e$| (PVector Any|$_1$| |$\ldots$| Any|$_n$|))
|$\Rightarrow$|
(let |$\itm{tmp}$| |$e'$|
   (if (eq? (tag-of-any |$\itm{tmp}$| 2))
      (let |$\itm{vec}$| (value-of |$\itm{tmp}$| (PVector Any |$\ldots$| Any))
        (if (eq? (proxy-vector-length |$\itm{vec}$|) |$n$|) |$\itm{vec}$| (exit)))
      (exit)))
\end{lstlisting}


\section{关闭转换}
\label{sec:closure-conversion-gradual}

关闭转换通过只需要一个小的调整。需要更新转换类型注释的辅助函数来处理 \code{PVector} 类型。

\section{说明控制}
\label{sec:explicate-control-gradual}

更新 \code{explicate-control} 通道来处理 \code{PVector} 类型上的新基元操作。

\section{选择指令}
\label{sec:select-instructions-gradual}

回想一下， \code{select-instructions} 通道负责将原始操作降低为x86指令。所以需要将新的 \code{PVector} 操作转换为x86。为此，需要回答的第一个问题是如何区分可以驻留在 \code{PVector} 中的两种值(向量和代理)。
只需要一个位来完成这一点，并在每个向量的前面使用64位标记的
$57$ 位(见图~\ref{fig:tuple-rep}) 。到目前为止，这一位已经被设置为 $0$ ，所以对于 \code{inject-vector} ，我们保持这种方式。
\begin{lstlisting}
(Assign |$\itm{lhs}$| (Prim 'inject-vector (list |$e_1$|)))
|$\Rightarrow$|  
movq |$e'_1$|, |$\itm{lhs'}$|
\end{lstlisting}
另一方面， \code{inject-proxy} 将 $57$ 位设为 $1$ 。
\begin{lstlisting}
(Assign |$\itm{lhs}$| (Prim 'inject-proxy (list |$e_1$|)))
|$\Rightarrow$|  
movq |$e'_1$|, %r11
movq |$(1 << 57)$|, %rax
orq 0(%r11), %rax
movq %rax, 0(%r11)
movq %r11, |$\itm{lhs'}$|
\end{lstlisting}

 \code{proxy?} 操作将使用 \code{inject-vector} 和 \code{inject-proxy} 小心翼翼地隐藏起来的信息。它隔离第 $57$ 位，以判断该值是实向量还是代理。
\begin{lstlisting}
(Assign |$\itm{lhs}$| (Prim 'proxy? (list e)))
|$\Rightarrow$|
movq |$e_1'$|, %r11
movq 0(%r11), %rax
sarq $57, %rax
andq $1, %rax
movq %rax, |$\itm{lhs'}$|
\end{lstlisting}

 \code{project-vector} 操作翻译起来很简单，所以把它留给读者。

关于 \code{proxy-vector} 操作，运行时提供实现它们的过程(它们是递归函数!)，所以这里只需要将这些向量操作转换为适当的函数调用。例如，下面是
\code{proxy-vector-ref} 的翻译。
\begin{lstlisting}
(Assign |$\itm{lhs}$| (Prim 'proxy-vector-ref (list |$e_1$| |$e_2$|)))
|$\Rightarrow$|
movq |$e_1'$|, %rdi
movq |$e_2'$|, %rsi
callq proxy_vector_ref
movq %rax, |$\itm{lhs'}$|
\end{lstlisting}

还有另一批向量操作要处理，那些针对
\code{Any} 类型的。回想一下，当\code{Any} 类型的东西上有 \code{vector-ref} 时， \LangGrad{} 类型检查器会生成
\code{any-vector-ref} ， \code{any-vector-set!}  和
\code{any-vector-length} 的情况也类似(图~\ref{fig:type-check-Rgradual-1}) 。在第~\ref{sec:select-Rany} 节中，基于底层值是一个实向量的思想为这些操作选择指令。但是在当前设置中，基础值的类型是
\code{PVector} 。所以 \code{any-vector-ref} 可以被翻译成如下的伪x86。首先从标记值中投影底层值，然后在运行时调用 \code{proxy\_vector\_ref}
过程。
\begin{lstlisting}
(Assign |$\itm{lhs}$| (Prim 'any-vector-ref (list |$e_1$| |$e_2$|)))
movq |$\neg 111$|, %rdi
andq |$e_1'$|, %rdi
movq |$e_2'$|, %rsi
callq proxy_vector_ref
movq %rax, |$\itm{lhs'}$|
\end{lstlisting}
 \code{any-vector-set!} 和 \code{any-vector-length} 运算符可以用类似的方式进行转换。

\begin{exercise}\normalfont
  通过为 \LangLoop{} 扩展和调整编译器，实现一个渐进类型的 \LangGrad{} 语言的编译器。创建10个新的部分类型测试程序。除了测试这些新程序之外，还要在所有 \LangLoop{}
  测试和 \LangDyn{} 测试上测试编译器。有时在 \LangDyn{} 程序中可能会出现类型检查错误，但是您可以通过在每个子表达式周围的 \code{Any} 类型中插入强制转换来调整它们，从而导致类型错误。虽然 \LangDyn{} 没有显式强制转换，但可以通过调用一个未注释的身份函数来包装子表达式 \code{e} 来诱导一次强制转换，例如: \code{((lambda (x) x) e)} 。
\end{exercise}

\begin{figure}[p]
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (Rgradual) at (6,4)  {\large \LangGrad{}};
\node (Rgradualp) at (3,4)  {\large \LangCast{}};
\node (Rwhilepp) at (0,4)  {\large \LangProxy{}};
\node (Rwhileproxy) at (0,2)  {\large \LangPVec{}};
\node (Rwhileproxy-2) at (3,2)  {\large \LangPVec{}};
\node (Rwhileproxy-3) at (6,2)  {\large \LangPVec{}};
\node (Rwhileproxy-4) at (9,2)  {\large \LangPVecFunRef{}};
\node (Rwhileproxy-5) at (12,2)  {\large \LangPVecFunRef{}};
\node (F1-1) at (12,0)  {\large \LangPVecFunRef{}};
\node (F1-2) at (9,0)  {\large \LangPVecFunRef{}};
\node (F1-3) at (6,0)  {\large \LangPVecFunRef{}};
\node (F1-4) at (3,0)  {\large \LangPVecAlloc{}};
\node (F1-5) at (0,0)  {\large \LangPVecAlloc{}};
\node (C3-2) at (3,-2)  {\large \LangCLoopPVec{}};

\node (x86-2) at (3,-4)  {\large \LangXIndCallVar{}};
\node (x86-2-1) at (3,-6)  {\large \LangXIndCallVar{}};
\node (x86-2-2) at (6,-6)  {\large \LangXIndCallVar{}};
\node (x86-3) at (6,-4)  {\large \LangXIndCallVar{}};
\node (x86-4) at (9,-4) {\large \LangXIndCall{}};
\node (x86-5) at (9,-6) {\large \LangXIndCall{}};


\path[->,bend right=15] (Rgradual) edge [above] node
     {\ttfamily\footnotesize type-check} (Rgradualp);
\path[->,bend right=15] (Rgradualp) edge [above] node
     {\ttfamily\footnotesize lower-casts} (Rwhilepp);
\path[->,bend right=15] (Rwhilepp) edge [right] node
     {\ttfamily\footnotesize differentiate-proxies} (Rwhileproxy);
\path[->,bend left=15] (Rwhileproxy) edge [above] node
     {\ttfamily\footnotesize shrink} (Rwhileproxy-2);
\path[->,bend left=15] (Rwhileproxy-2) edge [above] node
     {\ttfamily\footnotesize uniquify} (Rwhileproxy-3);
\path[->,bend left=15] (Rwhileproxy-3) edge [above] node
     {\ttfamily\footnotesize reveal-functions} (Rwhileproxy-4);
\path[->,bend left=15] (Rwhileproxy-4) edge [above] node
     {\ttfamily\footnotesize reveal-casts} (Rwhileproxy-5);
\path[->,bend left=15] (Rwhileproxy-5) edge [left] node
     {\ttfamily\footnotesize convert-assignments} (F1-1);
\path[->,bend left=15] (F1-1) edge [below] node
     {\ttfamily\footnotesize convert-to-clos.} (F1-2);
\path[->,bend right=15] (F1-2) edge [above] node
     {\ttfamily\footnotesize limit-fun.} (F1-3);
\path[->,bend right=15] (F1-3) edge [above] node
     {\ttfamily\footnotesize expose-alloc.} (F1-4);
\path[->,bend right=15] (F1-4) edge [above] node
     {\ttfamily\footnotesize remove-complex.} (F1-5);
\path[->,bend right=15] (F1-5) edge [right] node
     {\ttfamily\footnotesize explicate-control} (C3-2);
\path[->,bend left=15] (C3-2) edge [left] node
     {\ttfamily\footnotesize select-instr.} (x86-2);
\path[->,bend right=15] (x86-2) edge [left] node
     {\ttfamily\footnotesize uncover-live} (x86-2-1);
\path[->,bend right=15] (x86-2-1) edge [below] node 
     {\ttfamily\footnotesize build-inter.} (x86-2-2);
\path[->,bend right=15] (x86-2-2) edge [left] node
     {\ttfamily\footnotesize allocate-reg.} (x86-3);
\path[->,bend left=15] (x86-3) edge [above] node
     {\ttfamily\footnotesize patch-instr.} (x86-4);
\path[->,bend left=15] (x86-4) edge [right] node {\ttfamily\footnotesize print-x86} (x86-5);
\end{tikzpicture}
  \caption{ \LangGrad{} (渐进打字)的通道图。}
\label{fig:Rgradual-passes}
\end{figure}

图~\ref{fig:Rgradual-passes} 提供编译 \LangGrad{} 所需的所有通道的概览。

\section{延伸阅读}

这一章只是渐进式打字的皮毛。这里描述的基本方法缺少渐进类型实现中需要的两个关键要素:指责跟踪~\citep{Tobin-Hochstadt:2006fk,Wadler:2009qv} 和节省空间的类型转换~\citep{Herman:2006uq,Herman:2010aa} 。指责跟踪解决的问题是，当对高阶值进行强制转换失败时，它通常会在程序中远离原始强制转换的某个点上这样做。过失跟踪是一种通过强制转换和代理传播额外信息的技术，以便在强制转换失败时，错误消息可以指向源程序中强制转换的原始位置。

空间效率高的强制转换所解决的问题也与高阶强制转换有关。事实证明，在部分类型程序中，函数或向量可以在运行时进行很多类型转换。使用本章描述的方法，每次强制转换都会添加另一个
\code{lambda} 包装器或向量代理。这不仅会占用相当大的空间，而且会使函数调用和向量操作变慢。例如，在最坏的情况下，一个部分类型的快速排序版本可以围绕向量建立一个长度为 $O(n)$
的代理链，将算法的总时间复杂度从 $O(n^2)$ 改变为 $O(n^3)$ ！\citet{Herman:2006uq} 提出了一个解决这个问题的方法，即使用 \citet{Henglein:1994nz} 的强制演算来表示类型强制转换，这种方法通过将它们压缩成简洁的标准形式来防止创建长代理链。 \citet{Siek:2015ab} 给出了压缩强压的算法， \citet{Kuhlenschmidt:2019aa} 演示如何在Grift编译器中实现这些想法。
\begin{center}
  \url{https://github.com/Gradual-Typing/Grift}
\end{center}

在渐进类型和其他语言特性(如参数多态、信息流类型和类型推断等)之间还有一些有趣的交互。我们向读者推荐在线渐进式打字参考书目:
\begin{center}
  \url{http://samth.github.io/gradual-typing-bib/}
\end{center}

% TODO: challenge problem:
%   type analysis and type specialization?
%   coercions?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{参数多态性}
\label{ch:Rpoly}
\index{parametric polymorphism}
\index{generics}

本章研究类型化 Racket 的子集 \LangPoly{}
中参数多态性 \index{parametric polymorphism}
（也称为泛型 \index{generics}) 的编译。参数化多态通过参数化函数和数据结构所操作的类型来改进代码重用。例如，图~\ref{fig:map-vec-poly}
重新访问 \code{map-vec} 示例，但这次给出一个更适合的类型。这个 \code{map-vec} 函数是根据向量的元素类型参数化的。 \code{map-vec}
的类型是以下由 \code{All} 和类型参数 \code{a} 指定的多态类型。
\begin{lstlisting}
  (All (a) ((a -> a) (Vector a a) -> (Vector a a)))
\end{lstlisting}
这个想法是， \code{map-vec} 可以用于参数 \code{a} 的类型的 \emph{all} 选择。在图~\ref{fig:map-vec-poly} 中，将
\code{map-vec} 应用于一个整数向量，选择 \code{Integer} 表示
\code{a} ，但也可以将 \code{map-vec} 应用于一个布尔向量(和一个布尔函数)。

\begin{figure}[tbp]
  % poly_test_2.rkt
\begin{lstlisting}
(: map-vec (All (a) ((a -> a) (Vector a a) -> (Vector a a))))
(define (map-vec f v)
  (vector (f (vector-ref v 0)) (f (vector-ref v 1))))

(define (add1 [x : Integer]) : Integer (+ x 1))

(vector-ref (map-vec add1 (vector 0 41)) 1)
\end{lstlisting}
\caption{使用参数多态性的 \code{map-vec} 示例。}
\label{fig:map-vec-poly}
\end{figure}

图~\ref{fig:Rpoly-concrete-syntax} 定义
\LangPoly{} 的具体语法，图~\ref{fig:Rpoly-syntax} 定义抽象语法。为函数定义添加第二种形式，其中类型声明出现在 \code{define} 之前。在抽象语法中， \code{Def} 中的返回类型是 \code{Any}，但是为了在类型声明中使用返回类型，应该忽略它。(
\code{Any} 来自于使用与第~\ref{ch:Rdyn} 章相同的解析器。)  类型声明的存在使函数可以使用 \code{All} 类型，从而使其具有多态性。对类型语法进行扩展，以包括多态类型和类型变量。

\begin{figure}[tp]
\centering
\fbox{
  \begin{minipage}{0.96\textwidth}
\small
\[
\begin{array}{lcl}
  \Type &::=& \ldots \mid \LP\key{All}~\LP\Var\ldots\RP~ \Type\RP \mid \Var \\
  \Def &::=& \gray{ \CDEF{\Var}{\LS\Var \key{:} \Type\RS \ldots}{\Type}{\Exp} } \\
   &\mid& \LP\key{:}~\Var~\Type\RP \\
   &&       \LP\key{define}~ \LP\Var ~ \Var\ldots\RP ~ \Exp\RP  \\
  \LangPoly{} &::=& \gray{ \Def \ldots ~ \Exp }
\end{array}
\]
\end{minipage}
}
\caption{ \LangPoly{} 的具体语法，扩展 \LangLoop{}
    (图~\ref{fig:Rwhile-concrete-syntax})。}
\label{fig:Rpoly-concrete-syntax}
\end{figure}

\begin{figure}[tp]
\centering
\fbox{
  \begin{minipage}{0.96\textwidth}
\small
\[
\begin{array}{lcl}
  \Type &::=& \ldots \mid \LP\key{All}~\LP\Var\ldots\RP~ \Type\RP \mid \Var \\
  \Def &::=& \gray{ \DEF{\Var}{\LP\LS\Var \key{:} \Type\RS \ldots\RP}{\Type}{\code{'()}}{\Exp} } \\
   &\mid& \DECL{\Var}{\Type} \\
   &&  \DEF{\Var}{\LP\Var \ldots\RP}{\key{'Any}}{\code{'()}}{\Exp}  \\
  \LangPoly{} &::=& \gray{ \PROGRAMDEFSEXP{\code{'()}}{\LP\Def\ldots\RP}{\Exp} }
\end{array}
\]
\end{minipage}
}
\caption{ \LangPoly{} 抽象语法，扩展 \LangLoop{}
    (图~\ref{fig:Rwhile-syntax}).}
\label{fig:Rpoly-syntax}
\end{figure}

通过在 $\Type$ 非终结符中包含多态类型，选择使它们成为头等类型，这对编译器有有趣的影响。许多具有多态性的语言，比如
C++~\citep{stroustrup88:_param_types} 和 Standard
ML~\citep{Milner:1990fk} ，只支持二级多态性，所以看看一级多态性的例子是很有用的。在图~\ref{fig:apply-twice} 中，定义一个函数 \code{apply-twice}
，它的参数是一个多态函数。在函数类型下面出现多态类型是通过 $\Type$ 语法的普通递归结构和 \code{All} 类型分类为 $\Type$ 来实现的。 \code{apply-twice} 的函数体将多态函数应用于布尔值和整数。

\begin{figure}[tbp]
\begin{lstlisting}
(: apply-twice ((All (b) (b -> b)) -> Integer))
(define (apply-twice f)
  (if (f #t) (f 42) (f 777)))

(: id (All (a) (a -> a)))
(define (id x) x)

(apply-twice id)
\end{lstlisting}
\caption{说明一级多态性的示例。}
\label{fig:apply-twice}
\end{figure}

图~\ref{fig:type-check-Rvar0} 中 \LangPoly{} 的类型检查器有三个新职责(与 \LangLoop{} 相比)。扩展函数应用程序的类型检查，以处理操作符表达式是多态函数的情况。在这种情况下，通过将形参的类型与实参的类型匹配来推导类型实参。
%
 \code{match-types} 辅助函数通过递归降序通过形参类型 \code{pt} 和相应的实参类型 \code{at}来执行这一推断，确保它们是相等的，除非左边有类型形参(在形参类型中)。如果是第一次遇到类型形参，那么算法将推断出类型形参与右边对应的类型的关联(在实参类型中)。如果不是第一次遇到类型参数，算法将查找其推导出的类型，并确保它与右边的类型相等。
%
一旦推导出类型参数，操作符表达式就被包装在一个 \code{Inst} AST 节点中(用于实例化)，该节点记录操作符的类型，但更重要的是，记录推导出的类型参数。应用程序的返回类型是多态函数的返回类型，但是使用 \code{subst-type} 函数将类型参数替换为推导的类型参数。

类型检查器的第二个职责是扩展 \code{type-equal?} 函数来处理 \code{All} 类型。对于其他类型(如函数和向量类型)，这就不那么简单，因为尽管两个多态类型是等价类型，但它们在语法上可能是不同的。例如，
\code{(All (a) (a -> a))} 等价于 \code{(All (b) (b -> b))} 。
如果两个多态类型仅在类型参数名称的选择上不同，则应该认为它们是相等的。图~\ref{fig:type-check-Rvar0-aux} 中的
\code{type-equal?} 函数重命名第一个类型的类型形参，以匹配第二个类型的类型形参。

类型检查器的第三个职责是确保只有已定义的类型变量才出现在类型注释中。图~\ref{fig:well-formed-types} 中定义的
\code{check-well-formed} 函数递归地检查一个类型，确保每个类型变量都已定义。

类型检查器的输出语言是 \LangInst{} ，在图~\ref{fig:Rpoly-prime-syntax} 中定义。类型检查器使用 \code{Poly} 形式将类型声明和多态函数组合成一个单独的定义，以使多态函数在编译器的下一次传递中更方便地处理。

\begin{figure}[tp]
\centering
\fbox{
  \begin{minipage}{0.96\textwidth}
\small
\[
\begin{array}{lcl}
  \Type &::=& \ldots \mid \LP\key{All}~\LP\Var\ldots\RP~ \Type\RP \mid \Var \\
  \Exp &::=& \ldots \mid \INST{\Exp}{\Type}{\LP\Type\ldots\RP} \\
  \Def &::=& \gray{ \DEF{\Var}{\LP\LS\Var \key{:} \Type\RS \ldots\RP}{\Type}{\code{'()}}{\Exp} } \\
   &\mid& \LP\key{Poly}~\LP\Var\ldots\RP~ \DEF{\Var}{\LP\LS\Var \key{:} \Type\RS \ldots\RP}{\Type}{\code{'()}}{\Exp}\RP  \\
  \LangInst{} &::=& \gray{ \PROGRAMDEFSEXP{\code{'()}}{\LP\Def\ldots\RP}{\Exp} }
\end{array}
\]
\end{minipage}
}
\caption{ \LangInst{} 的抽象语法扩展 \LangLoop{} (图~\ref{fig:Rwhile-syntax})。}
\label{fig:Rpoly-prime-syntax}
\end{figure}

图~\ref{fig:map-vec-type-check} 中列出多态 \code{map-vec} 示例上的类型检查器的输出

\begin{figure}[tbp]
  % poly_test_2.rkt
\begin{lstlisting}
(poly (a) (define (map-vec [f : (a -> a)] [v : (Vector a a)]) : (Vector a a)
  (vector (f (vector-ref v 0)) (f (vector-ref v 1)))))

(define (add1 [x : Integer]) : Integer (+ x 1))

(vector-ref ((inst map-vec (All (a) ((a -> a) (Vector a a) -> (Vector a a)))
                           (Integer))
              add1 (vector 0 41)) 1)
\end{lstlisting}
\caption{ \code{map-vec} 示例上的类型检查器的输出。}
\label{fig:map-vec-type-check}
\end{figure}

\begin{figure}[tbp]
\begin{lstlisting}
(define type-check-poly-class
  (class type-check-Rwhile-class
    (super-new)
    (inherit check-type-equal?)
  
    (define/override (type-check-apply env e1 es)
      (define-values (e^ ty) ((type-check-exp env) e1))
      (define-values (es^ ty*) (for/lists (es^ ty*) ([e (in-list es)])
                                ((type-check-exp env) e)))
      (match ty
        [`(,ty^* ... -> ,rt)
         (for ([arg-ty ty*] [param-ty ty^*])
           (check-type-equal? arg-ty param-ty (Apply e1 es)))
         (values e^ es^ rt)]
        [`(All ,xs (,tys ... -> ,rt))
         (define env^ (append (for/list ([x xs]) (cons x 'Type)) env))
         (define env^^ (for/fold ([env^^ env^]) ([arg-ty ty*] [param-ty tys])
                         (match-types env^^ param-ty arg-ty)))
         (define targs
           (for/list ([x xs])
             (match (dict-ref env^^ x (lambda () #f))
               [#f (error 'type-check "type variable ~a not deduced\nin ~v"
                          x (Apply e1 es))]
               [ty ty])))
         (values (Inst e^ ty targs) es^ (subst-type env^^ rt))]
        [else (error 'type-check "expected a function, not ~a" ty)]))
    
    (define/override ((type-check-exp env) e)
      (match e
        [(Lambda `([,xs : ,Ts] ...) rT body)
         (for ([T Ts]) ((check-well-formed env) T))
         ((check-well-formed env) rT)
         ((super type-check-exp env) e)]
        [(HasType e1 ty)
         ((check-well-formed env) ty)
         ((super type-check-exp env) e)]
        [else ((super type-check-exp env) e)]))
\end{lstlisting}
\end{figure}
\begin{figure}[tbp]
\begin{lstlisting}
    (define/override ((type-check-def env) d)
      (verbose 'type-check "poly/def" d)
      (match d
        [(Generic ts (Def f (and p:t* (list `[,xs : ,ps] ...)) rt info body))
         (define ts-env (for/list ([t ts]) (cons t 'Type)))
         (for ([p ps]) ((check-well-formed ts-env) p))
         ((check-well-formed ts-env) rt)
         (define new-env (append ts-env (map cons xs ps) env))
         (define-values (body^ ty^) ((type-check-exp new-env) body))
         (check-type-equal? ty^ rt body)
         (Generic ts (Def f p:t* rt info body^))]
        [else ((super type-check-def env) d)]))

    (define/override (type-check-program p)
      (match p
        [(Program info body)
         (type-check-program (ProgramDefsExp info '() body))]
        [(ProgramDefsExp info ds body)
         (define ds^ (combine-decls-defs ds))
         (define new-env (for/list ([d ds^])
                           (cons (def-name d) (fun-def-type d))))
         (define ds^^ (for/list ([d ds^]) ((type-check-def new-env) d)))
         (define-values (body^ ty) ((type-check-exp new-env) body))
         (check-type-equal? ty 'Integer body)
         (ProgramDefsExp info ds^^ body^)]))
  ))
\end{lstlisting}
\caption{ \LangPoly{} 语言的类型检查器。}
\label{fig:type-check-Rvar0}
\end{figure}

\begin{figure}[tbp]
\begin{lstlisting}
(define/override (type-equal? t1 t2)
  (match* (t1 t2)
    [(`(All ,xs ,T1) `(All ,ys ,T2))
     (define env (map cons xs ys))
     (type-equal? (subst-type env T1) T2)]
    [(other wise)
     (super type-equal? t1 t2)]))

(define/public (match-types env pt at)
  (match* (pt at)
    [('Integer 'Integer) env] [('Boolean 'Boolean) env]
    [('Void 'Void) env] [('Any 'Any) env]
    [(`(Vector ,pts ...) `(Vector ,ats ...))
     (for/fold ([env^ env]) ([pt1 pts] [at1 ats])
       (match-types env^ pt1 at1))]
    [(`(,pts ... -> ,prt) `(,ats ... -> ,art))
     (define env^ (match-types env prt art))
     (for/fold ([env^^ env^]) ([pt1 pts] [at1 ats])
       (match-types env^^ pt1 at1))]
    [(`(All ,pxs ,pt1) `(All ,axs ,at1))
     (define env^ (append (map cons pxs axs) env))
     (match-types env^ pt1 at1)]
    [((? symbol? x) at)
     (match (dict-ref env x (lambda () #f))
       [#f (error 'type-check "undefined type variable ~a" x)]
       ['Type (cons (cons x at) env)]
       [t^ (check-type-equal? at t^ 'matching) env])]
    [(other wise) (error 'type-check "mismatch ~a != a" pt at)]))
\end{lstlisting}
\end{figure}
\begin{figure}[tbp]
\begin{lstlisting}
(define/public (subst-type env pt)
  (match pt
    ['Integer 'Integer] ['Boolean 'Boolean]
    ['Void 'Void] ['Any 'Any]
    [`(Vector ,ts ...)
     `(Vector ,@(for/list ([t ts]) (subst-type env t)))]
    [`(,ts ... -> ,rt)
     `(,@(for/list ([t ts]) (subst-type env t)) -> ,(subst-type env rt))]
    [`(All ,xs ,t)
     `(All ,xs ,(subst-type (append (map cons xs xs) env) t))]
    [(? symbol? x) (dict-ref env x)]
    [else (error 'type-check "expected a type not ~a" pt)]))

(define/public (combine-decls-defs ds)
  (match ds
    ['() '()]
    [`(,(Decl name type) . (,(Def f params _ info body) . ,ds^))
     (unless (equal? name f)
       (error 'type-check "name mismatch, ~a != ~a" name f))
     (match type
       [`(All ,xs (,ps ... -> ,rt))
        (define params^ (for/list ([x params] [T ps]) `[,x : ,T]))
        (cons (Generic xs (Def name params^ rt info body))
              (combine-decls-defs ds^))]
       [`(,ps ... -> ,rt)
        (define params^ (for/list ([x params] [T ps]) `[,x : ,T]))
        (cons (Def name params^ rt info body) (combine-decls-defs ds^))]
       [else (error 'type-check "expected a function type, not ~a" type) ])]
    [`(,(Def f params rt info body) . ,ds^)
     (cons (Def f params rt info body) (combine-decls-defs ds^))]))
\end{lstlisting}
\caption{用于类型检查 \LangPoly{} 的辅助功能。}
\label{fig:type-check-Rvar0-aux}
\end{figure}


\begin{figure}[tbp]
\begin{lstlisting}%[basicstyle=\ttfamily\scriptsize]
(define/public ((check-well-formed env) ty)
  (match ty
    ['Integer (void)]
    ['Boolean (void)]
    ['Void (void)]
    [(? symbol? a)
     (match (dict-ref env a (lambda () #f))
       ['Type (void)]
       [else (error 'type-check "undefined type variable ~a" a)])]
    [`(Vector ,ts ...)
     (for ([t ts]) ((check-well-formed env) t))]
    [`(,ts ... -> ,t)
     (for ([t ts]) ((check-well-formed env) t))
     ((check-well-formed env) t)]
    [`(All ,xs ,t)
     (define env^ (append (for/list ([x xs]) (cons x 'Type)) env))
     ((check-well-formed env^) t)]
    [else (error 'type-check "unrecognized type ~a" ty)]))
\end{lstlisting}
\caption{格式良好的类型。}
\label{fig:well-formed-types}
\end{figure}

% TODO: interpreter for R'_10

\section{编译多态性}
\label{sec:compiling-poly}

广义地说，有四种编译参数多态性的方法，在下面描述它们。

\begin{description}
\item[单形式化] 为使用它的每一组类型参数生成多态函数的不同版本，产生类型专门化的代码。这种方法可以产生最有效的代码，但需要整个程序编译(不需要单独编译)，并增加代码大小。就目前的目的而言，单一化是行不通的，因为在一级多态性中，有时无法确定在编译期间使用哪些泛型函数与哪些类型参数。(它可以在运行时通过实时编译完成。) 该方法用于在 NESL~\citep{Blelloch:1993aa} 和
  ML~\citep{Weeks:2006aa} 中编译 C++
  模板~\citep{stroustrup88:_param_types} 和多态函数。
  
\item[统一表示] 为每个多态函数生成一个版本，但要求所有值都具有公共的“装箱”格式，例如 \LangAny{} 中的 \code{Any} 类型标记值。非多态代码(即单态代码)的编译方式类似于动态类型语言(如 \LangDyn{} )中的代码，在这种语言中，原语操作符要求它们的参数从 \code{Any} 中投射出来，并将它们的结果注入 \code{Any} 中。 (在面向对象的语言中，投影是通过虚拟方法调度来实现的。) 统一表示方法与单独编译和一流多态性兼容。但是，它产生的代码效率最低，因为它在整个程序中引入开销，包括非多态代码。这种方法在
  CLU~\cite{liskov79:_clu_ref,Liskov:1993dk} 、
  ML~\citep{Cardelli:1984aa,Appel:1987aa} 和
  Java~\citep{Bracha:1998fk} 的实现中使用。
  
\item[混合表示] 使用类型变量的装箱表示生成每个多态函数的一个版本。单态代码通常被编译(如在 \LangLoop{} 中)，在单态和多态之间的边界执行转换(例如，当一个多态函数被实例化和调用时)。这种方法与单独编译和一级多态性兼容，并保持了单态代码的效率。在单态代码和多态代码之间的边界增加了开销。这种方法在 ML~\citep{Leroy:1992qb} 和 Java 的实现中使用，从Java 5开始，添加自动装箱功能。
  
\item[类型传递] 在单态和多态代码中都使用未装箱表示。每个多态函数被编译为一个带有描述类型参数的额外参数的单一函数。生成的代码使用类型信息来解如何在运行时访问未装箱的值。在 Napier88
  语言~\citep{Morrison:1991aa} 和 ML~\citep{Harper:1995um} 的实现中使用了这种方法。类型传递与单独编译和一级多态性兼容，并保持了单态代码的效率。在多态代码中，由于对类型信息进行调度，会产生运行时开销。
\end{description}

在本章中，使用混合表示方法，部分原因是它具有良好的属性，部分原因是它可以直接使用已经构建的支持渐进类型的工具来实现。为了编译多态函数，只添加一个新通道， \code{erase-types} ，将 \LangInst{} 编译为
\LangCast{} 。

\section{擦除类型}
\label{sec:erase-types}

使用第~\ref{ch:Rdyn} 章中的
\code{Any} 类型来表示类型变量。例如，图~\ref{fig:map-vec-erase}
显示 \code{erase-types} 通道到多态
\code{map-vec} 的输出(图~\ref{fig:map-vec-poly}) 。类型参数 \code{a} 的出现被 \code{Any} 代替，多态的
\code{All} 类型从 \code{map-vec} 类型中删除。

\begin{figure}[tbp]
\begin{lstlisting}
(define (map-vec [f : (Any -> Any)] [v : (Vector Any Any)])
                   : (Vector Any Any)
  (vector (f (vector-ref v 0)) (f (vector-ref v 1))))

(define (add1 [x : Integer]) : Integer (+ x 1))

(vector-ref ((cast map-vec
                     ((Any -> Any) (Vector Any Any) -> (Vector Any Any))  
                     ((Integer -> Integer) (Vector Integer Integer)
                               -> (Vector Integer Integer)))
             add1 (vector 0 41)) 1)
\end{lstlisting}
\caption{类型擦除后的多态 \code{map-vec} 示例。}
\label{fig:map-vec-erase}
\end{figure}

这种类型擦除过程在实例化点上产生挑战。例如，考虑图~\ref{fig:map-vec-type-check} 中 \code{map-vec} 的实例化。
 \code{map-vec} 的类型是
\begin{lstlisting}
(All (a) ((a -> a) (Vector a a) -> (Vector a a)))
\end{lstlisting}
它被实例化为
\begin{lstlisting}
((Integer -> Integer) (Vector Integer Integer)
   -> (Vector Integer Integer))
\end{lstlisting}
擦除后， \code{map-vec} 的类型是
\begin{lstlisting}
((Any -> Any) (Vector Any Any) -> (Vector Any Any))
\end{lstlisting}
但是需要将其转换为实例化的类型。这在目标语言 \LangCast{} 中很容易做到，只使用一个 \code{cast} 。在图~\ref{fig:map-vec-erase} 中， \code{map-vec}
的实例化已经被编译为 \code{map-vec} 的类型到实例化类型的
\code{cast} 。强制转换的源类型和目标类型必须一致（图~\ref{fig:consistent}) ，确实如此，因为源和目标都是从相同的 \code{map-vec} 的多态类型获得的，将类型参数替换为前者中的
\code{Any} 以及稍后推导的type参数。 (回想一下， \code{Any} 类型与任何类型一致。)

为了实现 \code{erase-types} 通道，建议定义一个名为 \code{erase-type} 的递归辅助函数，该函数应用以下两个转换。它将类型变量替换为 \code{Any}
\begin{lstlisting}
|$x$|
|$\Rightarrow$|
Any
\end{lstlisting}
并且删除多态的 \code{All} 类型。
\begin{lstlisting}
(All |$xs$| |$T_1$|)
|$\Rightarrow$|
|$T'_1$|
\end{lstlisting}
对程序中的所有类型注释应用 \code{erase-type} 函数。

在表达的翻译方面， \code{Inst} 的情况是一个有趣的例子。将其转换为 \code{Cast} ，如下所示。子表达式 $e$ 的类型是多态类型
$\LP\key{All} xs T\RP$ 。转换的源类型是
$T$ 的擦除，即类型 $T'$ 。目标类型 $T''$ 是将实参类型 $ts$ 替换为 $T$ 中的类型形参 $xs$ ，然后进行类型擦除的结果。
\begin{lstlisting}
(Inst |$e$| (All |$xs$| |$T$|) |$ts$|)
|$\Rightarrow$|
(Cast |$e'$| |$T'$| |$T''$|)
\end{lstlisting}
其中， $T'' = \LP\code{erase-type}~\LP\code{subst-type}~s~T\RP\RP$
， $s = \LP\code{map}~\code{cons}~xs~ts\RP$ 。

最后，将每个多态函数翻译为一个常规函数，其中类型擦除已应用于所有类型注释和主体。
\begin{lstlisting}
(Poly |$ts$| (Def |$f$| ([|$x_1$| : |$T_1$|] |$\ldots$|) |$T_r$| |$\itm{info}$| |$e$|))
|$\Rightarrow$|          
(Def |$f$| ([|$x_1$| : |$T'_1$|] |$\ldots$|) |$T'_r$| |$\itm{info}$| |$e'$|)
\end{lstlisting}

\begin{exercise}\normalfont
  为多态语言 \LangPoly{} 实现一个编译器，通过扩展和适应你的编译器为 \LangGrad{} 。创建6个使用多态函数的新测试程序。其中一些应该利用一级多态性。
\end{exercise}

\begin{figure}[p]
\begin{tikzpicture}[baseline=(current  bounding  box.center)]
\node (Rpoly) at (9,4)  {\large \LangPoly{}};
\node (Rpolyp) at (6,4)  {\large \LangInst{}};
\node (Rgradualp) at (3,4)  {\large \LangCast{}};
\node (Rwhilepp) at (0,4)  {\large \LangProxy{}};
\node (Rwhileproxy) at (0,2)  {\large \LangPVec{}};
\node (Rwhileproxy-2) at (3,2)  {\large \LangPVec{}};
\node (Rwhileproxy-3) at (6,2)  {\large \LangPVec{}};
\node (Rwhileproxy-4) at (9,2)  {\large \LangPVecFunRef{}};
\node (Rwhileproxy-5) at (12,2)  {\large \LangPVecFunRef{}};
\node (F1-1) at (12,0)  {\large \LangPVecFunRef{}};
\node (F1-2) at (9,0)  {\large \LangPVecFunRef{}};
\node (F1-3) at (6,0)  {\large \LangPVecFunRef{}};
\node (F1-4) at (3,0)  {\large \LangPVecAlloc{}};
\node (F1-5) at (0,0)  {\large \LangPVecAlloc{}};
\node (C3-2) at (3,-2)  {\large \LangCLoopPVec{}};

\node (x86-2) at (3,-4)  {\large \LangXIndCallVar{}};
\node (x86-2-1) at (3,-6)  {\large \LangXIndCallVar{}};
\node (x86-2-2) at (6,-6)  {\large \LangXIndCallVar{}};
\node (x86-3) at (6,-4)  {\large \LangXIndCallVar{}};
\node (x86-4) at (9,-4) {\large \LangXIndCall{}};
\node (x86-5) at (9,-6) {\large \LangXIndCall{}};


\path[->,bend right=15] (Rpoly) edge [above] node
     {\ttfamily\footnotesize type-check} (Rpolyp);
\path[->,bend right=15] (Rpolyp) edge [above] node
     {\ttfamily\footnotesize erase-types} (Rgradualp);
\path[->,bend right=15] (Rgradualp) edge [above] node
     {\ttfamily\footnotesize lower-casts} (Rwhilepp);
\path[->,bend right=15] (Rwhilepp) edge [right] node
     {\ttfamily\footnotesize differentiate-proxies} (Rwhileproxy);
\path[->,bend left=15] (Rwhileproxy) edge [above] node
     {\ttfamily\footnotesize shrink} (Rwhileproxy-2);
\path[->,bend left=15] (Rwhileproxy-2) edge [above] node
     {\ttfamily\footnotesize uniquify} (Rwhileproxy-3);
\path[->,bend left=15] (Rwhileproxy-3) edge [above] node
     {\ttfamily\footnotesize reveal-functions} (Rwhileproxy-4);
\path[->,bend left=15] (Rwhileproxy-4) edge [above] node
     {\ttfamily\footnotesize reveal-casts} (Rwhileproxy-5);
\path[->,bend left=15] (Rwhileproxy-5) edge [left] node
     {\ttfamily\footnotesize convert-assignments} (F1-1);
\path[->,bend left=15] (F1-1) edge [below] node
     {\ttfamily\footnotesize convert-to-clos.} (F1-2);
\path[->,bend right=15] (F1-2) edge [above] node
     {\ttfamily\footnotesize limit-fun.} (F1-3);
\path[->,bend right=15] (F1-3) edge [above] node
     {\ttfamily\footnotesize expose-alloc.} (F1-4);
\path[->,bend right=15] (F1-4) edge [above] node
     {\ttfamily\footnotesize remove-complex.} (F1-5);
\path[->,bend right=15] (F1-5) edge [right] node
     {\ttfamily\footnotesize explicate-control} (C3-2);
\path[->,bend left=15] (C3-2) edge [left] node
     {\ttfamily\footnotesize select-instr.} (x86-2);
\path[->,bend right=15] (x86-2) edge [left] node
     {\ttfamily\footnotesize uncover-live} (x86-2-1);
\path[->,bend right=15] (x86-2-1) edge [below] node 
     {\ttfamily\footnotesize build-inter.} (x86-2-2);
\path[->,bend right=15] (x86-2-2) edge [left] node
     {\ttfamily\footnotesize allocate-reg.} (x86-3);
\path[->,bend left=15] (x86-3) edge [above] node
     {\ttfamily\footnotesize patch-instr.} (x86-4);
\path[->,bend left=15] (x86-4) edge [right] node {\ttfamily\footnotesize print-x86} (x86-5);
\end{tikzpicture}
  \caption{ \LangPoly{} (参数多态)通道图。}
\label{fig:Rpoly-passes}
\end{figure}

图~\ref{fig:Rpoly-passes} 提供编译 \LangPoly{} 所需的所有通道的概览。

% TODO: challenge problem: specialization of instantiations

% Further Reading


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{附录}

\section{解释器}
\label{appendix:interp}
\index{interpreter}

在 \code{interp-Rint.rkt},\code{interp-Rvar.rkt} 等文件中为每一种源语言 \LangInt{} 、
\LangVar{} 、 $\ldots$ 提供解释器。中间语言 \LangCVar{} 和 \LangCIf{} 的解释器是 \code{interp-Cvar.rkt} 和
\code{interp-C1.rkt} 文件中。 \LangCVec{} 、 \LangCFun{} 、 pseudo-x86
and x86 的解释器在 \key{interp.rkt} 文件中。

\section{公用功能}
\label{appendix:utilities}

本节中描述的实用程序函数位于支持代码的 \key{utilities.rkt} 文件中。

\paragraph{\code{interp-tests}}

 \key{interp-tests} 函数对每个指定的测试运行编译器通过和解释器，以检查每次通过是否正确。 \key{interp-tests} 功能有以下参数:
\begin{description}
\item[name (a string)] 标识编译器的名称；
\item[typechecker] 只有一个参数的函数，在遇到类型错误时使用 \code{error} 函数引发错误，或在遇到类型错误时返回 \code{\#f} 。如果没有类型错误，类型检查器将返回该程序。

\item[passes] 每次传递一个条目的列表。一个条目是一个包含四项内容的列表:
  \begin{enumerate}
  \item 一个给出通道名称的字符串；
  \item 实现通道 (AST到AST的转换程序)的函数；
  \item 为输出语言实现解释器(从AST到结果值的函数)的函数；
  \item 输出语言的类型检查器。支持代码中提供 $R$ 和 $C$ 语言的类型检查器。例如， \LangVar{} 和 \LangCVar{} 的类型检查器在
    \code{type-check-Rvar.rkt} 和 \code{type-check-Cvar.rkt} 中。类型检查器条目是可选的。支持代码没有为x86语言提供类型检查器。
  \end{enumerate}

\item[source-interp] 源语言的解释器。附录~\ref{appendix:interp} 中的口译员做出很好的选择。
  
\item[test-family (a string)] 例如， \code{"r1"}、 \code{"r2"} 等。
\item[tests] 指定要运行哪些测试的测试号列表。(见下文)
\end{description}
%
 \key{interp-tests} 函数假定子目录
\key{tests} 有一个 Racket 程序集合，这些程序的名称都以家族名开头，后跟下划线和测试号，以文件扩展名 \key{.rkt} 结尾。此外，对于每个调用 \code{read} 一次或多次的测试程序，除了文件扩展名为 \key{.in} 外，还有一个同名的文件，该文件为 Racket 程序提供了输入。如果预期测试程序的类型检查失败，那么应该有一个同名但扩展名为 \key{.tyerr} 的空文件。


\paragraph{\code{compiler-tests}}

运行编译器传递生成x86 ( \key{.s} 文件)，然后运行GNU C编译器(gcc)生成机器码。它运行机器代码并检查输出是否为 $42$ 。
\code{compiler-tests} 函数的形参类似于
\code{interp-tests} 函数的形参，由以下几个部分组成
\begin{itemize}
\item 编译器名称(字符串)；
\item 类型检查器；
\item 通道的描述；
\item 测试族名称；
\item 测试编号的列表。
\end{itemize}


\paragraph{\code{compile-file}}

需要编译器传递的描述(见注释为
\key{interp-tests} )并返回一个函数,给出一个程序文件名称(字符串以 \key{.rkt} ,适用于所有的经过,并将输出写入到一个文件的名字是一样的程序文件名称,但 \key{.rkt} 替换为 \key{.s} 。


\paragraph{\code{read-program}}

获取一个文件路径，并将该文件(它必须是一个Racket程序)解析为一个抽象语法树。

\paragraph{\code{parse-program}}

接受抽象语法树的s表达式表示，并将其转换为基于结构的表示。

\paragraph{\code{assert}}

它接受两个参数，一个字符串 (\code{msg}) 和一个布尔值 (\code{bool}) ，如果布尔值为 \key{msg} ，则显示消息\key{bool} 。

\paragraph{\code{lookup}}

% remove discussion of lookup? -Jeremy
接受一个键和一个列表，并返回与给定键关联的第一个值(如果有的话)。如果不是，则会触发一个错误。列表可能同时包含不可变对(用
\key{cons} 构建)和可变对(用 \key{mcons} 构建)。

%The \key{map2} function ...

\section{x86指令集快速参考}
\label{sec:x86-quick-reference}
\index{x86}

表~\ref{tab:x86-instr} 列出一些x86指令及其作用。用 $A \to B$ 表示 $A$ 的值被写入位置 $B$ 。地址偏移量是以字节为单位给出的。指令参数 $A, B, C$ 可以是直接常量(如 \code{\$4}) 、
寄存器(如 \code{\%rax}) 或内存引用(如
\code{-4(\%ebp)}) 。大多数x86指令最多只允许一条指令引用一个内存。其他操作数必须是直接数或寄存器。

\begin{table}[tbp]
  \centering
\begin{tabular}{l|l}
\textbf{指令} & \textbf{运算} \\ \hline
\texttt{addq} $A$, $B$ &  $A + B \to B$\\
\texttt{negq} $A$ & $- A \to A$ \\
\texttt{subq} $A$, $B$ &  $B - A \to B$\\
\texttt{imulq} $A$, $B$ &  $A \times B \to B$\\
\texttt{callq} $L$ & 输入返回地址并跳转到标签 $L$ \\
\texttt{callq} \texttt{*}$A$ & 在地址 $A$ 处调用函数。\\
%\texttt{leave} & $\texttt{ebp} \to \texttt{esp};$ \texttt{popl \%ebp} \\
\texttt{retq} & 弹出返回地址，然后跳转到它 \\
\texttt{popq} $A$ & $*\mathtt{rsp} \to A; \mathtt{rsp} + 8 \to \mathtt{rsp}$ \\
\texttt{pushq} $A$ & $\texttt{rsp} - 8 \to \texttt{rsp}; A \to *\texttt{rsp}$\\
\texttt{leaq} $A$,$B$ & $A \to B$ ($B$ 必须是寄存器) \\
\texttt{cmpq} $A$, $B$ & 比较 $A$ 和 $B$ ，并设置标志寄存器 ($B$ 不能是即时寄存器) \\
\texttt{je} $L$ & \multirow{5}{3.7in}{如果标志寄存器与指令的条件代码匹配，则跳转到标签 $L$ ，否则转到下一个指令。条件代码是 \key{e} 表示“等于”，
  \key{l} 表示“小于”， \key{le} 表示“小于或等于”， \key{g}
  表示“大于”， \key{ge} 表示“大于或等于”。} \\
\texttt{jl} $L$ & \\
\texttt{jle} $L$ & \\
\texttt{jg} $L$ & \\
\texttt{jge} $L$ & \\
\texttt{jmp} $L$ & 跳转到标签 $L$ \\
\texttt{movq} $A$, $B$ &  $A \to B$ \\
\texttt{movzbq} $A$, $B$ &
  \multirow{3}{3.7in}{$A \to B$ ， \text{其中 } $A$ 是一个单字节寄存器(例如， \texttt{al} 或 \texttt{cl}) ， $B$ 是一个8字节寄存器，并且 $B$ 的额外字节被设为零。} \\
 & \\
 & \\
\texttt{notq} $A$ & $\sim A \to A$ \qquad (按位补码)\\
\texttt{orq} $A$, $B$ & $A | B \to B$ \qquad (按位或)\\
\texttt{andq} $A$, $B$ & $A \& B \to B$ \qquad (按位与)\\
\texttt{salq} $A$, $B$ & $B$ \texttt{<<} $A \to B$ (向左移动，其中 $A$ 是一个常数)\\
\texttt{sarq} $A$, $B$ & $B$ \texttt{>>} $A \to B$ (向右移动，其中 $A$ 是一个常数)\\
\texttt{sete} $A$ & \multirow{5}{3.7in}{如果标志匹配条件代码，则为 $1 \to A$ ，否则为 $0 \to A$ 。关于条件代码的描述，请参阅上面的 \texttt{je} 。 $A$ 必须是单字节寄存器(如 \texttt{al} 或 \texttt{cl}) 。} \\
\texttt{setl} $A$ & \\
\texttt{setle} $A$ & \\
\texttt{setg} $A$ & \\
\texttt{setge} $A$ &
\end{tabular}
\vspace{5pt}
  \caption{本书中使用的x86指令的快速参考。}
  \label{tab:x86-instr}
\end{table}

\cleardoublepage

\section{中间语言的具体语法}

 \LangAny{} 的具体语法定义在图~\ref{fig:Rany-concrete-syntax} 中。

\begin{figure}[tp]
\centering
\fbox{
\begin{minipage}{0.97\textwidth}\small
\[
\begin{array}{lcl}
  \Type &::=& \gray{\key{Integer} \mid \key{Boolean}
     \mid \LP\key{Vector}\;\Type\ldots\RP \mid \key{Void}} \\
    &\mid& \gray{\LP\Type\ldots \; \key{->}\; \Type\RP} \mid \key{Any} \\
\FType &::=& \key{Integer} \mid \key{Boolean} \mid \key{Void} 
      \mid \LP\key{Vector}\; \key{Any}\ldots\RP \\
     &\mid& \LP\key{Any}\ldots \; \key{->}\; \key{Any}\RP\\
\Exp &::=& \ldots \CINJECT{\Exp}{\FType}\RP \mid \CPROJECT{\Exp}{\FType}\\
  &\mid& \LP\key{any-vector-length}\;\Exp\RP
   \mid \LP\key{any-vector-ref}\;\Exp\;\Exp\RP \\
  &\mid& \LP\key{any-vector-set!}\;\Exp\;\Exp\;\Exp\RP\\
  &\mid& \LP\key{boolean?}\;\Exp\RP \mid \LP\key{integer?}\;\Exp\RP
   \mid \LP\key{void?}\;\Exp\RP \\
  &\mid& \LP\key{vector?}\;\Exp\RP \mid \LP\key{procedure?}\;\Exp\RP \\
  \Def &::=& \gray{ \CDEF{\Var}{\LS\Var \key{:} \Type\RS\ldots}{\Type}{\Exp} } \\
  \LangAny{} &::=& \gray{\Def\ldots \; \Exp}
\end{array}
\]
\end{minipage}
}
\caption{ \LangAny{} 的具体语法，扩展 \LangLam{} (图~\ref{fig:Rlam-syntax}) 。}
\label{fig:Rany-concrete-syntax}
\end{figure}

 \LangCVar{} 、 \LangCIf{} 、 \LangCVec{} 和 \LangCFun{} 的具体语法分别定义在图~\ref{fig:c0-concrete-syntax} 、
\ref{fig:c1-concrete-syntax} 、 \ref{fig:c2-concrete-syntax}
和 \ref{fig:c3-concrete-syntax} 中。

\begin{figure}[tbp]
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{lcl}
\Atm &::=& \Int \mid \Var \\
\Exp &::=& \Atm \mid \key{(read)} \mid \key{(-}~\Atm\key{)} \mid \key{(+}~\Atm~\Atm\key{)}\\
\Stmt &::=& \Var~\key{=}~\Exp\key{;} \\
\Tail &::= & \key{return}~\Exp\key{;} \mid \Stmt~\Tail \\
\LangCVar{} & ::= & (\itm{label}\key{:}~ \Tail)\ldots
\end{array}
\]
\end{minipage}
}
\caption{ \LangCVar{} 中间语言的具体语法。}
\label{fig:c0-concrete-syntax}
\end{figure}

\begin{figure}[tbp]
\fbox{
\begin{minipage}{0.96\textwidth}
\small    
\[
\begin{array}{lcl}
\Atm &::=& \gray{ \Int \mid \Var } \mid \itm{bool} \\
\itm{cmp} &::= & \key{eq?} \mid \key{<}  \\
\Exp &::=& \gray{ \Atm \mid \key{(read)} \mid \key{(-}~\Atm\key{)} \mid \key{(+}~\Atm~\Atm\key{)} } \\
   &\mid& \LP \key{not}~\Atm \RP \mid \LP \itm{cmp}~\Atm~\Atm\RP \\
\Stmt &::=& \gray{ \Var~\key{=}~\Exp\key{;} } \\
\Tail &::= & \gray{ \key{return}~\Exp\key{;} \mid \Stmt~\Tail } 
   \mid \key{goto}~\itm{label}\key{;}\\
   &\mid& \key{if}~\LP \itm{cmp}~\Atm~\Atm \RP~ \key{goto}~\itm{label}\key{;} ~\key{else}~\key{goto}~\itm{label}\key{;} \\
\LangCIf{} & ::= & \gray{ (\itm{label}\key{:}~ \Tail)\ldots }
\end{array}
\]
\end{minipage}
}
\caption{ \LangCIf{} 中间语言的具体语法。}
\label{fig:c1-concrete-syntax}
\end{figure}

\begin{figure}[tbp]
\fbox{
\begin{minipage}{0.96\textwidth}
\small    
\[
\begin{array}{lcl}
\Atm &::=& \gray{ \Int \mid \Var \mid \itm{bool} } \\
\itm{cmp} &::= & \gray{ \key{eq?} \mid \key{<} } \\
\Exp &::=& \gray{ \Atm \mid \key{(read)} \mid \key{(-}~\Atm\key{)} \mid \key{(+}~\Atm~\Atm\key{)} } \\
  &\mid& \gray{ \LP \key{not}~\Atm \RP \mid \LP \itm{cmp}~\Atm~\Atm\RP } \\
&\mid& \LP \key{allocate}~\Int~\Type \RP \\
  &\mid& (\key{vector-ref}\;\Atm\;\Int) \mid (\key{vector-set!}\;\Atm\;\Int\;\Atm)\\
  &\mid& \LP \key{global-value}~\Var \RP \mid \LP \key{void} \RP \\
\Stmt &::=& \gray{ \Var~\key{=}~\Exp\key{;} } \mid \LP\key{collect}~\Int \RP\\
\Tail &::= & \gray{ \key{return}~\Exp\key{;} \mid \Stmt~\Tail } 
   \mid \gray{ \key{goto}~\itm{label}\key{;} }\\
   &\mid& \gray{ \key{if}~\LP \itm{cmp}~\Atm~\Atm \RP~ \key{goto}~\itm{label}\key{;} ~\key{else}~\key{goto}~\itm{label}\key{;} } \\
\LangCVec{} & ::= & \gray{ (\itm{label}\key{:}~ \Tail)\ldots }
\end{array}
\]
\end{minipage}
}
\caption{ \LangCVec{} 中间语言的具体语法。}
\label{fig:c2-concrete-syntax}
\end{figure}

\begin{figure}[tp]
\fbox{
\begin{minipage}{0.96\textwidth}
\small
\[
\begin{array}{lcl}
\Atm &::=& \gray{ \Int \mid \Var \mid \key{\#t} \mid \key{\#f} }
  \\
\itm{cmp} &::= & \gray{  \key{eq?} \mid \key{<} } \\
\Exp &::= & \gray{ \Atm \mid \LP\key{read}\RP \mid \LP\key{-}\;\Atm\RP \mid \LP\key{+} \; \Atm\;\Atm\RP
      \mid \LP\key{not}\;\Atm\RP \mid \LP\itm{cmp}\;\Atm\;\Atm\RP  } \\
   &\mid& \gray{  \LP\key{allocate}\,\Int\,\Type\RP
   \mid \LP\key{vector-ref}\, \Atm\, \Int\RP  } \\
   &\mid& \gray{  \LP\key{vector-set!}\,\Atm\,\Int\,\Atm\RP \mid \LP\key{global-value} \,\itm{name}\RP \mid \LP\key{void}\RP } \\
   &\mid& \LP\key{fun-ref}~\itm{label}\RP \mid \LP\key{call} \,\Atm\,\Atm\ldots\RP \\
\Stmt &::=& \gray{ \ASSIGN{\Var}{\Exp} \mid \RETURN{\Exp} 
       \mid \LP\key{collect} \,\itm{int}\RP }\\
\Tail &::= & \gray{\RETURN{\Exp} \mid \LP\key{seq}\;\Stmt\;\Tail\RP} \\
      &\mid& \gray{\LP\key{goto}\,\itm{label}\RP
       \mid \IF{\LP\itm{cmp}\, \Atm\,\Atm\RP}{\LP\key{goto}\,\itm{label}\RP}{\LP\key{goto}\,\itm{label}\RP}} \\
      &\mid& \LP\key{tail-call}\,\Atm\,\Atm\ldots\RP \\
  \Def &::=& \LP\key{define}\; \LP\itm{label} \; [\Var \key{:} \Type]\ldots\RP \key{:} \Type \; \LP\LP\itm{label}\,\key{.}\,\Tail\RP\ldots\RP\RP \\
\LangCFun{} & ::= & \Def\ldots
\end{array}
\]
\end{minipage}
}
\caption{ \LangCFun{} 语言，用函数扩展 \LangCVec{} (图~\ref{fig:c2-concrete-syntax}) 。}
\label{fig:c3-concrete-syntax}
\end{figure}

\cleardoublepage

\addcontentsline{toc}{chapter}{Index}
\printindex

\cleardoublepage

\bibliographystyle{plainnat}
\bibliography{all}
\addcontentsline{toc}{chapter}{Bibliography}


\end{document}

%%  LocalWords:  Dybvig Waddell Abdulaziz Ghuloum Dipanwita Sussman
%%  LocalWords:  Sarkar lcl Matz aa representable Chez Ph Dan's nano
%%  LocalWords:  fk bh Siek plt uq Felleisen Bor Yuh ASTs AST Naur eq
%%  LocalWords:  BNF fixnum datatype arith prog backquote quasiquote
%%  LocalWords:  ast Reynold's reynolds interp cond fx evaluator jane
%%  LocalWords:  quasiquotes pe nullary unary rcl env lookup gcc rax
%%  LocalWords:  addq movq callq rsp rbp rbx rcx rdx rsi rdi subq nx
%%  LocalWords:  negq pushq popq retq globl Kernighan uniquify lll ve
%%  LocalWords:  allocator gensym env subdirectory scm rkt tmp lhs Tt
%%  LocalWords:  runtime Liveness liveness undirected Balakrishnan je
%%  LocalWords:  Rosen DSATUR SDO Gebremedhin Omari morekeywords cnd
%%  LocalWords:  fullflexible vertices Booleans Listof Pairof thn els
%%  LocalWords:  boolean type-check notq cmpq sete movzbq jmp al xorq
%%  LocalWords:  EFLAGS thns elss elselabel endlabel Tuples tuples os
%%  LocalWords:  tuple args lexically leaq Polymorphism msg bool nums
%%  LocalWords:  macosx unix Cormen vec callee xs maxStack numParams
%%  LocalWords:  arg bitwise XOR'd thenlabel immediates optimizations
%%  LocalWords:  deallocating Ungar Detlefs Tene kx FromSpace ToSpace
%%  LocalWords:  Appel Diwan Siebert ptr  fromspace rootstack typedef
%%  LocalWords:  len prev rootlen heaplen setl lt Kohlbecker dk multi
% LocalWords: Bloomington Wollowski definitional whitespace deref JM
% LocalWords: subexpression subexpressions iteratively ANF Danvy rco
% LocalWords: goto stmt JS ly cmp ty le ge jle goto's EFLAG CFG pred
% LocalWords: acyclic worklist Aho qf tsort implementer's hj Shidal
% LocalWords: nonnegative Shahriyar endian salq sarq uint cheney ior
% LocalWords: tospace vecinit collectret alloc initret decrement jl
% LocalWords: dereferencing GC di vals ps mcons ds mcdr callee's th
% LocalWords: mainDef tailcall prepending mainstart num params rT qb
% LocalWords: mainconclusion Cardelli bodyT fvs clos fvts subtype uj
% LocalWords: polymorphism untyped elts tys tagof Vectorof tyeq orq
% LocalWords: andq untagged Shao inlining ebp jge setle setg setge
% LocalWords: struct Friedman's MacOS Nystrom alist sam kate
% LocalWords: alists arity github unordered pqueue exprs ret param
% LocalWords: tyerr bytereg dh dl JmpIf HasType Osterlund Jacek TODO
% LocalWords: Gamari GlobalValue ProgramDefsExp prm ProgramDefs vn
% LocalWords: FunRef TailCall tailjmp IndirectCallq TailJmp Gilray
% LocalWords: dereference unbox Dataflow versa dataflow Kildall rhs
% LocalWords: Kleene enqueue dequeue AssignedFree FV cnvt SetBang tg
% LocalWords: ValueOf typechecker
